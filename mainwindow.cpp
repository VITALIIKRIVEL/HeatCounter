#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QTextCodec>
#include <QFile>
#include <QFileDialog>
#include <QMessageBox>
#include "global.h"
#include <QThread>
#include <QTextStream>
#include <QDateTime>
#include <QPainter>
#include <QPalette>
#include <QKeyEvent>
#include <QCryptographicHash>
#include <QPixmap>
#include <QApplication>
#include <QDesktopWidget>


MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    repeatParameter = 0;
    connectCondition = false;
    isRunWithoutConnect = false;

    ui->textBrowser->setVisible(false);

    ui->toolButton_stopThreads->setVisible(false);
    ui->checkBox_OneWorkPlace->setVisible(false);
    ui->toolButton_result->setVisible(false);
    ui->toolButton_resultFileChecking->setVisible(false);
 //   ui->textBrowser->setVisible(false);
    ui->toolButton_clearTextBrowser->setVisible(false);

    ui->lineEdit_serial->setMaxLength(3);
    ui->lineEdit_serial_2->setMaxLength(3);
    ui->lineEdit_serial_3->setMaxLength(3);
    ui->lineEdit_serial_4->setMaxLength(3);

    ui->spinBox_serial_->setMinimum(00000);
    ui->spinBox_serial_->setMaximum(99999);
    ui->spinBox_serial_2->setMinimum(00000);
    ui->spinBox_serial_2->setMaximum(99999);
    ui->spinBox_serial_3->setMinimum(00000);
    ui->spinBox_serial_3->setMaximum(99999);
    ui->spinBox_serial_4->setMinimum(00000);
    ui->spinBox_serial_4->setMaximum(99999);

    formCalibration = new FormCalibration();
    formParamsEdit = new FormParamsEdit();
    formLog = new FormLog();
    formViewTable = new FormViewTable();
    formConnectionParams = new FormConnectionParams();
    formConnectionParams->setWindowModality(Qt::ApplicationModal);
    formUserControl = new Formusercontrol();
    formUserControl->setWindowModality(Qt::ApplicationModal);

    dialogUpdateNote = new DialogUpdateNote(this);
    dialogLoginDataBase = new DialogLoginDataBase();//(this);
    dialogWritingDB = new DialogWritingDB(this);
    dialogIsRunWithoutConnect = new DialogIsRunWithoutConnect();

    smartStend = new SmartStend();

    formCalibration->setWindowTitle("Калибровка");
    formParamsEdit->setWindowTitle("Параметры");
    formLog->setWindowTitle("Лог");
 //   dialogLoginDataBase->setWindowTitle("Вход");
    dialogUpdateNote->setWindowTitle("Проверка уникальности серийного номера");   

    ObjectThread1 = new ObjectThread(parent = 0);
    ObjectThread2 = new ObjectThread(parent = 0);
    ObjectThread3 = new ObjectThread(parent = 0);
    ObjectThread4 = new ObjectThread(parent = 0);


//    ObjectThread1->moveToThread(Thread1);
//    ObjectThread2->moveToThread(Thread2);
//    ObjectThread3->moveToThread(Thread3);
//    ObjectThread4->moveToThread(Thread4);


    cmd = new QProcess(this);
    port = new QSerialPort(this);
    portOptical = new QSerialPort(this);
    portOptical2 = new QSerialPort(this);
    portOptical3 = new QSerialPort(this);
    portOptical4 = new QSerialPort(this);
    portDigitalInterfaceChecking = new QSerialPort(this);
    QFont mainFont;
    mainFont.setPointSize(11);
//    ui->label_86->setFont(mainFont);
    ui->label_87->setFont(mainFont);
    ui->label_88->setFont(mainFont);
    ui->label_89->setFont(mainFont);

//    ui->textBrowser->setFont(mainFont);

    //получение информации о портах
    ui->comboBox_portList->clear();
    ui->comboBox_portListOptical->clear();
    ui->comboBox_portListOptical_2->clear();
    ui->comboBox_portListOptical_3->clear();
    ui->comboBox_portListOptical_4->clear();

    QList<QSerialPortInfo> info = QSerialPortInfo::availablePorts();
    for(int i=0; i<info.size(); i++) {
       ui->comboBox_portList->addItem(info[i].portName());
       ui->comboBox_portListOptical->addItem(info[i].portName());
       ui->comboBox_portListOptical_2->addItem(info[i].portName());
       ui->comboBox_portListOptical_3->addItem(info[i].portName());
       ui->comboBox_portListOptical_4->addItem(info[i].portName());
       ui->comboBox_portListInterfaceChecking->addItem(info[i].portName());
    }
    ui->comboBox_portList->setCurrentIndex(ui->comboBox_portList->count() - 1);
    ui->comboBox_portListOptical->setCurrentIndex(ui->comboBox_portListOptical->count() - 1);
    ui->comboBox_portListOptical_2->setCurrentIndex(ui->comboBox_portListOptical_2->count() - 1);
    ui->comboBox_portListOptical_3->setCurrentIndex(ui->comboBox_portListOptical_3->count() - 1);
    ui->comboBox_portListOptical_4->setCurrentIndex(ui->comboBox_portListOptical_4->count() - 1);
    ui->comboBox_portListInterfaceChecking->setCurrentIndex(ui->comboBox_portListInterfaceChecking->count() - 1);
    //

    ui->comboBox_portList->setCurrentIndex(0);
    port->setPortName(ui->comboBox_portList->itemText(0));
    portName = ui->comboBox_portList->itemText(0);

    //
    ui->comboBox_portListOptical->setCurrentIndex(0);
    portOptical->setPortName(ui->comboBox_portListOptical->itemText(0));
    portNameOptical = ui->comboBox_portListOptical->itemText(0);

    ui->comboBox_portListOptical_2->setCurrentIndex(0);
    portOptical2->setPortName(ui->comboBox_portListOptical_2->itemText(0));
    portNameOptical2 = ui->comboBox_portListOptical_2->itemText(0);

    ui->comboBox_portListOptical_3->setCurrentIndex(0);
    portOptical3->setPortName(ui->comboBox_portListOptical_3->itemText(0));
    portNameOptical3 = ui->comboBox_portListOptical_3->itemText(0);

    ui->comboBox_portListOptical_4->setCurrentIndex(0);
    portOptical4->setPortName(ui->comboBox_portListOptical_4->itemText(0));
    portNameOptical4 = ui->comboBox_portListOptical_4->itemText(0);
    //

    ui->comboBox_portListInterfaceChecking->setCurrentIndex(0);
    portDigitalInterfaceChecking->setPortName(ui->comboBox_portListInterfaceChecking->itemText(0));
    portNameInterfaceChecking = ui->comboBox_portListInterfaceChecking->itemText(0);
    //

    port->setBaudRate(QSerialPort::Baud115200);
    port->setDataBits(QSerialPort::Data8);
    port->setParity(QSerialPort::NoParity);
    port->setStopBits(QSerialPort::OneStop);

    //
    portOptical->setBaudRate(QSerialPort::Baud19200);
    portOptical->setDataBits(QSerialPort::Data8);
    portOptical->setParity(QSerialPort::NoParity);
    portOptical->setStopBits(QSerialPort::OneStop);

    portOptical2->setBaudRate(QSerialPort::Baud19200);
    portOptical2->setDataBits(QSerialPort::Data8);
    portOptical2->setParity(QSerialPort::NoParity);
    portOptical2->setStopBits(QSerialPort::OneStop);

    portOptical3->setBaudRate(QSerialPort::Baud19200);
    portOptical3->setDataBits(QSerialPort::Data8);
    portOptical3->setParity(QSerialPort::NoParity);
    portOptical3->setStopBits(QSerialPort::OneStop);

    portOptical4->setBaudRate(QSerialPort::Baud19200);
    portOptical4->setDataBits(QSerialPort::Data8);
    portOptical4->setParity(QSerialPort::NoParity);
    portOptical4->setStopBits(QSerialPort::OneStop);
    //

    portDigitalInterfaceChecking->setBaudRate(QSerialPort::Baud2400);
    portDigitalInterfaceChecking->setDataBits(QSerialPort::Data8);
    portDigitalInterfaceChecking->setParity(QSerialPort::EvenParity);
    portDigitalInterfaceChecking->setStopBits(QSerialPort::OneStop);

    connect(cmd, SIGNAL(readyRead()), this, SLOT(slotReadyRead()));
//    connect(portOptical, SIGNAL(readyRead()), this, SLOT(slotReadyReadOptical()));

    ui->toolButton_reverse->setVisible(false);
    ui->lineEdit_reverse->setVisible(false);

    manCodeList = QStringList()<<"SET"<<"SVT"<<"ETO";
    ui->comboBox_ManCode->addItems(manCodeList);
    devTypeList = QStringList()<<"Обратный"<<"Подающий"; //"04"<<"0c";
    ui->comboBox_DevType->addItems(devTypeList);
    DNList = QStringList()<<"15"<<"20";
    ui->comboBox_DN->addItems(DNList);
    pulsesMode1List = QStringList()<<"0"<<"1"<<"2"<<"5"<<"9";
    ui->comboBox_PulsesMode1->addItems(pulsesMode1List);
    ui->comboBox_PulsesMode2->addItems(pulsesMode1List);
    AverageTList = QStringList()<<"0"<<"1";
    ui->comboBox_Average_T->addItems(AverageTList);
    flowRateList = QStringList()<<"17.02"<<"33.02"<<"52.00";
    ui->comboBox_FlowRate->addItems(flowRateList);
    flowNomList = QStringList()<<"0.6"<<"1.5"<<"2.5";
    ui->comboBox_FlowNom->addItems(flowNomList);
    RTD_TypeList = QStringList()<<"Pt(W100 = 1,385)"<<"Pt(W100 = 1,391)"<<"Инд. х-ка преобр."<<"Pt(W100 = 1,375)";// "0"<<"1"<<"2"<<"3";
    ui->comboBox_RTD_Type->addItems(RTD_TypeList);
    ASW_flagList = QStringList()<<"0"<<"1";
    ui->comboBox_ASW_flag->addItems(ASW_flagList);
    BaudRateList = QStringList()<<"1200"<<"2400"<<"4800"<<"9600"; //<<"ba"<<"bb"<<"bc"<<"bd";
    ui->comboBox_BaudRate->addItem("1200", 0xba);
    ui->comboBox_BaudRate->addItem("2400", 0xbb);
    ui->comboBox_BaudRate->addItem("4800", 0xbc);
    ui->comboBox_BaudRate->addItem("9600", 0xbd);

//    ui->comboBox_BaudRate->addItems(BaudRateList);

//    ui->comboBox_DevType->setCurrentText("0c");

    ui->lineEdit_Flow_min->setText("0.008");
    ui->lineEdit_Flow_max->setText("3.5");

//    ui->lineEdit_serial->setMaxLength(9);

    ui->spinBox_Tin_min->setRange(10, 60);
    ui->spinBox_Tin_min->setValue(30);

    ui->spinBox_Tin_max->setRange(50, 150);
    ui->spinBox_Tin_max->setValue(120);

    ui->spinBox_Tout_min->setRange(10, 60);
    ui->spinBox_Tout_min->setValue(20);

    ui->spinBox_Tout_max->setRange(50, 150);
    ui->spinBox_Tout_max->setValue(120);

    ui->spinBox_ReportData->setValue(0);
    reportDataByteArray.clear();
    quint8 null =0;
    reportDataByteArray.append(null);

    //
    //set default value
    ui->comboBox_Average_T->setCurrentText("1");
    ui->lineEdit_Pressure->setText("6");
    ui->lineEdit_R_RTD->setText("1000");
    ui->lineEdit_RWire1->setText("0");
    ui->lineEdit_RWire2->setText("0");

    ui->lineEdit_coef0->setText("1.000000");
    ui->lineEdit_coef1->setText("1.000000");
    ui->lineEdit_coef2->setText("1.000000");
    ui->lineEdit_coef3->setText("1.000000");
    ui->lineEdit_coef4->setText("1.000000");
    ui->lineEdit_coef5->setText("1.000000");

    ui->lineEdit_FS_DiffThrs->setText("30");

    ui->dateTimeEdit_realClock->setDisplayFormat("dd.MM.yyyy hh:mm:ss");

    ui->lineEdit_Shift_T1->setText("0.00000");
    ui->lineEdit_Shift_T2->setText("0.00000");
    ui->lineEdit_Scale_T1->setText("1.00000");
    ui->lineEdit_Scale_T2->setText("1.00000");

    ui->spinBox_Addr->setValue(1);
    ui->comboBox_BaudRate->setCurrentText("bb");
    ui->lineEdit_HMP_Trans->setText("3fff");
    ui->lineEdit_EPP_Trans->setText("000f");
    ui->lineEdit_ProtType->setText("ff");

    ui->lineEdit_Serial_P1->setText("00000000");
    ui->lineEdit_ManCode_P1->setText("0000");
    ui->lineEdit_DevType_P1->setText("00");
    ui->lineEdit_Version_P1->setText("0");
    ui->lineEdit_Initial_value_P1->setText("0");
    ui->lineEdit_Service_P1->setText("00000000");

    ui->lineEdit_Serial_P2->setText("00000000");
    ui->lineEdit_ManCode_P2->setText("0000");
    ui->lineEdit_DevType_P2->setText("00");
    ui->lineEdit_Version_P2->setText("0");
    ui->lineEdit_Initial_value_P2->setText("0");
    ui->lineEdit_Service_P2->setText("00000000");
    //
    //

    pulsesValue1ByteArray.clear();
    pulsesValue1ByteArray.append(null);
    pulsesValue1ByteArray.append(null);

    pulsesValue2ByteArray.clear();
    pulsesValue2ByteArray.append(null);
    pulsesValue2ByteArray.append(null);

    //editable(false)
//    ui->lineEdit_Pressure->setEnabled(false);
//    ui->lineEdit_R_RTD->setEnabled(false);
//    ui->lineEdit_RWire1->setEnabled(false);
//    ui->lineEdit_RWire2->setEnabled(false);

//    ui->lineEdit_coef0->setEnabled(false);
//    ui->lineEdit_coef1->setEnabled(false);
//    ui->lineEdit_coef2->setEnabled(false);
//    ui->lineEdit_coef3->setEnabled(false);
//    ui->lineEdit_coef4->setEnabled(false);
//    ui->lineEdit_coef5->setEnabled(false);

//    ui->lineEdit_FS_DiffThrs->setEnabled(false);

    connect(this, SIGNAL(sendbufferReadHardwareConfiguration(QByteArray, int)), formParamsEdit, SLOT(getbufferReadHardwareConfiguration(QByteArray, int)));
    connect(this, SIGNAL(sendbufferReadSoftWareConfiguration(QByteArray)), formParamsEdit, SLOT(getbufferReadSoftWareConfiguration(QByteArray)));
    connect(this, SIGNAL(sendbufferReadSensorParameters(QByteArray)), formParamsEdit, SLOT(getbufferReadSensorParameters(QByteArray)));
    connect(this, SIGNAL(sendbufferReadFlowCoefficient(QByteArray)), formParamsEdit, SLOT(getbufferReadFlowCoefficient(QByteArray)));
    connect(this, SIGNAL(sendbufferReadCalibrationFactor(QByteArray)), formParamsEdit, SLOT(getbufferReadCalibrationFactor(QByteArray)));
    connect(this, SIGNAL(sendbufferReadRealClock(QByteArray)), formParamsEdit, SLOT(getbufferReadRealClock(QByteArray)));
    connect(this, SIGNAL(sendbufferReadCalibrationFactor2(QByteArray)), formParamsEdit, SLOT(getbufferReadCalibrationFactor2(QByteArray)));
    connect(this, SIGNAL(sendbufferReadExternalInterfaceSettings(QByteArray)), formParamsEdit, SLOT(getbufferReadExternalInterfaceSettings(QByteArray)));
    connect(this, SIGNAL(sendbufferReadExternalDeviceSettings(QByteArray)), formParamsEdit, SLOT(getbufferReadExternalDeviceSettings(QByteArray)));


    connect(formParamsEdit, SIGNAL(sendParamsMap(QMap<QString, QByteArray>)), this, SLOT(slotGetParamsMap(QMap<QString, QByteArray>)));
    connect(formCalibration, SIGNAL(startCalibration(QMap<QString, QByteArray>, QMap<QString, float>)),
            this, SLOT(slotStartCalibration(QMap<QString,QByteArray>, QMap<QString, float>)));
    connect(formCalibration, SIGNAL(signalStartRealClockCalibration(quint16)), this, SLOT(slotStartRealClockCalibation(quint16)));

    connect(formParamsEdit, SIGNAL(signalReadParams()), this, SLOT(slotReadParams()));
    connect(formParamsEdit, SIGNAL(signalWriteParams()), this, SLOT(slotWriteParams()));

    connect(this, SIGNAL(sendParamsStringListFromFileToFormParamsedit(QStringList)), formParamsEdit, SLOT(slotGetParamsStringListFromFileFromMainWindow(QStringList)));

    connect(this, SIGNAL(signalSendSerial(QString)), formParamsEdit, SLOT(slotGetSerial(QString)));
    connect(this, SIGNAL(signalSendSerial2(QString)), formParamsEdit, SLOT(slotGetSerial2(QString)));
    connect(this, SIGNAL(signalSendSerial3(QString)), formParamsEdit, SLOT(slotGetSerial3(QString)));
    connect(this, SIGNAL(signalSendSerial4(QString)), formParamsEdit, SLOT(slotGetSerial4(QString)));

    connect(formParamsEdit, SIGNAL(signalSendSerialFromParamsEdit(QString)), this, SLOT(slotGetSerialFromParamsEdit(QString)));
    connect(formParamsEdit, SIGNAL(signalSendSerial2FromParamsEdit(QString)), this, SLOT(slotGetSerial2FromParamsEdit(QString)));
    connect(formParamsEdit, SIGNAL(signalSendSerial3FromParamsEdit(QString)), this, SLOT(slotGetSerial3FromParamsEdit(QString)));
    connect(formParamsEdit, SIGNAL(signalSendSerial4FromParamsEdit(QString)), this, SLOT(slotGetSerial4FromParamsEdit(QString)));

    connect(this, SIGNAL(signalReadParams(int)), this, SLOT(readParams(int)));
 //   connect(this, &MainWindow::signalReadParams, this, &MainWindow::readParams);

//    connect(this, SIGNAL(signalWriteParams(int)), this, SLOT(slotNewThreadOne()));

  //  connect(this, SIGNAL(signalWriteParams(int)), this, SLOT(writeParams(int)), Qt::DirectConnection);

//    connect(this, SIGNAL(signalWriteParams2(int)), this, SLOT(writeParams2(int)), Qt::DirectConnection);
//    connect(this, SIGNAL(signalWriteParams3(int)), this, SLOT(writeParams3(int)), Qt::DirectConnection);
//    connect(this, SIGNAL(signalWriteParams4(int)), this, SLOT(writeParams4(int)), Qt::DirectConnection);

//    connect(this, SIGNAL(signalWriteParams(int)), this, SLOT(writeParams(int)), Qt::DirectConnection);
//    connect(this, SIGNAL(signalWriteParams(int)), this, SLOT(writeParams2(int)), Qt::DirectConnection);
//    connect(this, SIGNAL(signalWriteParams(int)), this, SLOT(writeParams3(int)), Qt::DirectConnection);
//    connect(this, SIGNAL(signalWriteParams(int)), this, SLOT(writeParams4(int)), Qt::DirectConnection);


//    connect(this, &MainWindow::signalWriteParamsToThread, ObjectThread1, &ObjectThread::slotWriteParams);
//    connect(this, &MainWindow::signalWriteParamsToThread, ObjectThread2, &ObjectThread::slotWriteParams);

    //writing connect

    connect(this, SIGNAL(signalWriteParamsToThread(QSerialPort*, QSerialPort*, QSerialPort*, QSerialPort*)),
                         ObjectThread1, SLOT(slotWriteParams(QSerialPort*, QSerialPort*, QSerialPort*, QSerialPort*)));
    connect(this, SIGNAL(signalWriteParamsToThread(QSerialPort*, QSerialPort*, QSerialPort*, QSerialPort*)),
                         ObjectThread2, SLOT(slotWriteParams(QSerialPort*, QSerialPort*, QSerialPort*, QSerialPort*)));
    connect(this, SIGNAL(signalWriteParamsToThread(QSerialPort*, QSerialPort*, QSerialPort*, QSerialPort*)),
                         ObjectThread3, SLOT(slotWriteParams(QSerialPort*, QSerialPort*, QSerialPort*, QSerialPort*)));
    connect(this, SIGNAL(signalWriteParamsToThread(QSerialPort*, QSerialPort*, QSerialPort*, QSerialPort*)),
                         ObjectThread4, SLOT(slotWriteParams(QSerialPort*, QSerialPort*, QSerialPort*, QSerialPort*)));

    connect(ObjectThread1, SIGNAL(checkWritingError(int)), this,
            SLOT(slotCheckWritingError(int)));
    connect(ObjectThread2, SIGNAL(checkWritingError(int)), this,
            SLOT(slotCheckWritingError(int)));
    connect(ObjectThread3, SIGNAL(checkWritingError(int)), this,
            SLOT(slotCheckWritingError(int)));
    connect(ObjectThread4, SIGNAL(checkWritingError(int)), this,
            SLOT(slotCheckWritingError(int)));

    //writing connect/

    //calibration connect

    connect(this, SIGNAL(signalCalibrationToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
                         ObjectThread1, SLOT(slotCalibration(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalCalibrationToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
                         ObjectThread2, SLOT(slotCalibration(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalCalibrationToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
                         ObjectThread3, SLOT(slotCalibration(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalCalibrationToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
                         ObjectThread4, SLOT(slotCalibration(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));

    connect(ObjectThread1, SIGNAL(checkCalibrationError(int)), this,
            SLOT(slotCheckCalibrationError(int)));
    connect(ObjectThread2, SIGNAL(checkCalibrationError(int)), this,
            SLOT(slotCheckCalibrationError(int)));
    connect(ObjectThread3, SIGNAL(checkCalibrationError(int)), this,
            SLOT(slotCheckCalibrationError(int)));
    connect(ObjectThread4, SIGNAL(checkCalibrationError(int)), this,
            SLOT(slotCheckCalibrationError(int)));

    connect(ObjectThread1, SIGNAL(signalRMV(int,QString,int)), this, SLOT(slotGetRMV(int,QString,int)));
    connect(ObjectThread2, SIGNAL(signalRMV(int,QString,int)), this, SLOT(slotGetRMV(int,QString,int)));
    connect(ObjectThread3, SIGNAL(signalRMV(int,QString,int)), this, SLOT(slotGetRMV(int,QString,int)));
    connect(ObjectThread4, SIGNAL(signalRMV(int,QString,int)), this, SLOT(slotGetRMV(int,QString,int)));

    //calibration connect/

    //pulseotputheat connect

    connect(this, SIGNAL(signalPulsesOutputHeatToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
                         ObjectThread1, SLOT(slotPulsesOutputHeat(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalPulsesOutputHeatToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
                         ObjectThread2, SLOT(slotPulsesOutputHeat(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalPulsesOutputHeatToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
                         ObjectThread3, SLOT(slotPulsesOutputHeat(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalPulsesOutputHeatToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
                         ObjectThread4, SLOT(slotPulsesOutputHeat(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));


    connect(ObjectThread1, SIGNAL(checkPulsesOutputHeat(int)), this,
            SLOT(slotCheckPulsesOutputHeatError(int)));
    connect(ObjectThread2, SIGNAL(checkPulsesOutputHeat(int)), this,
            SLOT(slotCheckPulsesOutputHeatError(int)));
    connect(ObjectThread3, SIGNAL(checkPulsesOutputHeat(int)), this,
            SLOT(slotCheckPulsesOutputHeatError(int)));
    connect(ObjectThread4, SIGNAL(checkPulsesOutputHeat(int)), this,
            SLOT(slotCheckPulsesOutputHeatError(int)));


    //pulseotputheat connect/


    //pulsesInputVolume connect

    connect(this, SIGNAL(signalPulsesInputVolToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread1, SLOT(slotPulsesInputVolume(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalPulsesInputVolToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread2, SLOT(slotPulsesInputVolume(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalPulsesInputVolToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread3, SLOT(slotPulsesInputVolume(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalPulsesInputVolToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread4, SLOT(slotPulsesInputVolume(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));


    connect(ObjectThread1, SIGNAL(checkPulsesInputVolume(int)),
            this, SLOT(slotCheckPulsesInputVolumeError(int)));
    connect(ObjectThread2, SIGNAL(checkPulsesInputVolume(int)),
            this, SLOT(slotCheckPulsesInputVolumeError(int)));
    connect(ObjectThread3, SIGNAL(checkPulsesInputVolume(int)),
            this, SLOT(slotCheckPulsesInputVolumeError(int)));
    connect(ObjectThread4, SIGNAL(checkPulsesInputVolume(int)),
            this, SLOT(slotCheckPulsesInputVolumeError(int)));

    //pulsesInputVolume connect/


    //pulsesOutputDefault connect

    connect(this, SIGNAL(signalPulsesOutputDefToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread1, SLOT(slotPulsesOutputDefault(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalPulsesOutputDefToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread2, SLOT(slotPulsesOutputDefault(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalPulsesOutputDefToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread3, SLOT(slotPulsesOutputDefault(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalPulsesOutputDefToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread4, SLOT(slotPulsesOutputDefault(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));

    connect(ObjectThread1, SIGNAL(checkPulsesOutputDefault(int)),
            this, SLOT(slotCheckPulsesOutputDefError(int)));
    connect(ObjectThread2, SIGNAL(checkPulsesOutputDefault(int)),
            this, SLOT(slotCheckPulsesOutputDefError(int)));
    connect(ObjectThread3, SIGNAL(checkPulsesOutputDefault(int)),
            this, SLOT(slotCheckPulsesOutputDefError(int)));
    connect(ObjectThread4, SIGNAL(checkPulsesOutputDefault(int)),
            this, SLOT(slotCheckPulsesOutputDefError(int)));

    //pulsesOutputDefault connect/


    //mbusOn connect

    connect(this, SIGNAL(signalMBusOnToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread1, SLOT(slotMBusOn(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalMBusOnToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread2, SLOT(slotMBusOn(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalMBusOnToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread3, SLOT(slotMBusOn(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalMBusOnToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread4, SLOT(slotMBusOn(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));

    connect(ObjectThread1, SIGNAL(checkMBusOn(int)), this, SLOT(slotCheckMBusOnError(int)));
    connect(ObjectThread2, SIGNAL(checkMBusOn(int)), this, SLOT(slotCheckMBusOnError(int)));
    connect(ObjectThread3, SIGNAL(checkMBusOn(int)), this, SLOT(slotCheckMBusOnError(int)));
    connect(ObjectThread4, SIGNAL(checkMBusOn(int)), this, SLOT(slotCheckMBusOnError(int)));

    //mbusOn connect/


    //checkMbus connect

    connect(this, SIGNAL(signalCheckMBusToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread1, SLOT(slotMBusCheck(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalCheckMBusToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread2, SLOT(slotMBusCheck(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalCheckMBusToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread3, SLOT(slotMBusCheck(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalCheckMBusToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread4, SLOT(slotMBusCheck(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));

    connect(ObjectThread1, SIGNAL(checkMBusCheck(int)), this, SLOT(slotCheckMBusCheckError(int)));
    connect(ObjectThread2, SIGNAL(checkMBusCheck(int)), this, SLOT(slotCheckMBusCheckError(int)));
    connect(ObjectThread3, SIGNAL(checkMBusCheck(int)), this, SLOT(slotCheckMBusCheckError(int)));
    connect(ObjectThread4, SIGNAL(checkMBusCheck(int)), this, SLOT(slotCheckMBusCheckError(int)));

    //checkMbus connect



    //calibrationModeOff connect

    connect(this, SIGNAL(signalCalibModeOffToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread1, SLOT(slotCalibrationModeOff(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalCalibModeOffToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread2, SLOT(slotCalibrationModeOff(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalCalibModeOffToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread3, SLOT(slotCalibrationModeOff(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalCalibModeOffToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread4, SLOT(slotCalibrationModeOff(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));

    connect(ObjectThread1, SIGNAL(checkCalibrationModeOff(int)), this, SLOT(slotCheckCalibModeOffError(int)));
    connect(ObjectThread2, SIGNAL(checkCalibrationModeOff(int)), this, SLOT(slotCheckCalibModeOffError(int)));
    connect(ObjectThread3, SIGNAL(checkCalibrationModeOff(int)), this, SLOT(slotCheckCalibModeOffError(int)));
    connect(ObjectThread4, SIGNAL(checkCalibrationModeOff(int)), this, SLOT(slotCheckCalibModeOffError(int)));

    //calibrationModeOff connect


    //wireInterfaceChecking connect

    connect(this, SIGNAL(signalDigitalInterfaceToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread1, SLOT(slotWireInterfaceChecking(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalDigitalInterfaceToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread2, SLOT(slotWireInterfaceChecking(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalDigitalInterfaceToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread3, SLOT(slotWireInterfaceChecking(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalDigitalInterfaceToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread4, SLOT(slotWireInterfaceChecking(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));

    connect(ObjectThread1, SIGNAL(checkWireInterfaceChecking(int)), this, SLOT(slotCheckWireInterfaceChecking(int)));
    connect(ObjectThread2, SIGNAL(checkWireInterfaceChecking(int)), this, SLOT(slotCheckWireInterfaceChecking(int)));
    connect(ObjectThread3, SIGNAL(checkWireInterfaceChecking(int)), this, SLOT(slotCheckWireInterfaceChecking(int)));
    connect(ObjectThread4, SIGNAL(checkWireInterfaceChecking(int)), this, SLOT(slotCheckWireInterfaceChecking(int)));

    //wireInterfaceChecking connect/


    //mbusOff connect

    connect(this, SIGNAL(signalMBusOffToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread1, SLOT(slotMBusOff(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalMBusOffToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread2, SLOT(slotMBusOff(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalMBusOffToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread3, SLOT(slotMBusOff(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));
    connect(this, SIGNAL(signalMBusOffToThread(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)),
            ObjectThread4, SLOT(slotMBusOff(QSerialPort*,QSerialPort*,QSerialPort*,QSerialPort*)));

    connect(ObjectThread1, SIGNAL(checkMbusOff(int)), this, SLOT(slotCheckMBusOffError(int)));
    connect(ObjectThread2, SIGNAL(checkMbusOff(int)), this, SLOT(slotCheckMBusOffError(int)));
    connect(ObjectThread3, SIGNAL(checkMbusOff(int)), this, SLOT(slotCheckMBusOffError(int)));
    connect(ObjectThread4, SIGNAL(checkMbusOff(int)), this, SLOT(slotCheckMBusOffError(int)));

    //mbusOff connect/



 //   connect(gef1, SIGNAL(toLog(LogType,QString)), this, SLOT(slotGetLogFromGefest(QString)));

//    connect(ObjectThread1, SIGNAL(textBrowser(QString)),this, SLOT(slotGetLog(QString)));
//    connect(ObjectThread2, SIGNAL(textBrowser(QString)),this, SLOT(slotGetLog(QString)));
//    connect(ObjectThread3, SIGNAL(textBrowser(QString)),this, SLOT(slotGetLog(QString)));
//    connect(ObjectThread4, SIGNAL(textBrowser(QString)),this, SLOT(slotGetLog(QString)));

    connect(ObjectThread1, &ObjectThread::textBrowser, this, &MainWindow::slotGetLog);
    connect(ObjectThread2, &ObjectThread::textBrowser, this, &MainWindow::slotGetLog);
    connect(ObjectThread3, &ObjectThread::textBrowser, this, &MainWindow::slotGetLog);
    connect(ObjectThread4, &ObjectThread::textBrowser, this, &MainWindow::slotGetLog);

    connect(ObjectThread1, &ObjectThread::errorStringSignal, this, &MainWindow::slotError);
    connect(ObjectThread2, &ObjectThread::errorStringSignal, this, &MainWindow::slotError);
    connect(ObjectThread3, &ObjectThread::errorStringSignal, this, &MainWindow::slotError);
    connect(ObjectThread4, &ObjectThread::errorStringSignal, this, &MainWindow::slotError);

    connect(ObjectThread1, &ObjectThread::workPlaceOff, this, &MainWindow::slotWorkPlaceOff);
    connect(ObjectThread2, &ObjectThread::workPlaceOff, this, &MainWindow::slotWorkPlaceOff);
    connect(ObjectThread3, &ObjectThread::workPlaceOff, this, &MainWindow::slotWorkPlaceOff);
    connect(ObjectThread4, &ObjectThread::workPlaceOff, this, &MainWindow::slotWorkPlaceOff);

//    connect(ObjectThread1, &ObjectThread::errorStringSignal, this, &MainWindow::slotGetLog);
//    connect(ObjectThread2, &ObjectThread::errorStringSignal, this, &MainWindow::slotGetLog);
//    connect(ObjectThread3, &ObjectThread::errorStringSignal, this, &MainWindow::slotGetLog);
//    connect(ObjectThread4, &ObjectThread::errorStringSignal, this, &MainWindow::slotGetLog);


 //   QThread::moveToThread()

    connect(this, SIGNAL(signalCalibration(int)), this, SLOT(calibration(int)));
    connect(this, SIGNAL(signalPulsesOutputHeat(int)), this, SLOT(pulsesOutputHeat(int)));
    connect(this,SIGNAL(signalPulsesInputVolume(int)), this, SLOT(pulsesInputVolume(int)));
    connect(this, SIGNAL(signalPulsesOutputDefault(int)), this, SLOT(pulsesOutputDefault(int)));
    connect(this, SIGNAL(signalMBusOn(int)), this, SLOT(MBusOn(int)));
    connect(this, SIGNAL(signalMBusCheck(int)), this, SLOT(MBusCheck(int)));
    connect(this, SIGNAL(signalCalibrationModeOff(int)), this, SLOT(calibrationModeOff(int)));
    connect(this, SIGNAL(signalWireInterfaceChecking(int)), this, SLOT(wireInterfaceChecking(int)));
    connect(this, SIGNAL(signalMBusOff(int)), this, SLOT(MBusOff(int)));

    connect(this, SIGNAL(signalLog(QString)), formLog, SLOT(slotGetLog(QString)));

    connect(&timerWriteParams, SIGNAL(timeout()), this, SLOT(slotTimerWriteParams()));
//    connect(&timerCalibration, SIGNAL(timeout()), this, SLOT(slotTimerCalibration()));
//    connect(&timerPulsesOutputHeat, SIGNAL(timeout()), this, SLOT(slotTimerPulsesOutputHeat()));
//    connect(&timerPulsesInputVolume, SIGNAL(timeout()), this, SLOT(slotTimerPulsesInputVolume()));
//    connect(&timerPulsesOutputOff, SIGNAL(timeout()), this, SLOT(slotTimerPulsesOutputOff()));
//    connect(&timerCheckMbus, SIGNAL(timeout()), this, SLOT(slotTimerCheckMbus()));
//    connect(&timerCalibrationModeOff, SIGNAL(timeout()), this, SLOT(slotTimerCalibrationModeOff()));
//    connect(&timerDigitalWireInterfaceChecking, SIGNAL(timeout()), this, SLOT(slotTimerDigitalWireInterfaceChecking()));


    //
    connect(this, SIGNAL(sendNoteDataToDialofForm(QString,QString,int,QString,int)), dialogUpdateNote, SLOT(slotGetNoteData(QString,QString,int,QString,int)));

    //
    connect(dialogLoginDataBase, SIGNAL(sendLoginPassword(QString,QString,bool)), this, SLOT(slotGetLoginPassword(QString,QString,bool)));
    connect(dialogLoginDataBase, SIGNAL(signalClose()), this, SLOT(slotGetSignalCloseLogin()));

    //
    connect(portOptical, SIGNAL(errorOccurred(QSerialPort::SerialPortError)),
            this, SLOT(slotPort1AnyError(QSerialPort::SerialPortError)));
    connect(portOptical2, SIGNAL(errorOccurred(QSerialPort::SerialPortError)),
            this, SLOT(slotPort2AnyError(QSerialPort::SerialPortError)));
    connect(portOptical3, SIGNAL(errorOccurred(QSerialPort::SerialPortError)),
            this, SLOT(slotPort3AnyError(QSerialPort::SerialPortError)));
    connect(portOptical4, SIGNAL(errorOccurred(QSerialPort::SerialPortError)),
            this, SLOT(slotPort4AnyError(QSerialPort::SerialPortError)));
    connect(portDigitalInterfaceChecking, SIGNAL(errorOccurred(QSerialPort::SerialPortError)),
            this, SLOT(slotPortDigatalInterAnyError(QSerialPort::SerialPortError)));


    connect(this, SIGNAL(sendLogPasFromSettings(QString,QString)), dialogLoginDataBase, SLOT(slotGetLogPasFromSettings(QString,QString)));


    connect(this, SIGNAL(sendTableListToTableForm(QStringList, QString, QMap<int, QString>, QStringList, QList<int>)),
            formViewTable, SLOT(slotGetTableList(QStringList, QString, QMap<int, QString>, QStringList, QList<int>)));

    connect(formViewTable, SIGNAL(updateTable()), this, SLOT(on_ResultTable_triggered()));

    connect(this, SIGNAL(sendUserList(QStringList)), dialogLoginDataBase, SLOT(slotGetUserList(QStringList)));
    connect(this, SIGNAL(sendUserTable(QStringList)), formViewTable, SLOT(slotGetUserList(QStringList)));

    connect(formConnectionParams, SIGNAL(sendParamsConnection(QStringList)), this, SLOT(slotGetParamsConnection(QStringList)));
    connect(this, SIGNAL(sendParamsConnectFromSettings(QStringList)), formConnectionParams, SLOT(slotGetConnectParamsFromMW(QStringList)));
    connect(dialogLoginDataBase, SIGNAL(signalShowConnectParams()), this, SLOT(slotGetSignalShowConnPar()));

    connect(this, SIGNAL(sendUserTable(QStringList)), formUserControl, SLOT(slotGetListUserTable(QStringList)));

    //управление пользователями

    connect(formUserControl, SIGNAL(sendVectorToQueryAdd(QVector<QString>)),
            this, SLOT(slotAddUser(QVector<QString>)));
    connect(formUserControl, SIGNAL(sendVectorToQueryChange(QVector<QString>)),
            this, SLOT(slotChangeUser(QVector<QString>)));
    connect(formUserControl, SIGNAL(sendVectorToQueryRemove(QVector<QString>)),
            this, SLOT(slotDeleteUser(QVector<QString>)));

    connect(this, SIGNAL(sendCurrentUser(QString)), formUserControl, SLOT(slotGetCurrentUser(QString)));
    //управление пользователями/

    //    void slotTimerWriteParams();
    //    void slotTimerCalibration();
    //    void slotTimerPulsesOutputHeat();
    //    void slotTimerPulsesInputVolume();
    //    void slotTimerPulsesOutputOff();
    //    void slotTimerCheckMbus();
    //    void slotTimerCalibrationModeOff();
    //    void slotTimerDigitalWireInterfaceChecking();

//    ui->lineEdit_Shift_T1->setEnabled(false);
//    ui->lineEdit_Shift_T2->setEnabled(false);
//    ui->lineEdit_Scale_T1->setEnabled(false);
//    ui->lineEdit_Scale_T2->setEnabled(false);

    ui->groupBox_CalibrationFactor->setVisible(false);
    ui->groupBox_CalibrationFactor2->setVisible(false);
    ui->groupBox_ExternalDeviceSettings->setVisible(false);
    ui->groupBox_ExternalInterfaceSettings->setVisible(false);
    ui->groupBox_FlowCoefficient->setVisible(false);
//    ui->groupBox_HarwareConfiguration->setVisible(false);
    ui->groupBox_RealClock->setVisible(false);
    ui->groupBox_SensorParameters->setVisible(false);
    ui->groupBox_SoftwareConfiguration->setVisible(false);
    ui->toolButton_readPassword->setVisible(false);
    ui->toolButton_readParams->setVisible(false);
//    ui->toolButton_writeParams->setVisible(false);
    ui->toolButton_saveTemplate->setVisible(false);
 //   ui->toolButton_loadTemplate->setVisible(false);
    ui->label_61->setVisible(false);
    ui->comboBox_RTD_Type_2->setVisible(false);
    ui->label_80->setVisible(false);
    ui->label_81->setVisible(false);
    ui->lineEdit_Acceptable_TMeasDir_2->setVisible(false);
    ui->lineEdit_Acceptable_TMeasRev_2->setVisible(false);

    ui->groupBox->setVisible(false);

    //

    QStringList RTD_Type_2_List = QStringList()<<"0"<<"1"<<"2"<<"3";
    ui->comboBox_RTD_Type_2->addItems(RTD_Type_2_List);

    QStringList configFileFormat = QStringList()<<"R_Real1"<<"R_Real2"<<"Temperature1_type0"<<"Temperature2_type0"<<
                                                  "Temperature1_type1"<<"Temperature2_type1"<<
                                                  "Temperature1_type2"<<"Temperature2_type2"<<
                                                  "Temperature1_type3"<<"Temperature2_type3"<<
                                                  "Acceptable_R_Ref1"<<"Acceptable_R_Ref2"<<
                                                  "Acceptable_TMeasDir"<<"Acceptable_TMeasRev"<<
                                                  "Error_R_Reff1"<<"Error_R_Reff2"<<
                                                  "Error_TMeasDir"<<"Error_TMeasRev";

    allParamsNameList = QStringList()<<"serialNumber"<<
"serialNumber2"<<
"serialNumber3"<<
"serialNumber4"<<
"manCode"<<
"devType"<<
"DN"<<
"PCB_SN_ByteArray"<<
"PCB_SN_ByteArray2"<<
"PCB_SN_ByteArray3"<<
"PCB_SN_ByteArray4"<<
"flowMinByteArray"<<
"flowMaxByteArray"<<
"tinMinByteArray"<<
"tinMaxByteArray"<<
"toutMinByteArray"<<
"toutMaxByteArray"<<
"reportDataByteArray"<<
     "averageTByteArray"<<
     "pulsesMode1ByteArray"<<
     "pulsesMode2ByteArray"<<
     "pulsesValue1ByteArray"<<
     "pulsesValue2ByteArray"<<
    //Read Sensor Parameters      5a00050b
     "flowRateByteArray"<<
     "pressureByteArray"<<
     "RTD_TypeByteArray"<<
     "R_RTDByteArray"<<
     "RWire1ByteArray"<<
     "RWire2ByteArray"<<
     "flowNomByteArray"<<
    //Read Flow Coefficient  5a 00 05 1d
     "flowCoef0ByteArray"<<
     "flowCoef1ByteArray"<<
     "flowCoef2ByteArray"<<
     "flowCoef3ByteArray"<<
     "flowCoef4ByteArray"<<
     "flowCoef5ByteArray"<<
    //Read Calibration Factor 5a 00 05 06
     "FS_DiffThrsByteArray"<<
    //Read Real Clock 5a 00 05 05
     "hourByteArray"<<
     "minuteByteArray"<<
     "secondByteArray"<<
     "dayByteArray"<<
     "monthByteArray"<<
     "yearByteArray"<<
     "DOWByteArray"<<
     "ASW_flagByteArray"<<
    //Read Calibration Factor
     "shift_T1ByteArray"<<
     "shift_T2ByteArray"<<
     "scale_T1ByteArray"<<
     "scale_T2ByteArray"<<
    //Read External Interface Settings
     "addrByteArray"<<
     "baudRateByteArray"<<
     "HMP_TransByteArray"<<
     "EPP_TransByteArray"<<
     "P1PrimAddrByteArray"<<
     "P2PrimAddrByteArray"<<
     "ProtTypeByteArray"<<
    //External Device Settings
     "Serial_P1ByteArray"<<
     "ManCode_P1ByteArray"<<
     "DevType_P1ByteArray"<<
     "Version_P1ByteArray"<<
     "Initial_value_P1ByteArray"<<
     "Service_P1ByteArray"<<
     "Serial_P2ByteArray"<<
     "ManCode_P2ByteArray"<<
     "DevType_P2ByteArray"<<
     "Version_P2ByteArray"<<
     "Initial_value_P2ByteArray"<<
     "Service_P2ByteArray";

    qDebug()<<"allParamsNameList "<<allParamsNameList
            <<"allParamsNameList.size()"<<allParamsNameList.size();

    ui->toolButton_programmingBSL->setEnabled(false);
    ui->toolButton_writeParams->setEnabled(false);
    ui->toolButton_startCalibration->setEnabled(false);
    ui->toolButton_realClockCalibration->setEnabled(false);
    ui->toolButton_pulsesInputVolume->setEnabled(false);
    ui->toolButton_pulsesOutputHeat->setEnabled(false);
    ui->toolButton_pulsesOutputOff->setEnabled(false);
    ui->toolButton_digitalWireInterfaceChecking->setEnabled(false);
    ui->toolButton_MBusOn->setEnabled(false);

    ui->toolButton_MBusOff->setEnabled(false);

//    ui->toolButton_MBusOff->setVisible(false);

    ui->toolButton_CheckMbus->setEnabled(false);
    ui->toolButton_calibrationModeOff->setEnabled(false);

    ui->toolButton_result->setEnabled(false);
    ui->toolButton_resultFileChecking->setEnabled(true);

    ui->toolButton_sendCommandOptical->setVisible(false);
    ui->lineEdit_sendCommandOptical->setVisible(false);

 //   ui->lineEdit_serial->setVisible(false);
    ui->groupBox_2->setVisible(false);



//    ui->toolButton_result->setVisible(false);
//    ui->toolButton_resultFileChecking->setVisible(false);


//    QColor color(255, 127, 50);
//    ui->label_digitalWireInterfaceChecking->setStyleSheet(QString("color: green").arg(color.name()));
//    ui->label_digitalWireInterfaceChecking->setText("V");
//    ui->label_digitalWireInterfaceChecking->setVisible(true);

    ui->spinBox_serial->setMaximum(99999999);
    ui->spinBox_serial->setVisible(false);

//    qDebug()<<"this->styleSheet() "<<this->styleSheet();

//    QWidget;

 //   ui->toolButton_externalServerConnect->setVisible(false);
    ui->toolButton_serverConnect->setVisible(false);
    ui->toolButton_createJson->setVisible(false);
    ui->toolButton_execSql->setVisible(false);
    ui->toolButton_addNoteToTable->setVisible(false);
    ui->toolButton_uniqNumChecking->setVisible(false);
    ui->lineEdit_SqlQuery->setVisible(false);
    ui->lineEdit_serNum->setVisible(false);
    ui->label_91->setVisible(false);
    ui->lineEdit_userDB->setVisible(false);
    ui->label_86->setVisible(false);
    ui->lineEdit_userPassword->setVisible(false);

    ui->toolButton_externalServerConnect->setVisible(false);

    //
    //
    ui->groupBox_old->setVisible(false);

    vectorIsWorkPlaceUse.resize(4);
    vectorIsWorkPlaceUse.fill(false);

    vectorIsCommandUse.resize(10);
    vectorIsCommandUse.fill(false);

    vectorIsErrorOccured.resize(4);
    vectorIsErrorOccured.fill(false);

//    ui->lineEdit_serial->setText("11111111");
//    ui->lineEdit_serial_2->setText("22222222");
//    ui->lineEdit_serial_3->setText("33333333");
//    ui->lineEdit_serial_4->setText("44444444");

    vectorIndicatorStateMatrix.resize(10);

    for(int u=0; u<10; u++) {
        vectorIndicatorStateMatrix[u].resize(4);
        vectorIndicatorStateMatrix[u].fill(false);
    }

    isNeedPaintEvent = false;

 //   ui->label_StatusBar->setStyleSheet("QLabel { background-color : white; color : blue; }");

    ui->label_StatusBar->setStyleSheet("QLabel { color : red; }");

    ui->toolButton_setAddressDefault->setVisible(false);

    ui->checkBox_OneWorkPlace->setChecked(true);
    ui->checkBox_OneWorkPlace->setChecked(false);

    setCurrentDateToSerial();

    ui->spinBox_serial_->setValue(11111);
    ui->spinBox_serial_2->setValue(11111);
    ui->spinBox_serial_3->setValue(11111);
    ui->spinBox_serial_4->setValue(11111);

    primeStart();

    //чтение настроек из файла
    loadSettings();

    //соединение с сервером
    serverConnectWithPasswordExtServ("gefest", "gefest");

    isLoginPasswordOk = false;

   if(!isRunWithoutConnect) {

      QStringList userList = readUserTable();

      emit sendUserList(userList);

      emit sendLogPasFromSettings(ui->lineEdit_humanName->text(), QString());

      //диалог ввода логина
      dialogLoginDataBase->setModal(true);

    //прочитать таблицу user, передать список пользователей в форму

      dialogLoginDataBase->show();

   }

   else {
       ui->ResultTable->setEnabled(false);
       ui->action_users->setEnabled(false);
   }

   on_checkBox_workPlace1_clicked(ui->checkBox_workPlace1->isChecked());
   on_checkBox_workPlace2_clicked(ui->checkBox_workPlace2->isChecked());
   on_checkBox_workPlace3_clicked(ui->checkBox_workPlace3->isChecked());
   on_checkBox_workPlace4_clicked(ui->checkBox_workPlace4->isChecked());

}
/*************************************************************/
MainWindow::~MainWindow()
{
    ObjectThread1->~ObjectThread();
    ObjectThread2->~ObjectThread();
    ObjectThread3->~ObjectThread();
    ObjectThread4->~ObjectThread();

    Thread1.exit();
    Thread2.exit();
    Thread3.exit();
    Thread4.exit();

    Thread1.quit();
    Thread2.quit();
    Thread3.quit();
    Thread4.quit();

    Thread1.terminate();
    Thread2.terminate();
    Thread3.terminate();
    Thread4.terminate();

    Thread1.wait(3000);
    Thread2.wait(3000);
    Thread3.wait(3000);
    Thread4.wait(3000);

    portOptical->close();
    portOptical2->close();
    portOptical3->close();
    portOptical4->close();
    portDigitalInterfaceChecking->close();

    writeSettings();

    delete ui;
}
/*************************************************************/
void MainWindow::primeStart()
{
//        Thread1 = new QThread();
//        Thread1 = new QThread();
//        Thread3 = new QThread();
//        Thread4 = new QThread();

//        ObjectThread1->moveToThread(Thread1);
//        ObjectThread2->moveToThread(Thread2);
//        ObjectThread3->moveToThread(Thread3);
//        ObjectThread4->moveToThread(Thread4);

//        Thread1->start(QThread::NormalPriority);
//        Thread2->start(QThread::NormalPriority);
//        Thread3->start(QThread::NormalPriority);
//        Thread4->start(QThread::NormalPriority);

}

void MainWindow::indicatorReset()
{

            QPainter painter(this); // Создаём объект отрисовщика
            // Устанавливаем кисть абриса
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::white, Qt::SolidPattern));

            int xGpourBox = ui->groupBox_writeParams->x();
            int yGroupBox = ui->groupBox_writeParams->y();
            painter.drawEllipse(xGpourBox + 13, yGroupBox + 45, 15, 15);
            painter.drawEllipse(xGpourBox + 13 + 33, yGroupBox + 45, 15, 15);
            painter.drawEllipse(xGpourBox + 13 + 33 + 33, yGroupBox + 45, 15, 15);
            painter.drawEllipse(xGpourBox + 13 + 33 + 33 + 33, yGroupBox + 45, 15, 15);

}
/*************************************************************/
void MainWindow::paintIndicator()
{
//    //
//    if( (currentBoxNumber == 0) && (currentIndicatorNumber == 0) && vectorIndicatorStateMatrix.at(0).at(0) ) {
//        QPainter painter(this); // Создаём объект отрисовщика
//        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//        painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

//        int xGpourBox = ui->groupBox_writeParams->x();
//        int yGroupBox = ui->groupBox_writeParams->y();

//        painter.drawEllipse(xGpourBox + 13, yGroupBox + 45, 15, 15);
//    }
//    if( (currentBoxNumber == 0) && (currentIndicatorNumber == 0) && !vectorIndicatorStateMatrix.at(0).at(0) ) {
//        QPainter painter(this); // Создаём объект отрисовщика
//        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//        painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

//        int xGpourBox = ui->groupBox_writeParams->x();
//        int yGroupBox = ui->groupBox_writeParams->y();

//        painter.drawEllipse(xGpourBox + 13, yGroupBox + 45, 15, 15);
//    }
//    //

//    //
//    if( (currentBoxNumber == 0) && (currentIndicatorNumber == 1) && vectorIndicatorStateMatrix.at(0).at(0) ) {
//        QPainter painter(this); // Создаём объект отрисовщика
//        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//        painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

//        int xGpourBox = ui->groupBox_writeParams->x();
//        int yGroupBox = ui->groupBox_writeParams->y();

//        painter.drawEllipse(xGpourBox + 13 + 33, yGroupBox + 45, 15, 15);
//    }
//    if( (currentBoxNumber == 0) && (currentIndicatorNumber == 1) && !vectorIndicatorStateMatrix.at(0).at(0) ) {
//        QPainter painter(this); // Создаём объект отрисовщика
//        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//        painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

//        int xGpourBox = ui->groupBox_writeParams->x();
//        int yGroupBox = ui->groupBox_writeParams->y();

//        painter.drawEllipse(xGpourBox + 13 + 33, yGroupBox + 45, 15, 15);
//    }
//    //

//    //
//    if( (currentBoxNumber == 0) && (currentIndicatorNumber == 2) && vectorIndicatorStateMatrix.at(0).at(0) ) {
//        QPainter painter(this); // Создаём объект отрисовщика
//        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//        painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

//        int xGpourBox = ui->groupBox_writeParams->x();
//        int yGroupBox = ui->groupBox_writeParams->y();

//        painter.drawEllipse(xGpourBox + 13 + 33 + 33, yGroupBox + 45, 15, 15);
//    }
//    if( (currentBoxNumber == 0) && (currentIndicatorNumber == 2) && !vectorIndicatorStateMatrix.at(0).at(0) ) {
//        QPainter painter(this); // Создаём объект отрисовщика
//        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//        painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

//        int xGpourBox = ui->groupBox_writeParams->x();
//        int yGroupBox = ui->groupBox_writeParams->y();

//        painter.drawEllipse(xGpourBox + 13 + 33 + 33, yGroupBox + 45, 15, 15);
//    }
//    //

//    //
//    if( (currentBoxNumber == 0) && (currentIndicatorNumber == 3) && vectorIndicatorStateMatrix.at(0).at(0) ) {
//        QPainter painter(this); // Создаём объект отрисовщика
//        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//        painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

//        int xGpourBox = ui->groupBox_writeParams->x();
//        int yGroupBox = ui->groupBox_writeParams->y();

//        painter.drawEllipse(xGpourBox + 13 + 33 + 33 + 33, yGroupBox + 45, 15, 15);
//    }
//    if( (currentBoxNumber == 0) && (currentIndicatorNumber == 3) && !vectorIndicatorStateMatrix.at(0).at(0) ) {
//        QPainter painter(this); // Создаём объект отрисовщика
//        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//        painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

//        int xGpourBox = ui->groupBox_writeParams->x();
//        int yGroupBox = ui->groupBox_writeParams->y();

//        painter.drawEllipse(xGpourBox + 13 + 33 + 33 + 33, yGroupBox + 45, 15, 15);
//    }
//    //
}

void MainWindow::checkWritingError(int currentIndicator)
{
    isNeedPaintEvent = true;
    switch (currentIndicator) {
    case 0:
        isWritingFinished1 = true;
        break;
    case 1:
        isWritingFinished2 = true;
        break;
    case 2:
        isWritingFinished3 = true;
        break;
    case 3:
        isWritingFinished4 = true;
        break;
    default:
        break;
    }
    repaint();
//    isNeedPaintEvent = false;
}

void MainWindow::checkCalibrationError(int currentIndicator)
{
    isNeedPaintEvent = true;
    switch (currentIndicator) {
    case 0:
        isCalibrationFinished1 = true;
        break;
    case 1:
        isCalibrationFinished2 = true;
        break;
    case 2:
        isCalibrationFinished3 = true;
        break;
    case 3:
        isCalibrationFinished4 = true;
        break;
    default:
        break;
    }
    repaint();
//    isNeedPaintEvent = false;
}

void MainWindow::checkPulsesOutputHeat(int currentIndicator)
{
    isNeedPaintEvent = true;
    switch (currentIndicator) {
    case 0:
        isPulsesOutputHeat1 = true;
        break;
    case 1:
        isPulsesOutputHeat2 = true;
        break;
    case 2:
        isPulsesOutputHeat3 = true;
        break;
    case 3:
        isPulsesOutputHeat4 = true;
        break;
    default:
        break;
    }
    repaint();
}

void MainWindow::checkPulsesInputVolume(int currentIndicator)
{
    isNeedPaintEvent = true;
    switch (currentIndicator) {
    case 0:
        isPulsesInputVolume1 = true;
        break;
    case 1:
        isPulsesInputVolume2 = true;
        break;
    case 2:
        isPulsesInputVolume3 = true;
        break;
    case 3:
        isPulsesInputVolume4 = true;
        break;
    default:
        break;
    }
    repaint();
}

void MainWindow::checkPulsesOutputDefault(int currentIndicator)
{
    isNeedPaintEvent = true;
    switch (currentIndicator) {
    case 0:
        isPulsesOutputDefault1 = true;
        break;
    case 1:
        isPulsesOutputDefault2 = true;
        break;
    case 2:
        isPulsesOutputDefault3 = true;
        break;
    case 3:
        isPulsesOutputDefault4 = true;
        break;
    default:
        break;
    }
    repaint();
}

void MainWindow::checkMbusOn(int currentIndicator)
{
    isNeedPaintEvent = true;
    switch (currentIndicator) {
    case 0:
        isMBusOn1 = true;
        break;
    case 1:
        isMBusOn2 = true;
        break;
    case 2:
        isMBusOn3 = true;
        break;
    case 3:
        isMBusOn4 = true;
        break;
    default:
        break;
    }
//    repaint();
}

void MainWindow::checkMbusCheck(int currentIndicator)
{
    isNeedPaintEvent = true;
    switch (currentIndicator) {
    case 0:
        isMBusCheck1 = true;
        break;
    case 1:
        isMBusCheck2 = true;
        break;
    case 2:
        isMBusCheck3 = true;
        break;
    case 3:
        isMBusCheck4 = true;
        break;
    default:
        break;
    }
    repaint();
}

void MainWindow::checkCalibrationModeOff(int currentIndicator)
{
    isNeedPaintEvent = true;
    switch (currentIndicator) {
    case 0:
        isCalibrationModeOff1 = true;
        break;
    case 1:
        isCalibrationModeOff2 = true;
        break;
    case 2:
        isCalibrationModeOff3 = true;
        break;
    case 3:
        isCalibrationModeOff4 = true;
        break;
    default:
        break;
    }
    repaint();
}

void MainWindow::checkWireInterfaceChecking(int currentIndicator)
{
    isNeedPaintEvent = true;
    switch (currentIndicator) {
    case 0:
        isWireInterfaceChecking1 = true;
        break;
    case 1:
        isWireInterfaceChecking2 = true;
        break;
    case 2:
        isWireInterfaceChecking3 = true;
        break;
    case 3:
        isWireInterfaceChecking4 = true;
        break;
    default:
        break;
    }
    repaint();
}

void MainWindow::checkMbusOff(int currentIndicator)
{
    isNeedPaintEvent = true;
    switch (currentIndicator) {
    case 0:
        isMBusOff1 = true;
        break;
    case 1:
        isMBusOff2 = true;
        break;
    case 2:
        isMBusOff3 = true;
        break;
    case 3:
        isMBusOff4 = true;
        break;
    default:
        break;
    }
    repaint();
}

/* Метод, в котором происходит рисование
 * */
void MainWindow::paintEvent(QPaintEvent *event)
{    
    Q_UNUSED(event);

    qDebug()<<"MainWindow::paintEvent(QPaintEvent *event)";

    if(isNeedPaintEvent) {

        QPainter painter(this); // Создаём объект отрисовщика
        // Устанавливаем кисть абриса
        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
        painter.setBrush(QBrush(Qt::white, Qt::SolidPattern));

        int xGpourBox = ui->groupBox_writeParams->x();
        int yGroupBox = ui->groupBox_writeParams->y();
        painter.drawEllipse(xGpourBox + 13, yGroupBox + 45, 15, 15);
        painter.drawEllipse(xGpourBox + 13 + 33, yGroupBox + 45, 15, 15);
        painter.drawEllipse(xGpourBox + 13 + 33 + 33, yGroupBox + 45, 15, 15);
        painter.drawEllipse(xGpourBox + 13 + 33 + 33 + 33, yGroupBox + 45, 15, 15);

        int xGpourBoxCalibration = ui->groupBox_calibration->x();
        int yGroupBoxCalibration = ui->groupBox_calibration->y();
        painter.drawEllipse(xGpourBoxCalibration + 13, yGroupBoxCalibration + 45, 15, 15);
        painter.drawEllipse(xGpourBoxCalibration + 13 + 33, yGroupBoxCalibration + 45, 15, 15);
        painter.drawEllipse(xGpourBoxCalibration + 13 + 33 + 33, yGroupBoxCalibration + 45, 15, 15);
        painter.drawEllipse(xGpourBoxCalibration + 13 + 33 + 33 + 33, yGroupBoxCalibration + 45, 15, 15);

        int xGpourBoxPulsesOutputHeat = ui->groupBox_pulsesOutputHeat->x();
        int yGroupBoxPulsesOutputHeat = ui->groupBox_pulsesOutputHeat->y();
        painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13, yGroupBoxPulsesOutputHeat + 45, 15, 15);
        painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13 + 33, yGroupBoxPulsesOutputHeat + 45, 15, 15);
        painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13 + 33 + 33, yGroupBoxPulsesOutputHeat + 45, 15, 15);
        painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13 + 33 + 33 + 33, yGroupBoxPulsesOutputHeat + 45, 15, 15);

        int xGpourBoxPulsesInputVolume = ui->groupBox_pulsesInputVolume->x();
        int yGroupBoxPulsesInputVolume = ui->groupBox_pulsesInputVolume->y();
        painter.drawEllipse(xGpourBoxPulsesInputVolume + 13, yGroupBoxPulsesInputVolume + 45, 15, 15);
        painter.drawEllipse(xGpourBoxPulsesInputVolume + 13 + 33, yGroupBoxPulsesInputVolume + 45, 15, 15);
        painter.drawEllipse(xGpourBoxPulsesInputVolume + 13 + 33 + 33, yGroupBoxPulsesInputVolume + 45, 15, 15);
        painter.drawEllipse(xGpourBoxPulsesInputVolume + 13 + 33 + 33 + 33, yGroupBoxPulsesInputVolume + 45, 15, 15);

        int xGpourBoxPulsesOutputOff = ui->groupBox_pulsesOutputOff->x();
        int yGroupBoxPulsesOutputOff = ui->groupBox_pulsesOutputOff->y();
        painter.drawEllipse(xGpourBoxPulsesOutputOff + 13, yGroupBoxPulsesOutputOff + 45, 15, 15);
        painter.drawEllipse(xGpourBoxPulsesOutputOff + 13 + 33, yGroupBoxPulsesOutputOff + 45, 15, 15);
        painter.drawEllipse(xGpourBoxPulsesOutputOff + 13 + 33 + 33, yGroupBoxPulsesOutputOff + 45, 15, 15);
        painter.drawEllipse(xGpourBoxPulsesOutputOff + 13 + 33 + 33 + 33, yGroupBoxPulsesOutputOff + 45, 15, 15);

//        int xGpourBoxMBusOn = ui->groupBox_MBusOn->x();
//        int yGroupBoxMBusOn = ui->groupBox_MBusOn->y();
//        painter.drawEllipse(xGpourBoxMBusOn + 13, yGroupBoxMBusOn + 45, 15, 15);
//        painter.drawEllipse(xGpourBoxMBusOn + 13 + 33, yGroupBoxMBusOn + 45, 15, 15);
//        painter.drawEllipse(xGpourBoxMBusOn + 13 + 33 + 33, yGroupBoxMBusOn + 45, 15, 15);
//        painter.drawEllipse(xGpourBoxMBusOn + 13 + 33 + 33 + 33, yGroupBoxMBusOn + 45, 15, 15);

        int xGpourBoxMBusCheck = ui->groupBox_CheckMbus->x();
        int yGroupBoxMBusCheck = ui->groupBox_CheckMbus->y();
        painter.drawEllipse(xGpourBoxMBusCheck + 13, yGroupBoxMBusCheck + 45, 15, 15);
        painter.drawEllipse(xGpourBoxMBusCheck + 13 + 33, yGroupBoxMBusCheck + 45, 15, 15);
        painter.drawEllipse(xGpourBoxMBusCheck + 13 + 33 + 33, yGroupBoxMBusCheck + 45, 15, 15);
        painter.drawEllipse(xGpourBoxMBusCheck + 13 + 33 + 33 + 33, yGroupBoxMBusCheck + 45, 15, 15);

        int xGpourBoxCalibrationModeOff = ui->groupBox_calibrationModeOff->x();
        int yGroupBoxCalibrationModeOff = ui->groupBox_calibrationModeOff->y();
        painter.drawEllipse(xGpourBoxCalibrationModeOff + 13, yGroupBoxCalibrationModeOff + 45, 15, 15);
        painter.drawEllipse(xGpourBoxCalibrationModeOff + 13 + 33, yGroupBoxCalibrationModeOff + 45, 15, 15);
        painter.drawEllipse(xGpourBoxCalibrationModeOff + 13 + 33 + 33, yGroupBoxCalibrationModeOff + 45, 15, 15);
        painter.drawEllipse(xGpourBoxCalibrationModeOff + 13 + 33 + 33 + 33, yGroupBoxCalibrationModeOff + 45, 15, 15);

        int xGroupBoxWireInterfaceChecking = ui->groupBox_digitalWireInterfaceChecking->x();
        int yGroupBoxWireInterfaceChecking = ui->groupBox_digitalWireInterfaceChecking->y();
        painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13, yGroupBoxWireInterfaceChecking + 45, 15, 15);
        painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13 + 33, yGroupBoxWireInterfaceChecking + 45, 15, 15);
        painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13 + 33 + 33, yGroupBoxWireInterfaceChecking + 45, 15, 15);
        painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13 + 33 + 33 + 33, yGroupBoxWireInterfaceChecking + 45, 15, 15);

        int xGroupBoxResult = ui->groupBox_result->x();
        int yGroupBoxResult = ui->groupBox_result->y();
        painter.drawEllipse(xGroupBoxResult + 13, yGroupBoxResult + 45, 15, 15);
        painter.drawEllipse(xGroupBoxResult + 13 + 33, yGroupBoxResult + 45, 15, 15);
        painter.drawEllipse(xGroupBoxResult + 13 + 33 + 33, yGroupBoxResult + 45, 15, 15);
        painter.drawEllipse(xGroupBoxResult + 13 + 33 + 33 + 33, yGroupBoxResult + 45, 15, 15);

 //       return;

        //
        //
        //writing
        if( vectorIndicatorStateMatrix.at(0).at(0) && ui->checkBox_workPlace1->isChecked() && isWritingFinished1) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBox + 13, yGroupBox + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(0).at(0)  && ui->checkBox_workPlace1->isChecked() && isWritingFinished1 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBox + 13, yGroupBox + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(0).at(1)  && ui->checkBox_workPlace2->isChecked() && isWritingFinished2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBox + 13 + 33, yGroupBox + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(0).at(1)  && ui->checkBox_workPlace2->isChecked() && isWritingFinished2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBox + 13 + 33, yGroupBox + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(0).at(2)  && ui->checkBox_workPlace3->isChecked() && isWritingFinished3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBox + 13 + 33 + 33, yGroupBox + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(0).at(2)  && ui->checkBox_workPlace3->isChecked() && isWritingFinished3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBox + 13 + 33 + 33, yGroupBox + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(0).at(3)  && ui->checkBox_workPlace4->isChecked() && isWritingFinished4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBox + 13 + 33 + 33 + 33, yGroupBox + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(0).at(3)  && ui->checkBox_workPlace4->isChecked() && isWritingFinished4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBox + 13 + 33 + 33 + 33, yGroupBox + 45, 15, 15);
        }
        //
        //
        //writing/

        //----------------------Calibration--------------------------------------

        if( vectorIndicatorStateMatrix.at(1).at(0) && ui->checkBox_workPlace1->isChecked() && isCalibrationFinished1) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibration + 13, yGroupBoxCalibration + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(1).at(0)  && ui->checkBox_workPlace1->isChecked() && isCalibrationFinished1 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibration + 13, yGroupBoxCalibration + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(1).at(1)  && ui->checkBox_workPlace2->isChecked() && isCalibrationFinished2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibration + 13 + 33, yGroupBoxCalibration + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(1).at(1)  && ui->checkBox_workPlace2->isChecked() && isCalibrationFinished2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibration + 13 + 33, yGroupBoxCalibration + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(1).at(2)  && ui->checkBox_workPlace3->isChecked() && isCalibrationFinished3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibration + 13 + 33 + 33, yGroupBoxCalibration + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(1).at(2)  && ui->checkBox_workPlace3->isChecked() && isCalibrationFinished3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibration + 13 + 33 + 33, yGroupBoxCalibration + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(1).at(3)  && ui->checkBox_workPlace4->isChecked() && isCalibrationFinished4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibration + 13 + 33 + 33 + 33, yGroupBoxCalibration + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(1).at(3)  && ui->checkBox_workPlace4->isChecked() && isCalibrationFinished4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibration + 13 + 33 + 33 + 33, yGroupBoxCalibration + 45, 15, 15);
        }

        //----------------------Calibration--------------------------------------/


        //----------------------PulsesOutputHeat---------------------------------

        if( vectorIndicatorStateMatrix.at(2).at(0) && ui->checkBox_workPlace1->isChecked() && isPulsesOutputHeat1) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13, yGroupBoxPulsesOutputHeat + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(2).at(0)  && ui->checkBox_workPlace1->isChecked() && isPulsesOutputHeat1 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13, yGroupBoxPulsesOutputHeat + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(2).at(1)  && ui->checkBox_workPlace2->isChecked() && isPulsesOutputHeat2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13 + 33, yGroupBoxPulsesOutputHeat + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(2).at(1)  && ui->checkBox_workPlace2->isChecked() && isPulsesOutputHeat2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13 + 33, yGroupBoxPulsesOutputHeat + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(2).at(2)  && ui->checkBox_workPlace3->isChecked() && isPulsesOutputHeat3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13 + 33 + 33, yGroupBoxPulsesOutputHeat + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(2).at(2)  && ui->checkBox_workPlace3->isChecked() && isPulsesOutputHeat3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13 + 33 + 33, yGroupBoxPulsesOutputHeat + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(2).at(3)  && ui->checkBox_workPlace4->isChecked() && isPulsesOutputHeat4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13 + 33 + 33 + 33, yGroupBoxPulsesOutputHeat + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(2).at(3)  && ui->checkBox_workPlace4->isChecked() && isPulsesOutputHeat4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputHeat + 13 + 33 + 33 + 33, yGroupBoxPulsesOutputHeat + 45, 15, 15);
        }

        //----------------------PulsesOutputHeat---------------------------------/


        //----------------------PulsesInputVolume--------------------------------

        if( vectorIndicatorStateMatrix.at(3).at(0) && ui->checkBox_workPlace1->isChecked() && isPulsesInputVolume1) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesInputVolume + 13, yGroupBoxPulsesInputVolume + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(3).at(0)  && ui->checkBox_workPlace1->isChecked() && isPulsesInputVolume1 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesInputVolume + 13, yGroupBoxPulsesInputVolume + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(3).at(1)  && ui->checkBox_workPlace2->isChecked() && isPulsesInputVolume2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesInputVolume + 13 + 33, yGroupBoxPulsesInputVolume + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(3).at(1)  && ui->checkBox_workPlace2->isChecked() && isPulsesInputVolume2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesInputVolume + 13 + 33, yGroupBoxPulsesInputVolume + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(3).at(2)  && ui->checkBox_workPlace3->isChecked() && isPulsesInputVolume3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesInputVolume + 13 + 33 + 33, yGroupBoxPulsesInputVolume + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(3).at(2)  && ui->checkBox_workPlace3->isChecked() && isPulsesInputVolume3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesInputVolume + 13 + 33 + 33, yGroupBoxPulsesInputVolume + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(3).at(3)  && ui->checkBox_workPlace4->isChecked() && isPulsesInputVolume4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesInputVolume + 13 + 33 + 33 + 33, yGroupBoxPulsesInputVolume + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(3).at(3)  && ui->checkBox_workPlace4->isChecked() && isPulsesInputVolume4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesInputVolume + 13 + 33 + 33 + 33, yGroupBoxPulsesInputVolume + 45, 15, 15);
        }

        //----------------------PulsesInputVolume--------------------------------/

        //----------------------PulsesOutputDefault------------------------------

        if( vectorIndicatorStateMatrix.at(4).at(0) && ui->checkBox_workPlace1->isChecked() && isPulsesOutputDefault1) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputOff + 13, yGroupBoxPulsesOutputOff + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(4).at(0)  && ui->checkBox_workPlace1->isChecked() && isPulsesOutputDefault1 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputOff + 13, yGroupBoxPulsesOutputOff + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(4).at(1)  && ui->checkBox_workPlace2->isChecked() && isPulsesOutputDefault2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputOff + 13 + 33, yGroupBoxPulsesOutputOff + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(4).at(1)  && ui->checkBox_workPlace2->isChecked() && isPulsesOutputDefault2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputOff + 13 + 33, yGroupBoxPulsesOutputOff + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(4).at(2)  && ui->checkBox_workPlace3->isChecked() && isPulsesOutputDefault3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputOff + 13 + 33 + 33, yGroupBoxPulsesOutputOff + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(4).at(2)  && ui->checkBox_workPlace3->isChecked() && isPulsesOutputDefault3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputOff + 13 + 33 + 33, yGroupBoxPulsesOutputOff + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(4).at(3)  && ui->checkBox_workPlace4->isChecked() && isPulsesOutputDefault4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputOff + 13 + 33 + 33 + 33, yGroupBoxPulsesOutputOff + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(4).at(3)  && ui->checkBox_workPlace4->isChecked() && isPulsesOutputDefault4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxPulsesOutputOff + 13 + 33 + 33 + 33, yGroupBoxPulsesOutputOff + 45, 15, 15);
        }

        //----------------------PulsesOutputDefault------------------------------/


        //----------------------MBusOn-------------------------------------------

//        if( vectorIndicatorStateMatrix.at(5).at(0) && ui->checkBox_workPlace1->isChecked() && isPulsesOutputDefault1) {
//            QPainter painter(this); // Создаём объект отрисовщика
//            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

//            painter.drawEllipse(xGpourBoxMBusOn + 13, yGroupBoxMBusOn + 45, 15, 15);
//        }
//        if( !vectorIndicatorStateMatrix.at(5).at(0)  && ui->checkBox_workPlace1->isChecked() && isPulsesOutputDefault1 ) {
//            QPainter painter(this); // Создаём объект отрисовщика
//            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

//            painter.drawEllipse(xGpourBoxMBusOn + 13, yGroupBoxMBusOn + 45, 15, 15);
//        }
//        //

//        //
//        if( vectorIndicatorStateMatrix.at(5).at(1)  && ui->checkBox_workPlace2->isChecked() && isPulsesOutputDefault2 ) {
//            QPainter painter(this); // Создаём объект отрисовщика
//            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

//            painter.drawEllipse(xGpourBoxMBusOn + 13 + 33, yGroupBoxMBusOn + 45, 15, 15);
//        }
//        if( !vectorIndicatorStateMatrix.at(5).at(1)  && ui->checkBox_workPlace2->isChecked() && isPulsesOutputDefault2 ) {
//            QPainter painter(this); // Создаём объект отрисовщика
//            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

//            painter.drawEllipse(xGpourBoxMBusOn + 13 + 33, yGroupBoxMBusOn + 45, 15, 15);
//        }
//        //

//        //
//        if( vectorIndicatorStateMatrix.at(5).at(2)  && ui->checkBox_workPlace3->isChecked() && isPulsesOutputDefault3 ) {
//            QPainter painter(this); // Создаём объект отрисовщика
//            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

//            painter.drawEllipse(xGpourBoxMBusOn + 13 + 33 + 33, yGroupBoxMBusOn + 45, 15, 15);
//        }
//        if( !vectorIndicatorStateMatrix.at(5).at(2)  && ui->checkBox_workPlace3->isChecked() && isPulsesOutputDefault3 ) {
//            QPainter painter(this); // Создаём объект отрисовщика
//            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

//            painter.drawEllipse(xGpourBoxMBusOn + 13 + 33 + 33, yGroupBoxMBusOn + 45, 15, 15);
//        }
//        //

//        //
//        if( vectorIndicatorStateMatrix.at(5).at(3)  && ui->checkBox_workPlace4->isChecked() && isPulsesOutputDefault4 ) {
//            QPainter painter(this); // Создаём объект отрисовщика
//            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

//            painter.drawEllipse(xGpourBoxMBusOn + 13 + 33 + 33 + 33, yGroupBoxMBusOn + 45, 15, 15);
//        }
//        if( !vectorIndicatorStateMatrix.at(5).at(3)  && ui->checkBox_workPlace4->isChecked() && isPulsesOutputDefault4 ) {
//            QPainter painter(this); // Создаём объект отрисовщика
//            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
//            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

//            painter.drawEllipse(xGpourBoxMBusOn + 13 + 33 + 33 + 33, yGroupBoxMBusOn + 45, 15, 15);
//        }

        //----------------------MBusOn-------------------------------------------/


        //----------------------MBusCheck----------------------------------------

        if( vectorIndicatorStateMatrix.at(6).at(0) && ui->checkBox_workPlace1->isChecked() && isMBusCheck1) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxMBusCheck + 13, yGroupBoxMBusCheck + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(6).at(0)  && ui->checkBox_workPlace1->isChecked() && isMBusCheck1 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxMBusCheck + 13, yGroupBoxMBusCheck + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(6).at(1)  && ui->checkBox_workPlace2->isChecked() && isMBusCheck2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxMBusCheck + 13 + 33, yGroupBoxMBusCheck + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(6).at(1)  && ui->checkBox_workPlace2->isChecked() && isMBusCheck2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxMBusCheck + 13 + 33, yGroupBoxMBusCheck + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(6).at(2)  && ui->checkBox_workPlace3->isChecked() && isMBusCheck3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxMBusCheck + 13 + 33 + 33, yGroupBoxMBusCheck + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(6).at(2)  && ui->checkBox_workPlace3->isChecked() && isMBusCheck3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxMBusCheck + 13 + 33 + 33, yGroupBoxMBusCheck + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(6).at(3)  && ui->checkBox_workPlace4->isChecked() && isMBusCheck4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxMBusCheck + 13 + 33 + 33 + 33, yGroupBoxMBusCheck + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(6).at(3)  && ui->checkBox_workPlace4->isChecked() && isMBusCheck4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxMBusCheck + 13 + 33 + 33 + 33, yGroupBoxMBusCheck + 45, 15, 15);
        }

        //----------------------MBusCheck----------------------------------------/


        //----------------------WireInterfaceChecking----------------------------

        if( vectorIndicatorStateMatrix.at(7).at(0) && ui->checkBox_workPlace1->isChecked() && isWireInterfaceChecking1) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13, yGroupBoxWireInterfaceChecking + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(7).at(0)  && ui->checkBox_workPlace1->isChecked() && isWireInterfaceChecking1 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13, yGroupBoxWireInterfaceChecking + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(7).at(1)  && ui->checkBox_workPlace2->isChecked() && isWireInterfaceChecking2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13 + 33, yGroupBoxWireInterfaceChecking + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(7).at(1)  && ui->checkBox_workPlace2->isChecked() && isWireInterfaceChecking2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13 + 33, yGroupBoxWireInterfaceChecking + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(7).at(2)  && ui->checkBox_workPlace3->isChecked() && isWireInterfaceChecking3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13 + 33 + 33, yGroupBoxWireInterfaceChecking + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(7).at(2)  && ui->checkBox_workPlace3->isChecked() && isWireInterfaceChecking3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13 + 33 + 33, yGroupBoxWireInterfaceChecking + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(7).at(3)  && ui->checkBox_workPlace4->isChecked() && isWireInterfaceChecking4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13 + 33 + 33 + 33, yGroupBoxWireInterfaceChecking + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(7).at(3)  && ui->checkBox_workPlace4->isChecked() && isWireInterfaceChecking4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGroupBoxWireInterfaceChecking + 13 + 33 + 33 + 33, yGroupBoxWireInterfaceChecking + 45, 15, 15);
        }

        //----------------------WireInterfaceChecking----------------------------/


        //----------------------CalibrationModeOff-------------------------------

        if( vectorIndicatorStateMatrix.at(9).at(0) && ui->checkBox_workPlace1->isChecked() && isCalibrationModeOff1) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibrationModeOff + 13, yGroupBoxCalibrationModeOff + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(9).at(0)  && ui->checkBox_workPlace1->isChecked() && isCalibrationModeOff1 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibrationModeOff + 13, yGroupBoxCalibrationModeOff + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(9).at(1)  && ui->checkBox_workPlace2->isChecked() && isCalibrationModeOff2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibrationModeOff + 13 + 33, yGroupBoxCalibrationModeOff + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(9).at(1)  && ui->checkBox_workPlace2->isChecked() && isCalibrationModeOff2 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibrationModeOff + 13 + 33, yGroupBoxCalibrationModeOff + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(9).at(2)  && ui->checkBox_workPlace3->isChecked() && isCalibrationModeOff3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibrationModeOff + 13 + 33 + 33, yGroupBoxCalibrationModeOff + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(9).at(2)  && ui->checkBox_workPlace3->isChecked() && isCalibrationModeOff3 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibrationModeOff + 13 + 33 + 33, yGroupBoxCalibrationModeOff + 45, 15, 15);
        }
        //

        //
        if( vectorIndicatorStateMatrix.at(9).at(3)  && ui->checkBox_workPlace4->isChecked() && isCalibrationModeOff4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibrationModeOff + 13 + 33 + 33 + 33, yGroupBoxCalibrationModeOff + 45, 15, 15);
        }
        if( !vectorIndicatorStateMatrix.at(9).at(3)  && ui->checkBox_workPlace4->isChecked() && isCalibrationModeOff4 ) {
            QPainter painter(this); // Создаём объект отрисовщика
            painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
            painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

            painter.drawEllipse(xGpourBoxCalibrationModeOff + 13 + 33 + 33 + 33, yGroupBoxCalibrationModeOff + 45, 15, 15);
        }

        //----------------------CalibrationModeOff-------------------------------/



        //---------------------------Relult--------------------------------------

      if(isCommandsEnded) {

            //проверяем, какие команды выбраны. если для данного рабочего места есть хотя бы один красный кружок, то результат красный

        bool workPlace1Result = false;
        bool workPlace2Result = false;
        bool workPlace3Result = false;
        bool workPlace4Result = false;

        workPlace1ResultString = tr("Годен");
        workPlace2ResultString = tr("Годен");
        workPlace3ResultString = tr("Годен");
        workPlace4ResultString = tr("Годен");

        for(int u=0; u<vectorIsCommandUse.size(); u++) {
            if(vectorIsCommandUse.at(u)) {

                if(ui->checkBox_workPlace1->isChecked()) {
                    if(vectorIndicatorStateMatrix.at(u).at(0)) {
                        workPlace1Result = true;
                        workPlace1ResultString = tr("Не годен");
                    }
                }

                if(ui->checkBox_workPlace2->isChecked()) {
                    if(vectorIndicatorStateMatrix.at(u).at(1)) {
                        workPlace2Result = true;
                        workPlace2ResultString = tr("Не годен");
                    }
                }

                if(ui->checkBox_workPlace3->isChecked()) {
                    if(vectorIndicatorStateMatrix.at(u).at(2)) {
                        workPlace3Result = true;
                        workPlace3ResultString = tr("Не годен");
                    }
                }

                if(ui->checkBox_workPlace4->isChecked()) {
                    if(vectorIndicatorStateMatrix.at(u).at(3)) {
                        workPlace4Result = true;
                        workPlace4ResultString = tr("Не годен");
                    }
                }

            }

        }

        //
        //

        if(workPlace1Result && ui->checkBox_workPlace1->isChecked()) {
                        QPainter painter(this); // Создаём объект отрисовщика
                        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
                        painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

                        painter.drawEllipse(xGroupBoxResult + 13, yGroupBoxResult + 45, 15, 15);
        }
        if(!workPlace1Result && ui->checkBox_workPlace1->isChecked()) {
                        QPainter painter(this); // Создаём объект отрисовщика
                        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
                        painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

                        painter.drawEllipse(xGroupBoxResult + 13, yGroupBoxResult + 45, 15, 15);
        }

        //
        if(workPlace2Result && ui->checkBox_workPlace2->isChecked()) {
                        QPainter painter(this); // Создаём объект отрисовщика
                        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
                        painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

                        painter.drawEllipse(xGroupBoxResult + 13 + 33, yGroupBoxResult + 45, 15, 15);
        }
        if(!workPlace2Result && ui->checkBox_workPlace2->isChecked()) {
                        QPainter painter(this); // Создаём объект отрисовщика
                        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
                        painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

                        painter.drawEllipse(xGroupBoxResult + 13 + 33, yGroupBoxResult + 45, 15, 15);
        }

        //
        if(workPlace3Result && ui->checkBox_workPlace3->isChecked()) {
                        QPainter painter(this); // Создаём объект отрисовщика
                        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
                        painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

                        painter.drawEllipse(xGroupBoxResult + 13 + 33 + 33, yGroupBoxResult + 45, 15, 15);
        }
        if(!workPlace3Result && ui->checkBox_workPlace3->isChecked()) {
                        QPainter painter(this); // Создаём объект отрисовщика
                        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
                        painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

                        painter.drawEllipse(xGroupBoxResult + 13 + 33 + 33, yGroupBoxResult + 45, 15, 15);
        }

        //
        if(workPlace4Result && ui->checkBox_workPlace4->isChecked()) {
                        QPainter painter(this); // Создаём объект отрисовщика
                        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
                        painter.setBrush(QBrush(Qt::red, Qt::SolidPattern));

                        painter.drawEllipse(xGroupBoxResult + 13 + 33 + 33 + 33, yGroupBoxResult + 45, 15, 15);
        }
        if(!workPlace4Result && ui->checkBox_workPlace4->isChecked()) {
                        QPainter painter(this); // Создаём объект отрисовщика
                        painter.setPen(QPen(Qt::lightGray, 1, Qt::SolidLine, Qt::FlatCap));
                        painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));

                        painter.drawEllipse(xGroupBoxResult + 13 + 33 + 33 + 33, yGroupBoxResult + 45, 15, 15);
        }


      } //if(isCommandsEnded)

        //---------------------------Relult--------------------------------------/


    }


}
/*************************************************************/
void MainWindow::closeEvent(QCloseEvent *event)
{
 //   formEditParameters->close();
    port->close();
    portOptical->close();
    portOptical2->close();
    portOptical3->close();
    portOptical4->close();
    portDigitalInterfaceChecking->close();

    formCalibration->close();
    formParamsEdit->close();
    formLog->close();
    formViewTable->close();
    formConnectionParams->close();
    formUserControl->close();

//    writeSettings();
}
/*************************************************************/
void MainWindow::slotReadParams()
{
    on_toolButton_readParams_clicked();
}
/*************************************************************/
void MainWindow::slotWriteParams()
{
    on_toolButton_writeParams_clicked();
}
/*************************************************************/
void MainWindow::on_toolButton_programmingBSL_clicked()
{
    processData.clear();
    ui->textBrowser->clear();

    //специальные настройки для windows
    if(QSysInfo::productType()=="windows")
    {
        QTextCodec *codec = QTextCodec::codecForName("IBM 866");
//        ui->textEdit->append( codec->toUnicode(m_process->readAllStandardOutput() ) );
    }
//    else
//        ui->textEdit->append( m_process->readAllStandardOutput() );
   //формирование команды
    QString strCommand;

    strCommand = "cmd /C BSL_Scripter scriptProgramming.txt";//"cmd.exe ";
    cmd->start(strCommand/*, listParam*/);

//    global::pause(1000);

//    qDebug()<<"cmd.program"<<cmd->program();
//    qDebug()<<"cmd.lastError"<<cmd->error();
//    qDebug()<<"cmd.OpenMode"<<cmd->openMode();

//    if(QSysInfo::productType()=="windows")
//    {
//        QTextCodec *codec = QTextCodec::codecForName("IBM 866");
//  //        ui->textEdit->append( codec->toUnicode(m_process->readAllStandardOutput() ) );

//    //
//    QString processData = codec->toUnicode(cmd->readAllStandardOutput());//readAll();
//    ui->textBrowser->setText(processData);
//    qDebug()<<"processData"<<processData;//QString::fromLatin1(processData);
//    }
//    timerStageOne->start(10000);
}
/*************************************************************/
void MainWindow::readSettings()
{
//    QMessageBox box;

//    QSettings settings("calibration.conf", QSettings::IniFormat);
//    portName = settings.value("portName", "COM1").toString();
//    ui->comboBox_portList->setCurrentText(portName);

//    fileName = settings.value("fileName", "").toString();
//    ui->lineEdit_programmingFile->setText(fileName);

//    if(fileName == "") {
//        return;
//    }

//    //в файл скрипта scriptEso вставляем название файла прошивки
//    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//    QFile scriptEso("scriptEso.txt");
//    if(!scriptEso.open(QIODevice::ReadOnly | QIODevice::Text)) {
//        box.setText("Не удалось открыть файл scriptEso.txt");
//        box.exec();
//        qDebug()<<"не удалось открыть файл";
//        return;
//    }


//    //в файл скрипта write_scriptFrequency вставляем номер порта
//  //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//    QFile write_scriptFrequency("write_scriptFrequency.txt");
//    if(!write_scriptFrequency.open(QIODevice::ReadOnly | QIODevice::Text)) {
//        box.setText("Не удалось открыть файл write_scriptFrequency.txt");
//        box.exec();
//        qDebug()<<"не удалось открыть файл";
//        return;
//    }


//    //в файл скрипта write_scriptParamsFirstField вставляем номер порта
// //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//    QFile write_scriptParamsFirstField("write_scriptParamsFirstField.txt");
//    if(!write_scriptParamsFirstField.open(QIODevice::ReadOnly | QIODevice::Text)) {
//        box.setText("Не удалось открыть файл write_scriptParamsFirstField.txt");
//        box.exec();
//        qDebug()<<"не удалось открыть файл";
//        return;
//    }


//    //в файл скрипта write_scriptParamsSecondField вставляем номер порта
// //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//    QFile write_scriptParamsSecondField("write_scriptParamsSecondField.txt");
//    if(!write_scriptParamsSecondField.open(QIODevice::ReadOnly | QIODevice::Text)) {
//        box.setText("Не удалось открыть файл write_scriptParamsSecondField.txt");
//        box.exec();
//        qDebug()<<"не удалось открыть файл";
//        return;
//    }


//    //прочитываем файл scriptEso в строку далее в лист
//    QString fileToString = scriptEso.readAll();
//    qDebug()<<"fileToString"<<fileToString;
//    QStringList fileToStringList;
//    QString sym = "";
//    for(int i=0; i<fileToString.size(); i++) {
//        sym = sym + fileToString[i];
//        if(fileToString[i+1] == "\n") {
// //           sym = sym + "\n";
//            fileToStringList<<sym;
//            sym = "";
// //           i=i+1;
//        }
//    }
//    qDebug()<<"fileToStringList"<<fileToStringList;


//    //прочитываем файл write_scriptFrequency в строку далее в лист
//    QString fileToStringWrite_scriptFrequency = write_scriptFrequency.readAll();
//    qDebug()<<"fileToStringWrite_scriptFrequency"<<fileToStringWrite_scriptFrequency;
//    QStringList fileToStringWrite_scriptFrequencyList;
//    sym = "";
//    for(int i=0; i<fileToStringWrite_scriptFrequency.size(); i++) {
//        sym = sym + fileToStringWrite_scriptFrequency[i];
//        if(fileToStringWrite_scriptFrequency[i+1] == "\n") {
// //           sym = sym + "\n";
//            fileToStringWrite_scriptFrequencyList<<sym;
//            sym = "";
// //           i=i+1;
//        }
//    }

//    //прочитываем файл write_scriptParamsFirstField в строку далее в лист
//    QString fileToStringWrite_scriptParamsFirstField = write_scriptParamsFirstField.readAll();
//    qDebug()<<"fileToStringWrite_scriptParamsFirstField"<<fileToStringWrite_scriptParamsFirstField;
//    QStringList fileToStringWrite_scriptParamsFirstFieldList;
//    sym = "";
//    for(int i=0; i<fileToStringWrite_scriptParamsFirstField.size(); i++) {
//        sym = sym + fileToStringWrite_scriptParamsFirstField[i];
//        if(fileToStringWrite_scriptParamsFirstField[i+1] == "\n") {
// //           sym = sym + "\n";
//            fileToStringWrite_scriptParamsFirstFieldList<<sym;
//            sym = "";
// //           i=i+1;
//        }
//    }

//    //прочитываем файл write_scriptParamsSecondField в строку далее в лист
//    QString fileToStringWrite_scriptParamsSecondField = write_scriptParamsSecondField.readAll();
//    qDebug()<<"fileToStringWrite_scriptParamsSecondField"<<fileToStringWrite_scriptParamsSecondField;
//    QStringList fileToStringWrite_scriptParamsSecondFieldList;
//    sym = "";
//    for(int i=0; i<fileToStringWrite_scriptParamsSecondField.size(); i++) {
//        sym = sym + fileToStringWrite_scriptParamsSecondField[i];
//        if(fileToStringWrite_scriptParamsSecondField[i+1] == "\n") {
// //           sym = sym + "\n";
//            fileToStringWrite_scriptParamsSecondFieldList<<sym;
//            sym = "";
// //           i=i+1;
//        }
//    }


//    //находим строку с командой RX_DATA_BLOCK
//    bool command_RX_DATA_BLOCK_Exist = false;
//    int numberOfCommandString;
//    for(int i=0; i<fileToStringList.size(); i++) {
//       if(fileToStringList[i].contains("\nRX_DATA_BLOCK")) {
//            command_RX_DATA_BLOCK_Exist = true;
//            numberOfCommandString = i;
//        }
//    }

//    //находим строку с номером порта
//    bool rowWithPortNameExist = false;
//    int numberOfPortNameString;
//    for(int i=0; i<fileToStringList.size(); i++) {
//       if(fileToStringList[i].contains("MODE 5xx_family")) {
//            rowWithPortNameExist = true;
//            numberOfPortNameString = i;
//        }
//    }

//    //записываем в строку с командой RX_DATA_BLOCK название выбранного файла прошивки
//    QString str = "\nRX_DATA_BLOCK " + fileName;
//    str.remove(str.size() - 4, 4);
//    fileToStringList[numberOfCommandString] = "\nRX_DATA_BLOCK " + fileName;

//    //записываем в строку с номером порта текущий порт
//    str = "MODE 5xx_family " + port->portName();
//    fileToStringList[numberOfPortNameString] = str;

//    //записываем новую строку с номером порта в остальные файлы
//    fileToStringWrite_scriptFrequencyList[0] = str;
//    fileToStringWrite_scriptParamsFirstFieldList[0] = str;
//    fileToStringWrite_scriptParamsSecondFieldList[0] = str;

//    //делаем из листа обратно строку, чтобы записать в файл
//    QString stringWriteToFile;
//    sym = "";
//    for(int i=0; i<fileToStringList.size(); i++) {
//    //    fileToStringList[i].remove("\n");
//        sym = sym + fileToStringList[i];
//    }
//    sym = sym + "\n";
//    scriptEso.write("");
//    scriptEso.close();
//    //открываем файл на чтение
//    if(!scriptEso.open(QIODevice::WriteOnly | QIODevice::Text)) {
//        box.setText("Не удалось открыть файл");
//        box.exec();
//        qDebug()<<"не удалось открыть файл";
//        return;
//    }
//    scriptEso.write(sym.toLocal8Bit());

//    scriptEso.close();


//    //делаем из листа обратно строку, чтобы записать в файл write_scriptFrequency
// //   QString stringWriteToFileScriptFrequency;
//    sym = "";
//    for(int i=0; i<fileToStringWrite_scriptFrequencyList.size(); i++) {
//    //    fileToStringWrite_scriptFrequencyList[i].remove("\n");
//        sym = sym + fileToStringWrite_scriptFrequencyList[i];
//    }
//    sym = sym + "\n";
//    write_scriptFrequency.write("");
//    write_scriptFrequency.close();
//    //открываем файл на чтение
//    if(!write_scriptFrequency.open(QIODevice::WriteOnly | QIODevice::Text)) {
//        box.setText("Не удалось открыть файл write_scriptFrequency");
//        box.exec();
//        qDebug()<<"не удалось открыть файл write_scriptFrequency";
//        return;
//    }
//    write_scriptFrequency.write(sym.toLocal8Bit());

//    write_scriptFrequency.close();


//    //делаем из листа обратно строку, чтобы записать в файл write_scriptParamsFirstField
// //       QString stringWriteToFile;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptParamsFirstFieldList.size(); i++) {
//        //    fileToStringWrite_scriptParamsFirstFieldList[i].remove("\n");
//            sym = sym + fileToStringWrite_scriptParamsFirstFieldList[i];
//        }
//        sym = sym + "\n";
//        write_scriptParamsFirstField.write("");
//        write_scriptParamsFirstField.close();
//        //открываем файл на чтение
//        if(!write_scriptParamsFirstField.open(QIODevice::WriteOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }
//        write_scriptParamsFirstField.write(sym.toLocal8Bit());

//        write_scriptParamsFirstField.close();


//    //делаем из листа обратно строку, чтобы записать в файл write_scriptParamsSecondField
//  //      QString stringWriteToFile;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptParamsSecondFieldList.size(); i++) {
//        //    fileToStringWrite_scriptParamsSecondFieldList[i].remove("\n");
//            sym = sym + fileToStringWrite_scriptParamsSecondFieldList[i];
//        }
//        sym = sym + "\n";
//        write_scriptParamsSecondField.write("");
//        write_scriptParamsSecondField.close();
//        //открываем файл на чтение
//        if(!write_scriptParamsSecondField.open(QIODevice::WriteOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }
//        write_scriptParamsSecondField.write(sym.toLocal8Bit());

//        write_scriptParamsSecondField.close();


//    //прочитываем файл прошивки и извлекаем значение калибровочной частоты
//    QFile programmingFile(fileName);
//    if(!programmingFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
//        box.setText("Не удалось открыть файл");
//        box.exec();
//        qDebug()<<"не удалось открыть файл";
//        return;
//    }

//    //прочитываем файл в строку далее в лист
//    programmingFileToString = programmingFile.readAll();
//    qDebug()<<"programmingFileToString"<<programmingFileToString;
//    programmingFileToStringList.clear();
//    sym = "";
//    for(int i=0; i<programmingFileToString.size(); i++) {
//        sym = sym + programmingFileToString[i];
//        if(programmingFileToString[i+1] == "\n") {
// //           sym = sym + "\n";
//            programmingFileToStringList<<sym;
//            sym = "";
//            i=i+1;
//        }
//    }
//    qDebug()<<"programmingFileToStringList"<<programmingFileToStringList;

//    firstField = "";
//    firstField = programmingFileToStringList[1];

//    QString localCalibrFrequencyString = firstField.remove("\n");
//    localCalibrFrequencyString.remove(0, 3);
//    localCalibrFrequencyString = localCalibrFrequencyString.left(8);

//    localCalibrFrequencyString.remove(" ");
//    qDebug()<<"localCalibrFrequencyString"<<localCalibrFrequencyString;

//    QVector<QString> localCalibrFrequencyByteVector;
//    for(int i=0; i<localCalibrFrequencyString.size(); i=i+2) {
//        localCalibrFrequencyByteVector.append(localCalibrFrequencyString[i] + "" + localCalibrFrequencyString[i+1]);
//    }
//    qDebug()<<"localCalibrFrequencyByteVector"<<localCalibrFrequencyByteVector;

//    bool ok;
//    quint32 localCalibrFrequencyInt = static_cast<quint8>(localCalibrFrequencyByteVector.at(2).toInt(&ok, 16));//старший байт
//    localCalibrFrequencyInt = (localCalibrFrequencyInt<<8)|(static_cast<quint8>(localCalibrFrequencyByteVector.at(1).toInt(&ok, 16)));//средний байт
//    localCalibrFrequencyInt = (localCalibrFrequencyInt<<8)|(static_cast<quint8>(localCalibrFrequencyByteVector.at(0).toInt(&ok, 16)));//младший байт

//    qDebug()<<"localCalibrFrequencyInt"<<localCalibrFrequencyInt;
//    double localCalibrFrequencyIntModified = (0x10AF75*433.820)/localCalibrFrequencyInt;

//    //извлекаем дату записи из файла прошивки

//    makeKey();

}
/*************************************************************/
void MainWindow::writeSettings()
{
    QSettings settings("HeatCounter.conf", QSettings::IniFormat);
    settings.setValue("portName1", portOptical->portName());
    settings.setValue("portName2", portOptical2->portName());
    settings.setValue("portName3", portOptical3->portName());
    settings.setValue("portName4", portOptical4->portName());
    settings.setValue("portDigitalInterfaceName", portDigitalInterfaceChecking->portName());
    settings.setValue("paramsFileName", ui->lineEdit_loadParamsFile->text());

    //запоминание положениий галочек рабочих мест
    QString vectorIsWorkPlaceUseSettings;

    if(ui->checkBox_workPlace1->isChecked()) {
        vectorIsWorkPlaceUseSettings[0] = '1';
    }
    else {
        vectorIsWorkPlaceUseSettings[0] = '0';
    }

    if(ui->checkBox_workPlace2->isChecked()) {
        vectorIsWorkPlaceUseSettings[1] = '1';
    }
    else {
        vectorIsWorkPlaceUseSettings[1] = '0';
    }

    if(ui->checkBox_workPlace3->isChecked()) {
        vectorIsWorkPlaceUseSettings[2] = '1';
    }
    else {
        vectorIsWorkPlaceUseSettings[2] = '0';
    }

    if(ui->checkBox_workPlace4->isChecked()) {
        vectorIsWorkPlaceUseSettings[3] = '1';
    }
    else {
        vectorIsWorkPlaceUseSettings[3] = '0';
    }

    settings.setValue("vectorIsWorkPlaceUseSettings", vectorIsWorkPlaceUseSettings);

   //запоминание галочек команд
   QString vectorIsCommandUseSettings;

   for(int u=0; u<vectorIsCommandUse.size(); u++) {
       if(vectorIsCommandUse.at(u)) {
           vectorIsCommandUseSettings[u] = '1';
       }
       else {
           vectorIsCommandUseSettings[u] = '0';
       }
   }

   settings.setValue("vectorIsCommandUseSettings", vectorIsCommandUseSettings);

   //запоминание инженера и логина/пароля
   settings.setValue("engineer", humanNameResult);

   if(isRememberLogPas) {
       settings.setValue("logDB", loginDB);
       settings.setValue("pasDB", passwordDB);
   }

   //запоминание параметров соединения
   settings.setValue("hostName", hostName);
   settings.setValue("dataBaseName", dataBaseName);
   settings.setValue("dataBaseUserName", dataBaseUserName);
   settings.setValue("dataBasePassword", dataBasePassword);


}
/*************************************************************/
void MainWindow::loadSettings()
{
    QSettings settings("HeatCounter.conf", QSettings::IniFormat);

    hostName = settings.value("hostName", "192.168.100.1").toString();
    dataBaseName = settings.value("dataBaseName", "gefest").toString();
    dataBaseUserName = settings.value("dataBaseUserName", "gefest").toString();
    dataBasePassword = settings.value("dataBasePassword", "gefest").toString();

    QStringList listParamsConnection = QStringList()<<hostName<<dataBaseName<<dataBaseUserName<<dataBasePassword;

    emit sendParamsConnectFromSettings(listParamsConnection);

    portOptical->setPortName(settings.value("portName1", "COM1").toString());
    ui->comboBox_portListOptical->setCurrentText(settings.value("portName1", "COM1").toString());

    portOptical2->setPortName(settings.value("portName2", "COM1").toString());
    ui->comboBox_portListOptical_2->setCurrentText(settings.value("portName2", "COM1").toString());

    portOptical3->setPortName(settings.value("portName3", "COM1").toString());
    ui->comboBox_portListOptical_3->setCurrentText(settings.value("portName3", "COM1").toString());

    portOptical4->setPortName(settings.value("portName4", "COM1").toString());
    ui->comboBox_portListOptical_4->setCurrentText(settings.value("portName4", "COM1").toString());

    portDigitalInterfaceChecking->setPortName(settings.value("portDigitalInterfaceName", "COM1").toString());
    ui->comboBox_portListInterfaceChecking->setCurrentText(settings.value("portDigitalInterfaceName", "COM1").toString());

    //установка галочек для рабочих мест
    QString vectorIsWorkPlaceUseSettings = settings.value("vectorIsWorkPlaceUseSettings", "0000").toString();

    if(vectorIsWorkPlaceUseSettings.at(0) == "1") {
        ui->checkBox_workPlace1->setChecked(true);
        on_checkBox_workPlace1_clicked(true);
    }
    else {
   //     ui->checkBox_workPlace1->setChecked(false);
    }

    if(vectorIsWorkPlaceUseSettings.at(1) == "1") {
        ui->checkBox_workPlace2->setChecked(true);
        on_checkBox_workPlace2_clicked(true);
    }
    else {
   //     ui->checkBox_workPlace2->setChecked(false);
    }


    if(vectorIsWorkPlaceUseSettings.at(2) == "1") {
        ui->checkBox_workPlace3->setChecked(true);
        on_checkBox_workPlace3_clicked(true);
    }
    else {
 //       ui->checkBox_workPlace3->setChecked(false);
    }


    if(vectorIsWorkPlaceUseSettings.at(3) == "1") {
        ui->checkBox_workPlace4->setChecked(true);
        on_checkBox_workPlace4_clicked(true);
    }
    else {
  //      ui->checkBox_workPlace4->setChecked(false);
    }

    //установка галочек для комманд
    QString vectorIsCommandUseSettings = settings.value("vectorIsCommandUseSettings", "0000000000").toString();

    if(vectorIsCommandUseSettings.at(0) == "1") {
        ui->checkBox_writeParamsUse->setChecked(true);
        on_checkBox_writeParamsUse_clicked(true);
    }
    else {
  //      ui->checkBox_writeParamsUse->setChecked(false);
    }

    //
    if(vectorIsCommandUseSettings.at(1) == "1") {
        ui->checkBox_startCalibrationUse->setChecked(true);
        on_checkBox_startCalibrationUse_clicked(true);
    }
    else {
//        ui->checkBox_startCalibrationUse->setChecked(false);
    }

    //
    if(vectorIsCommandUseSettings.at(2) == "1") {
        ui->checkBox_pulsesOutputHeatUse->setChecked(true);
        on_checkBox_pulsesOutputHeatUse_clicked(true);
    }
    else {
 //       ui->checkBox_pulsesOutputHeatUse->setChecked(false);
    }

    //
    if(vectorIsCommandUseSettings.at(3) == "1") {
        ui->checkBox_pulsesInputVolumeUse->setChecked(true);
        on_checkBox_pulsesInputVolumeUse_clicked(true);
    }
    else {
 //       ui->checkBox_pulsesInputVolumeUse->setChecked(false);
    }

    //
    if(vectorIsCommandUseSettings.at(4) == "1") {
        ui->checkBox_pulsesOutputOffUse->setChecked(true);
        on_checkBox_pulsesOutputOffUse_clicked(true);
    }
    else {
 //       ui->checkBox_pulsesOutputOffUse->setChecked(false);
    }

    //
    if(vectorIsCommandUseSettings.at(5) == "1") {
        ui->checkBox_MBusOnUse->setChecked(true);
        on_checkBox_MBusOnUse_clicked(true);
    }
    else {
 //       ui->checkBox_MBusOnUse->setChecked(false);
    }

    //
    if(vectorIsCommandUseSettings.at(6) == "1") {
        ui->checkBox_CheckMbusUse->setChecked(true);
        on_checkBox_CheckMbusUse_clicked(true);
    }
    else {
  //      ui->checkBox_CheckMbusUse->setChecked(false);
    }

    //
    if(vectorIsCommandUseSettings.at(7) == "1") {
        ui->checkBox_digitalWireInterfaceCheckingUse->setChecked(true);
        on_checkBox_digitalWireInterfaceCheckingUse_clicked(true);
    }
    else {
 //       ui->checkBox_digitalWireInterfaceCheckingUse->setChecked(false);
    }

    //
    if(vectorIsCommandUseSettings.at(8) == "1") {
        ui->checkBox_MBusOffUse->setChecked(true);
        on_checkBox_MBusOffUse_clicked(true);
    }
    else {
 //       ui->checkBox_MBusOffUse->setChecked(false);
    }

    //
    if(vectorIsCommandUseSettings.at(9) == "1") {
        ui->checkBox_calibrationModeOffUse->setChecked(true);
        on_checkBox_calibrationModeOffUse_clicked(true);
    }
    else {
 //       ui->checkBox_calibrationModeOffUse->setChecked(false);
    }


//    fileName = settings.value("fileName", "").toString();
//    ui->lineEdit_programmingFile->setText(fileName);

//    if(fileName == "") {
//        return;
//    }

    //загрузка имени инженера и логина/пароля
    ui->lineEdit_humanName->setText(settings.value("engineer", "").toString());

 //   emit sendLogPasFromSettings(settings.value("logDB", "").toString(), settings.value("pasDB", "").toString());

}
/*************************************************************/
void MainWindow::slotReadyRead()
{

    processData = "";
    qDebug()<<"MainWindow::slotReadyRead()";
    QTextCodec *codec = QTextCodec::codecForName("IBM 866");
    processData = codec->toUnicode(cmd->readAll());//readAll();
    ui->textBrowser->append(processData);//setText(processData);
    qDebug()<<"processData"<<processData;
//    on_pushButton_readProcessOutput_clicked();

}
/*************************************************************/

/*************************************************************/

/*************************************************************/

/*************************************************************/
void MainWindow::on_toolButton_openFile_clicked()
{
//        QMessageBox box;
//        programmingFileToString = "";
//        //специальные настройки для windows
//    //    if(QSysInfo::productType()=="windows")
//    //    {
//    //        QTextCodec *codec = QTextCodec::codecForName("IBM 866");
//    //    }
//    //    QTextCodec
//        QFileDialog fileDialog;
//        fileDialog.setFileMode(QFileDialog::Directory);
//        fileName = fileDialog.getOpenFileName();
//        //
//    //    QByteArray fileNameArray = fileName.toLocal8Bit();
//    //    QTextCodec *codec = QTextCodec::codecForName("IBM 866");
//    //    fileName = codec->toUnicode(fileNameArray);
//        //
//    //    fileName = fileName.toUtf8();
//        ui->lineEdit_programmingFile->setText(fileName);
//        qDebug()<<"fileName"<<fileName;


//        //в файл скрипта scriptEso вставляем название файла прошивки
//        qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//        QFile scriptEso("scriptEso.txt");
//        if(!scriptEso.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл scriptEso.txt");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }


//        //в файл скрипта write_scriptFrequency вставляем номер порта
//    //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//        QFile write_scriptFrequency("write_scriptFrequency.txt");
//        if(!write_scriptFrequency.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptFrequency.txt");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }


//        //в файл скрипта write_scriptParamsFirstField вставляем номер порта
//    //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//        QFile write_scriptParamsFirstField("write_scriptParamsFirstField.txt");
//        if(!write_scriptParamsFirstField.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptParamsFirstField.txt");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }


//        //в файл скрипта write_scriptParamsSecondField вставляем номер порта
//    //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//        QFile write_scriptParamsSecondField("write_scriptParamsSecondField.txt");
//        if(!write_scriptParamsSecondField.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptParamsSecondField.txt");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }


//        //прочитываем файл scriptEso в строку далее в лист
//        QString fileToString = scriptEso.readAll();
//        qDebug()<<"fileToString"<<fileToString;
//        QStringList fileToStringList;
//        QString sym = "";
//        for(int i=0; i<fileToString.size(); i++) {
//            sym = sym + fileToString[i];
//            if(fileToString[i+1] == "\n") {
//     //           sym = sym + "\n";
//                fileToStringList<<sym;
//                sym = "";
//     //           i=i+1;
//            }
//        }
//        qDebug()<<"fileToStringList"<<fileToStringList;


//        //прочитываем файл write_scriptFrequency в строку далее в лист
//        QString fileToStringWrite_scriptFrequency = write_scriptFrequency.readAll();
//        qDebug()<<"fileToStringWrite_scriptFrequency"<<fileToStringWrite_scriptFrequency;
//        QStringList fileToStringWrite_scriptFrequencyList;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptFrequency.size(); i++) {
//            sym = sym + fileToStringWrite_scriptFrequency[i];
//            if(fileToStringWrite_scriptFrequency[i+1] == "\n") {
//     //           sym = sym + "\n";
//                fileToStringWrite_scriptFrequencyList<<sym;
//                sym = "";
//     //           i=i+1;
//            }
//        }

//        //прочитываем файл write_scriptParamsFirstField в строку далее в лист
//        QString fileToStringWrite_scriptParamsFirstField = write_scriptParamsFirstField.readAll();
//        qDebug()<<"fileToStringWrite_scriptParamsFirstField"<<fileToStringWrite_scriptParamsFirstField;
//        QStringList fileToStringWrite_scriptParamsFirstFieldList;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptParamsFirstField.size(); i++) {
//            sym = sym + fileToStringWrite_scriptParamsFirstField[i];
//            if(fileToStringWrite_scriptParamsFirstField[i+1] == "\n") {
//     //           sym = sym + "\n";
//                fileToStringWrite_scriptParamsFirstFieldList<<sym;
//                sym = "";
//     //           i=i+1;
//            }
//        }

//        //прочитываем файл write_scriptParamsSecondField в строку далее в лист
//        QString fileToStringWrite_scriptParamsSecondField = write_scriptParamsSecondField.readAll();
//        qDebug()<<"fileToStringWrite_scriptParamsSecondField"<<fileToStringWrite_scriptParamsSecondField;
//        QStringList fileToStringWrite_scriptParamsSecondFieldList;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptParamsSecondField.size(); i++) {
//            sym = sym + fileToStringWrite_scriptParamsSecondField[i];
//            if(fileToStringWrite_scriptParamsSecondField[i+1] == "\n") {
//     //           sym = sym + "\n";
//                fileToStringWrite_scriptParamsSecondFieldList<<sym;
//                sym = "";
//     //           i=i+1;
//            }
//        }


//        //находим строку с командой RX_DATA_BLOCK
//        bool command_RX_DATA_BLOCK_Exist = false;
//        int numberOfCommandString;
//        for(int i=0; i<fileToStringList.size(); i++) {
//           if(fileToStringList[i].contains("\nRX_DATA_BLOCK")) {
//                command_RX_DATA_BLOCK_Exist = true;
//                numberOfCommandString = i;
//            }
//        }

//        //находим строку с номером порта
//        bool rowWithPortNameExist = false;
//        int numberOfPortNameString;
//        for(int i=0; i<fileToStringList.size(); i++) {
//           if(fileToStringList[i].contains("MODE 5xx_family")) {
//                rowWithPortNameExist = true;
//                numberOfPortNameString = i;
//            }
//        }

//        //записываем в строку с командой RX_DATA_BLOCK название выбранного файла прошивки
//        QString str = "\nRX_DATA_BLOCK " + fileName;
//        str.remove(str.size() - 4, 4);
//        fileToStringList[numberOfCommandString] = "\nRX_DATA_BLOCK " + fileName;

//        //записываем в строку с номером порта текущий порт
//        str = "MODE 5xx_family " + port->portName();
//        fileToStringList[numberOfPortNameString] = str;

//        //записываем новую строку с номером порта в остальные файлы
//        fileToStringWrite_scriptFrequencyList[0] = str;
//        fileToStringWrite_scriptParamsFirstFieldList[0] = str;
//        fileToStringWrite_scriptParamsSecondFieldList[0] = str;

//        //делаем из листа обратно строку, чтобы записать в файл
//        QString stringWriteToFile;
//        sym = "";
//        for(int i=0; i<fileToStringList.size(); i++) {
//        //    fileToStringList[i].remove("\n");
//            sym = sym + fileToStringList[i];
//        }
//        sym = sym + "\n";
//        scriptEso.write("");
//        scriptEso.close();
//        //открываем файл на чтение
//        if(!scriptEso.open(QIODevice::WriteOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }
//        scriptEso.write(sym.toLocal8Bit());

//        scriptEso.close();


//        //делаем из листа обратно строку, чтобы записать в файл write_scriptFrequency
//     //   QString stringWriteToFileScriptFrequency;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptFrequencyList.size(); i++) {
//        //    fileToStringWrite_scriptFrequencyList[i].remove("\n");
//            sym = sym + fileToStringWrite_scriptFrequencyList[i];
//        }
//        sym = sym + "\n";
//        write_scriptFrequency.write("");
//        write_scriptFrequency.close();
//        //открываем файл на чтение
//        if(!write_scriptFrequency.open(QIODevice::WriteOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptFrequency");
//            box.exec();
//            qDebug()<<"не удалось открыть файл write_scriptFrequency";
//            return;
//        }
//        write_scriptFrequency.write(sym.toLocal8Bit());

//        write_scriptFrequency.close();


//        //делаем из листа обратно строку, чтобы записать в файл write_scriptParamsFirstField
//     //       QString stringWriteToFile;
//            sym = "";
//            for(int i=0; i<fileToStringWrite_scriptParamsFirstFieldList.size(); i++) {
//            //    fileToStringWrite_scriptParamsFirstFieldList[i].remove("\n");
//                sym = sym + fileToStringWrite_scriptParamsFirstFieldList[i];
//            }
//            sym = sym + "\n";
//            write_scriptParamsFirstField.write("");
//            write_scriptParamsFirstField.close();
//            //открываем файл на чтение
//            if(!write_scriptParamsFirstField.open(QIODevice::WriteOnly | QIODevice::Text)) {
//                box.setText("Не удалось открыть файл");
//                box.exec();
//                qDebug()<<"не удалось открыть файл";
//                return;
//            }
//            write_scriptParamsFirstField.write(sym.toLocal8Bit());

//            write_scriptParamsFirstField.close();


//        //делаем из листа обратно строку, чтобы записать в файл write_scriptParamsSecondField
//      //      QString stringWriteToFile;
//            sym = "";
//            for(int i=0; i<fileToStringWrite_scriptParamsSecondFieldList.size(); i++) {
//            //    fileToStringWrite_scriptParamsSecondFieldList[i].remove("\n");
//                sym = sym + fileToStringWrite_scriptParamsSecondFieldList[i];
//            }
//            sym = sym + "\n";
//            write_scriptParamsSecondField.write("");
//            write_scriptParamsSecondField.close();
//            //открываем файл на чтение
//            if(!write_scriptParamsSecondField.open(QIODevice::WriteOnly | QIODevice::Text)) {
//                box.setText("Не удалось открыть файл");
//                box.exec();
//                qDebug()<<"не удалось открыть файл";
//                return;
//            }
//            write_scriptParamsSecondField.write(sym.toLocal8Bit());

//            write_scriptParamsSecondField.close();


//        //прочитываем файл прошивки и извлекаем значение калибровочной частоты
//        QFile programmingFile(fileName);
//        if(!programmingFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }

//        //прочитываем файл в строку далее в лист
//        programmingFileToString = programmingFile.readAll();
//        qDebug()<<"programmingFileToString"<<programmingFileToString;
//        programmingFileToStringList.clear();
//        sym = "";
//        for(int i=0; i<programmingFileToString.size(); i++) {
//            sym = sym + programmingFileToString[i];
//            if(programmingFileToString[i+1] == "\n") {
//     //           sym = sym + "\n";
//                programmingFileToStringList<<sym;
//                sym = "";
//                i=i+1;
//            }
//        }
//        qDebug()<<"programmingFileToStringList"<<programmingFileToStringList;

//        firstField = "";
//        firstField = programmingFileToStringList[1];

//        QString localCalibrFrequencyString = firstField.remove("\n");
//        localCalibrFrequencyString.remove(0, 3);
//        localCalibrFrequencyString = localCalibrFrequencyString.left(8);

//        localCalibrFrequencyString.remove(" ");
//        qDebug()<<"localCalibrFrequencyString"<<localCalibrFrequencyString;

//        QVector<QString> localCalibrFrequencyByteVector;
//        for(int i=0; i<localCalibrFrequencyString.size(); i=i+2) {
//            localCalibrFrequencyByteVector.append(localCalibrFrequencyString[i] + "" + localCalibrFrequencyString[i+1]);
//        }
//        qDebug()<<"localCalibrFrequencyByteVector"<<localCalibrFrequencyByteVector;

//        bool ok;
//        quint32 localCalibrFrequencyInt = static_cast<quint8>(localCalibrFrequencyByteVector.at(2).toInt(&ok, 16));//старший байт
//        localCalibrFrequencyInt = (localCalibrFrequencyInt<<8)|(static_cast<quint8>(localCalibrFrequencyByteVector.at(1).toInt(&ok, 16)));//средний байт
//        localCalibrFrequencyInt = (localCalibrFrequencyInt<<8)|(static_cast<quint8>(localCalibrFrequencyByteVector.at(0).toInt(&ok, 16)));//младший байт

//        qDebug()<<"localCalibrFrequencyInt"<<localCalibrFrequencyInt;
//        double localCalibrFrequencyIntModified = (0x10AF75*433.820)/localCalibrFrequencyInt;

//        //извлекаем дату записи из файла прошивки

//        makeKey();

//     //   ui->lineEdit_valueOfFraquency->setText(QString::number(localCalibrFrequencyIntModified));

}
/*************************************************************/
void MainWindow::on_toolButton_clearTextBrowser_clicked()
{
    ui->textBrowser->clear();
}
/*************************************************************/

void MainWindow::on_toolButton_selectProgrammingFile_clicked()
{
        QMessageBox box;
        programmingFileToString = "";
        //специальные настройки для windows
    //    if(QSysInfo::productType()=="windows")
    //    {
    //        QTextCodec *codec = QTextCodec::codecForName("IBM 866");
    //    }
    //    QTextCodec
        QFileDialog fileDialog;
        fileDialog.setFileMode(QFileDialog::Directory);
        fileName = fileDialog.getOpenFileName();
        //
    //    QByteArray fileNameArray = fileName.toLocal8Bit();
    //    QTextCodec *codec = QTextCodec::codecForName("IBM 866");
    //    fileName = codec->toUnicode(fileNameArray);
        //
    //    fileName = fileName.toUtf8();
        ui->lineEdit_programmingFile->setText(fileName);
        qDebug()<<"fileName"<<fileName;


        //в файл скрипта scriptProgramming вставляем название файла прошивки
        qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
        QFile scriptEso("scriptProgramming.txt");
        if(fileName.isEmpty()) {
            return;
        }
        if(!scriptEso.open(QIODevice::ReadOnly | QIODevice::Text)) {
            box.setText("Не удалось открыть файл scriptProgramming.txt");
            box.exec();
            qDebug()<<"не удалось открыть файл";
            ui->toolButton_programmingBSL->setEnabled(false);
            return;
        }


        ui->toolButton_programmingBSL->setEnabled(true);

//        //в файл скрипта write_scriptFrequency вставляем номер порта
//    //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//        QFile write_scriptFrequency("write_scriptFrequency.txt");
//        if(!write_scriptFrequency.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptFrequency.txt");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }


//        //в файл скрипта write_scriptParamsFirstField вставляем номер порта
//    //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//        QFile write_scriptParamsFirstField("write_scriptParamsFirstField.txt");
//        if(!write_scriptParamsFirstField.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptParamsFirstField.txt");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }


//        //в файл скрипта write_scriptParamsSecondField вставляем номер порта
//    //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//        QFile write_scriptParamsSecondField("write_scriptParamsSecondField.txt");
//        if(!write_scriptParamsSecondField.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptParamsSecondField.txt");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }


        //прочитываем файл scriptProgramming в строку далее в лист
        QString fileToString = scriptEso.readAll();
        qDebug()<<"fileToString"<<fileToString;
        QStringList fileToStringList;
        QString sym = "";
        for(int i=0; i<fileToString.size(); i++) {
            sym = sym + fileToString[i];
            if(fileToString[i+1] == "\n") {
     //           sym = sym + "\n";
                fileToStringList<<sym;
                sym = "";
     //           i=i+1;
            }
        }
        qDebug()<<"fileToStringList"<<fileToStringList;


//        //прочитываем файл write_scriptFrequency в строку далее в лист
//        QString fileToStringWrite_scriptFrequency = write_scriptFrequency.readAll();
//        qDebug()<<"fileToStringWrite_scriptFrequency"<<fileToStringWrite_scriptFrequency;
//        QStringList fileToStringWrite_scriptFrequencyList;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptFrequency.size(); i++) {
//            sym = sym + fileToStringWrite_scriptFrequency[i];
//            if(fileToStringWrite_scriptFrequency[i+1] == "\n") {
//     //           sym = sym + "\n";
//                fileToStringWrite_scriptFrequencyList<<sym;
//                sym = "";
//     //           i=i+1;
//            }
//        }

//        //прочитываем файл write_scriptParamsFirstField в строку далее в лист
//        QString fileToStringWrite_scriptParamsFirstField = write_scriptParamsFirstField.readAll();
//        qDebug()<<"fileToStringWrite_scriptParamsFirstField"<<fileToStringWrite_scriptParamsFirstField;
//        QStringList fileToStringWrite_scriptParamsFirstFieldList;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptParamsFirstField.size(); i++) {
//            sym = sym + fileToStringWrite_scriptParamsFirstField[i];
//            if(fileToStringWrite_scriptParamsFirstField[i+1] == "\n") {
//     //           sym = sym + "\n";
//                fileToStringWrite_scriptParamsFirstFieldList<<sym;
//                sym = "";
//     //           i=i+1;
//            }
//        }

//        //прочитываем файл write_scriptParamsSecondField в строку далее в лист
//        QString fileToStringWrite_scriptParamsSecondField = write_scriptParamsSecondField.readAll();
//        qDebug()<<"fileToStringWrite_scriptParamsSecondField"<<fileToStringWrite_scriptParamsSecondField;
//        QStringList fileToStringWrite_scriptParamsSecondFieldList;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptParamsSecondField.size(); i++) {
//            sym = sym + fileToStringWrite_scriptParamsSecondField[i];
//            if(fileToStringWrite_scriptParamsSecondField[i+1] == "\n") {
//     //           sym = sym + "\n";
//                fileToStringWrite_scriptParamsSecondFieldList<<sym;
//                sym = "";
//     //           i=i+1;
//            }
//        }


        //находим строку с командой RX_DATA_BLOCK
        bool command_RX_DATA_BLOCK_Exist = false;
        int numberOfCommandString;
        for(int i=0; i<fileToStringList.size(); i++) {
           if(fileToStringList[i].contains("\nRX_DATA_BLOCK")) {
                command_RX_DATA_BLOCK_Exist = true;
                numberOfCommandString = i;
            }
        }

        //находим строку с номером порта
        bool rowWithPortNameExist = false;
        int numberOfPortNameString;
        for(int i=0; i<fileToStringList.size(); i++) {
           if(fileToStringList[i].contains("MODE 6xx_family")) {
                rowWithPortNameExist = true;
                numberOfPortNameString = i;
            }
        }

        //записываем в строку с командой RX_DATA_BLOCK название выбранного файла прошивки
        QString str = "\nRX_DATA_BLOCK " + fileName;
        str.remove(str.size() - 4, 4);
        fileToStringList[numberOfCommandString] = "\nRX_DATA_BLOCK " + fileName;

        //записываем в строку с номером порта текущий порт
        str = "MODE 6xx_family " + port->portName();
        fileToStringList[numberOfPortNameString] = str;

//        //записываем новую строку с номером порта в остальные файлы
//        fileToStringWrite_scriptFrequencyList[0] = str;
//        fileToStringWrite_scriptParamsFirstFieldList[0] = str;
//        fileToStringWrite_scriptParamsSecondFieldList[0] = str;

        //делаем из листа обратно строку, чтобы записать в файл
        QString stringWriteToFile;
        sym = "";
        for(int i=0; i<fileToStringList.size(); i++) {
        //    fileToStringList[i].remove("\n");
            sym = sym + fileToStringList[i];
        }
        sym = sym + "\n";
        scriptEso.write("");
        scriptEso.close();
        //открываем файл на чтение
        if(!scriptEso.open(QIODevice::WriteOnly | QIODevice::Text)) {
            box.setText("Не удалось открыть файл");
            box.exec();
            qDebug()<<"не удалось открыть файл";
            return;
        }
        scriptEso.write(sym.toLocal8Bit());

        scriptEso.close();


//        //делаем из листа обратно строку, чтобы записать в файл write_scriptFrequency
//     //   QString stringWriteToFileScriptFrequency;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptFrequencyList.size(); i++) {
//        //    fileToStringWrite_scriptFrequencyList[i].remove("\n");
//            sym = sym + fileToStringWrite_scriptFrequencyList[i];
//        }
//        sym = sym + "\n";
//        write_scriptFrequency.write("");
//        write_scriptFrequency.close();
//        //открываем файл на чтение
//        if(!write_scriptFrequency.open(QIODevice::WriteOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptFrequency");
//            box.exec();
//            qDebug()<<"не удалось открыть файл write_scriptFrequency";
//            return;
//        }
//        write_scriptFrequency.write(sym.toLocal8Bit());

//        write_scriptFrequency.close();


//        //делаем из листа обратно строку, чтобы записать в файл write_scriptParamsFirstField
//     //       QString stringWriteToFile;
//            sym = "";
//            for(int i=0; i<fileToStringWrite_scriptParamsFirstFieldList.size(); i++) {
//            //    fileToStringWrite_scriptParamsFirstFieldList[i].remove("\n");
//                sym = sym + fileToStringWrite_scriptParamsFirstFieldList[i];
//            }
//            sym = sym + "\n";
//            write_scriptParamsFirstField.write("");
//            write_scriptParamsFirstField.close();
//            //открываем файл на чтение
//            if(!write_scriptParamsFirstField.open(QIODevice::WriteOnly | QIODevice::Text)) {
//                box.setText("Не удалось открыть файл");
//                box.exec();
//                qDebug()<<"не удалось открыть файл";
//                return;
//            }
//            write_scriptParamsFirstField.write(sym.toLocal8Bit());

//            write_scriptParamsFirstField.close();


//        //делаем из листа обратно строку, чтобы записать в файл write_scriptParamsSecondField
//      //      QString stringWriteToFile;
//            sym = "";
//            for(int i=0; i<fileToStringWrite_scriptParamsSecondFieldList.size(); i++) {
//            //    fileToStringWrite_scriptParamsSecondFieldList[i].remove("\n");
//                sym = sym + fileToStringWrite_scriptParamsSecondFieldList[i];
//            }
//            sym = sym + "\n";
//            write_scriptParamsSecondField.write("");
//            write_scriptParamsSecondField.close();
//            //открываем файл на чтение
//            if(!write_scriptParamsSecondField.open(QIODevice::WriteOnly | QIODevice::Text)) {
//                box.setText("Не удалось открыть файл");
//                box.exec();
//                qDebug()<<"не удалось открыть файл";
//                return;
//            }
//            write_scriptParamsSecondField.write(sym.toLocal8Bit());

//            write_scriptParamsSecondField.close();


//        //прочитываем файл прошивки и извлекаем значение калибровочной частоты
//        QFile programmingFile(fileName);
//        if(!programmingFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }

//        //прочитываем файл в строку далее в лист
//        programmingFileToString = programmingFile.readAll();
//        qDebug()<<"programmingFileToString"<<programmingFileToString;
//        programmingFileToStringList.clear();
//        sym = "";
//        for(int i=0; i<programmingFileToString.size(); i++) {
//            sym = sym + programmingFileToString[i];
//            if(programmingFileToString[i+1] == "\n") {
//     //           sym = sym + "\n";
//                programmingFileToStringList<<sym;
//                sym = "";
//                i=i+1;
//            }
//        }
//        qDebug()<<"programmingFileToStringList"<<programmingFileToStringList;

//        firstField = "";
//        firstField = programmingFileToStringList[1];

//        QString localCalibrFrequencyString = firstField.remove("\n");
//        localCalibrFrequencyString.remove(0, 3);
//        localCalibrFrequencyString = localCalibrFrequencyString.left(8);

//        localCalibrFrequencyString.remove(" ");
//        qDebug()<<"localCalibrFrequencyString"<<localCalibrFrequencyString;

//        QVector<QString> localCalibrFrequencyByteVector;
//        for(int i=0; i<localCalibrFrequencyString.size(); i=i+2) {
//            localCalibrFrequencyByteVector.append(localCalibrFrequencyString[i] + "" + localCalibrFrequencyString[i+1]);
//        }
//        qDebug()<<"localCalibrFrequencyByteVector"<<localCalibrFrequencyByteVector;

//        bool ok;
//        quint32 localCalibrFrequencyInt = static_cast<quint8>(localCalibrFrequencyByteVector.at(2).toInt(&ok, 16));//старший байт
//        localCalibrFrequencyInt = (localCalibrFrequencyInt<<8)|(static_cast<quint8>(localCalibrFrequencyByteVector.at(1).toInt(&ok, 16)));//средний байт
//        localCalibrFrequencyInt = (localCalibrFrequencyInt<<8)|(static_cast<quint8>(localCalibrFrequencyByteVector.at(0).toInt(&ok, 16)));//младший байт

//        qDebug()<<"localCalibrFrequencyInt"<<localCalibrFrequencyInt;
//        double localCalibrFrequencyIntModified = (0x10AF75*433.820)/localCalibrFrequencyInt;

//        //извлекаем дату записи из файла прошивки

//        makeKey();

     //   ui->lineEdit_valueOfFraquency->setText(QString::number(localCalibrFrequencyIntModified));

}

void MainWindow::on_comboBox_portList_currentIndexChanged(const QString &arg1)
{
//    return;

        port->close();
        port->setPortName(arg1);
        portName = arg1;

        QMessageBox box;
        programmingFileToString = "";
        //специальные настройки для windows
    //    if(QSysInfo::productType()=="windows")
    //    {
    //        QTextCodec *codec = QTextCodec::codecForName("IBM 866");
    //    }
    //    QTextCodec
    //    QFileDialog fileDialog;
    //    fileDialog.setFileMode(QFileDialog::Directory);
    //    fileName = fileDialog.getOpenFileName();
    //    //
    //  //    QByteArray fileNameArray = fileName.toLocal8Bit();
    //  //    QTextCodec *codec = QTextCodec::codecForName("IBM 866");
    //  //    fileName = codec->toUnicode(fileNameArray);
    //    //

    //    fileName = fileName.toUtf8();

    //    ui->lineEdit_programmingFile->setText(fileName);

    //    qDebug()<<"fileName"<<fileName;


        //в файл скрипта scriptProgramming вставляем название файла прошивки
        qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
        QFile scriptEso("scriptProgramming.txt");
        if(!scriptEso.open(QIODevice::ReadOnly | QIODevice::Text)) {
            box.setText("Не удалось открыть файл scriptProgramming.txt");
            box.exec();
            qDebug()<<"не удалось открыть файл";
            return;
        }


//        //в файл скрипта write_scriptFrequency вставляем номер порта
//    //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//        QFile write_scriptFrequency("write_scriptFrequency.txt");
//        if(!write_scriptFrequency.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptFrequency.txt");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }


//        //в файл скрипта write_scriptParamsFirstField вставляем номер порта
//    //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//        QFile write_scriptParamsFirstField("write_scriptParamsFirstField.txt");
//        if(!write_scriptParamsFirstField.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptParamsFirstField.txt");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }


//        //в файл скрипта write_scriptParamsSecondField вставляем номер порта
//    //    qDebug()<<"QDir::currentPath()"<<QDir::currentPath();
//        QFile write_scriptParamsSecondField("write_scriptParamsSecondField.txt");
//        if(!write_scriptParamsSecondField.open(QIODevice::ReadOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptParamsSecondField.txt");
//            box.exec();
//            qDebug()<<"не удалось открыть файл";
//            return;
//        }


        //прочитываем файл scriptProgramming в строку далее в лист
        QString fileToString = scriptEso.readAll();
        qDebug()<<"fileToString"<<fileToString;
        QStringList fileToStringList;
        QString sym = "";
        for(int i=0; i<fileToString.size(); i++) {
            sym = sym + fileToString[i];
            if(fileToString[i+1] == "\n") {
     //           sym = sym + "\n";
                fileToStringList<<sym;
                sym = "";
     //           i=i+1;
            }
        }
        qDebug()<<"fileToStringList"<<fileToStringList;


//        //прочитываем файл write_scriptFrequency в строку далее в лист
//        QString fileToStringWrite_scriptFrequency = write_scriptFrequency.readAll();
//        qDebug()<<"fileToStringWrite_scriptFrequency"<<fileToStringWrite_scriptFrequency;
//        QStringList fileToStringWrite_scriptFrequencyList;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptFrequency.size(); i++) {
//            sym = sym + fileToStringWrite_scriptFrequency[i];
//            if(fileToStringWrite_scriptFrequency[i+1] == "\n") {
//     //           sym = sym + "\n";
//                fileToStringWrite_scriptFrequencyList<<sym;
//                sym = "";
//     //           i=i+1;
//            }
//        }

//        //прочитываем файл write_scriptParamsFirstField в строку далее в лист
//        QString fileToStringWrite_scriptParamsFirstField = write_scriptParamsFirstField.readAll();
//        qDebug()<<"fileToStringWrite_scriptParamsFirstField"<<fileToStringWrite_scriptParamsFirstField;
//        QStringList fileToStringWrite_scriptParamsFirstFieldList;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptParamsFirstField.size(); i++) {
//            sym = sym + fileToStringWrite_scriptParamsFirstField[i];
//            if(fileToStringWrite_scriptParamsFirstField[i+1] == "\n") {
//     //           sym = sym + "\n";
//                fileToStringWrite_scriptParamsFirstFieldList<<sym;
//                sym = "";
//     //           i=i+1;
//            }
//        }

//        //прочитываем файл write_scriptParamsSecondField в строку далее в лист
//        QString fileToStringWrite_scriptParamsSecondField = write_scriptParamsSecondField.readAll();
//        qDebug()<<"fileToStringWrite_scriptParamsSecondField"<<fileToStringWrite_scriptParamsSecondField;
//        QStringList fileToStringWrite_scriptParamsSecondFieldList;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptParamsSecondField.size(); i++) {
//            sym = sym + fileToStringWrite_scriptParamsSecondField[i];
//            if(fileToStringWrite_scriptParamsSecondField[i+1] == "\n") {
//     //           sym = sym + "\n";
//                fileToStringWrite_scriptParamsSecondFieldList<<sym;
//                sym = "";
//     //           i=i+1;
//            }
//        }


        //находим строку с командой RX_DATA_BLOCK
        bool command_RX_DATA_BLOCK_Exist = false;
        int numberOfCommandString;
        for(int i=0; i<fileToStringList.size(); i++) {
           if(fileToStringList[i].contains("\nRX_DATA_BLOCK")) {
                command_RX_DATA_BLOCK_Exist = true;
                numberOfCommandString = i;
            }
        }

        //находим строку с номером порта
        bool rowWithPortNameExist = false;
        int numberOfPortNameString;
        for(int i=0; i<fileToStringList.size(); i++) {
           if(fileToStringList[i].contains("MODE 6xx_family")) {
                rowWithPortNameExist = true;
                numberOfPortNameString = i;
            }
        }

        //записываем в строку с командой RX_DATA_BLOCK название выбранного файла прошивки
        QString str = "\nRX_DATA_BLOCK " + fileName;
        str.remove(str.size() - 4, 4);
        fileToStringList[numberOfCommandString] = "\nRX_DATA_BLOCK " + fileName;

        //записываем в строку с номером порта текущий порт
        str = "MODE 6xx_family " + port->portName();
        fileToStringList[numberOfPortNameString] = str;

//        //записываем новую строку с номером порта в остальные файлы
//        fileToStringWrite_scriptFrequencyList[0] = str;
//        fileToStringWrite_scriptParamsFirstFieldList[0] = str;
//        fileToStringWrite_scriptParamsSecondFieldList[0] = str;

        //делаем из листа обратно строку, чтобы записать в файл
        QString stringWriteToFile;
        sym = "";
        for(int i=0; i<fileToStringList.size(); i++) {
        //    fileToStringList[i].remove("\n");
            sym = sym + fileToStringList[i];
        }
        sym = sym + "\n";
        scriptEso.write("");
        scriptEso.close();
        //открываем файл на чтение
        if(!scriptEso.open(QIODevice::WriteOnly | QIODevice::Text)) {
            box.setText("Не удалось открыть файл");
            box.exec();
            qDebug()<<"не удалось открыть файл";
            return;
        }
        scriptEso.write(sym.toLocal8Bit());

        scriptEso.close();


//        //делаем из листа обратно строку, чтобы записать в файл write_scriptFrequency
//     //   QString stringWriteToFileScriptFrequency;
//        sym = "";
//        for(int i=0; i<fileToStringWrite_scriptFrequencyList.size(); i++) {
//        //    fileToStringWrite_scriptFrequencyList[i].remove("\n");
//            sym = sym + fileToStringWrite_scriptFrequencyList[i];
//        }
//        sym = sym + "\n";
//        write_scriptFrequency.write("");
//        write_scriptFrequency.close();
//        //открываем файл на чтение
//        if(!write_scriptFrequency.open(QIODevice::WriteOnly | QIODevice::Text)) {
//            box.setText("Не удалось открыть файл write_scriptFrequency");
//            box.exec();
//            qDebug()<<"не удалось открыть файл write_scriptFrequency";
//            return;
//        }
//        write_scriptFrequency.write(sym.toLocal8Bit());

//        write_scriptFrequency.close();


//        //делаем из листа обратно строку, чтобы записать в файл write_scriptParamsFirstField
//     //       QString stringWriteToFile;
//            sym = "";
//            for(int i=0; i<fileToStringWrite_scriptParamsFirstFieldList.size(); i++) {
//            //    fileToStringWrite_scriptParamsFirstFieldList[i].remove("\n");
//                sym = sym + fileToStringWrite_scriptParamsFirstFieldList[i];
//            }
//            sym = sym + "\n";
//            write_scriptParamsFirstField.write("");
//            write_scriptParamsFirstField.close();
//            //открываем файл на чтение
//            if(!write_scriptParamsFirstField.open(QIODevice::WriteOnly | QIODevice::Text)) {
//                box.setText("Не удалось открыть файл");
//                box.exec();
//                qDebug()<<"не удалось открыть файл";
//                return;
//            }
//            write_scriptParamsFirstField.write(sym.toLocal8Bit());

//            write_scriptParamsFirstField.close();


//        //делаем из листа обратно строку, чтобы записать в файл write_scriptParamsSecondField
//      //      QString stringWriteToFile;
//            sym = "";
//            for(int i=0; i<fileToStringWrite_scriptParamsSecondFieldList.size(); i++) {
//            //    fileToStringWrite_scriptParamsSecondFieldList[i].remove("\n");
//                sym = sym + fileToStringWrite_scriptParamsSecondFieldList[i];
//            }
//            sym = sym + "\n";
//            write_scriptParamsSecondField.write("");
//            write_scriptParamsSecondField.close();
//            //открываем файл на чтение
//            if(!write_scriptParamsSecondField.open(QIODevice::WriteOnly | QIODevice::Text)) {
//                box.setText("Не удалось открыть файл");
//                box.exec();
//                qDebug()<<"не удалось открыть файл";
//                return;
//            }
//            write_scriptParamsSecondField.write(sym.toLocal8Bit());

//            write_scriptParamsSecondField.close();

}
/*************************************************************/
void MainWindow::makePacketToRead(quint8 numByte, quint8 command)
{
    packetToRead.clear();
    quint8 byte = 0x5a;
    packetToRead.append(byte);
    byte = 0x00;
    packetToRead.append(byte);
    byte = 0x05;
    packetToRead.append(byte);
    byte = 0x01;
    packetToRead.append(byte);

    quint8 crc = makeCRC(packetToRead);

    packetToRead.append(crc);

//    packetToRead.append(synByte);
//    packetToRead.append(numByte);
//    packetToRead.append(command);
//    //генерация crc
//    /*int*/ quint16 crc = 0xFFFF;
//    int len = packetToRead.size();
//    char *block = packetToRead.data();
//    while(len--)//for(int j=0; j<packetToRead.size(); j++)
//    {
//    //    quint16 byte = static_cast<quint8>(packetToRead[j]);
//        crc ^= *block++ << 8;//packet[j];//*pdata++;
//        for (int i=0; i<8; i++)
//        {
//          crc = crc & 0x8000 ? (crc << 1) ^ 0x1021 : crc << 1;
//        }
//    }
//    qDebug()<<"crc"<<crc;//QString::number(crc, 16);

//    packetToRead.append(crc&0xFF);//lo
//    packetToRead.append((crc>>8)&0xFF);//hi
//    packetToRead.trimmed();
//    qDebug()<<"crc.size"<<sizeof(crc);
//    qDebug()<<"packetToReadHex"<<packetToRead.toHex();
//    qDebug()<<"packetToRead.size"<<packetToRead.size();
}
/*************************************************************/
quint8 MainWindow::makeCRC(QByteArray buffer)
{
//    quint8 crc = 0xFF;
//    int i;
//    char *bufferPoint = buffer.data();

//    int len = buffer.size();

//    while (len--) {
//        crc ^= *bufferPoint++;

//        for(i=0; i<8; i++) {
//            crc = crc & 0x80 ? (crc << 1) ^ 0x31 : crc << 1;
//        }

//        crc ^= 0xFF;
//        return crc;

//    }

    quint8 crc = 0x00;

    for(int i=1; i<buffer.size(); i++) {
        //reverse
        //
        quint8 byte = buffer.at(i);
        quint8 temp = reverse8(byte);

        crc ^= temp;

        for(int j=0; j<8; j++) {
            temp = crc & 0x80;
            crc = crc<<1;
            if(temp) {
                crc ^= 0x31;
            }
        }
    }

    crc = reverse8(crc);

    return crc;

}
/*************************************************************/
quint8 MainWindow::checkCRC(QByteArray buffer)
{
    quint8 crc = 0x00;

    for(int i=1; i<buffer.size(); i++) {
        //reverse
        //
        quint8 byte = buffer.at(i);
        quint8 temp = reverse8(byte);

        crc ^= temp;

        for(int j=0; j<8; j++) {
            temp = crc & 0x80;
            crc = crc<<1;
            if(temp) {
                crc ^= 0x31;
            }
        }
    }

    crc = reverse8(crc);

    return crc;
}
/*************************************************************/
void MainWindow::readFromCounter()
{
    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
        }
    }
    makePacketToRead(1, 1);

    quint64 cnt = portOptical->write(packetToRead);

    qDebug()<<"cnt "<<cnt
            <<"packetToRead "<<packetToRead.toHex()
            <<"portOptical->portName() "<<portOptical->portName();

    if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));



}
/*************************************************************/

void MainWindow::on_toolButton_sendCommandOptical_clicked()
{
 //   readFromCounter();

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
        }
    }

    quint64 cnt = portOptical->write(packetFromLineEdit);

    qDebug()<<"cnt "<<cnt
            <<"packetFromLineEdit.toHex() "<<packetFromLineEdit.toHex()
            <<"portOptical->portName() "<<portOptical->portName();

    if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

    global::pause(300);

    ui->textBrowser->append("buffer.toHex() " + portOptical->readAll().toHex());
}
/*************************************************************/
void MainWindow::slotReadyReadOptical()
{
    QByteArray buffer = portOptical->readAll();

    ui->textBrowser->append(buffer.toHex());

    qDebug()<<"buffer.toHex()"<<buffer.toHex();
}
/*************************************************************/
void MainWindow::on_comboBox_portListOptical_currentIndexChanged(const QString &arg1)
{
    portOptical->close();
    portOptical->setPortName(arg1);
    portNameOptical = arg1;

    qDebug()<<"portOptical->portName()"<<portOptical->portName();
}
/*************************************************************/
quint8 MainWindow::reverse8(quint8 temp)
{
    quint8 result=0,
    i;
    for(i=0;i<8;i++) {
       if (temp & (1 << i)) {
          result |= 1 << (7-i);
       }
    }

//    qDebug()<<"QString::number(result) "<<QString::number(result);

    return result;
}
/*************************************************************/
void MainWindow::on_lineEdit_reverse_textChanged(const QString &arg1)
{
    bool ok;
    quint8 byte = arg1.toInt(&ok);
    reverse8(byte);
}
/*************************************************************/
void MainWindow::on_toolButton_saveTemplate_clicked()
{
    QFileDialog fileDialog;
    fileDialog.setFileMode(QFileDialog::Directory);
    QString fileName = fileDialog.getSaveFileName(this, tr("Save File"),
                                                  QDir::currentPath(),
                                                  tr("Текст (*.txt)"));

//    QString channel = ui->comboBox_channelNumberWmbus->currentText();
//    QString power = ui->comboBox_power->currentText();
//    QString timeOfWaiting = QString::number(ui->spinBox_timeOfWaitingReceiver->value(), 10);
//    QString minTimeout = QString::number(ui->spinBox_minTimeoutRadio->value(), 10);
//    QString maxTimeout = QString::number(ui->spinBox_maxTimeoutRadio->value(), 10);
//    QString defaultTimeout = QString::number(ui->spinBox_timeoutRadioDefault->value(), 10);
//    QString counterNumber = ui->lineEdit_counterNumber->text();
//    QString coef = ui->lineEdit_coefScoreDecimal->text();
//    QString startValue = ui->lineEdit_startValue->text();

    QFile saveTemplate(fileName);
    //открываем файл для очистки
    if(!saveTemplate.open(QIODevice::ReadWrite | QIODevice::Truncate)) {
        QMessageBox box;
        box.setText("Не удалось открыть файл");
        box.exec();
        qDebug()<<"не удалось открыть файл";
        return;
    }
    saveTemplate.close();

    //открываем файл для записи
    if(!saveTemplate.open(QIODevice::WriteOnly | QIODevice::Text)) {
//        stream << str;
        QMessageBox box;
        box.setText("Не удалось открыть файл");
        box.exec();
        qDebug()<<"не удалось открыть файл";
        return;
    }
    //создаём поток записи в файл
    QFile *filePointer = &saveTemplate;
    QTextStream stream(filePointer);
    //
    //
    stream.setCodec("UTF-8");//("Windows-1251");
    stream<<"serial " + ui->lineEdit_serial->text() + "\n";
    stream<<"ManCode " + ui->comboBox_ManCode->currentText() + "\n";
    stream<<"DevType " + ui->comboBox_DevType->currentText() + "\n";
    stream<<"DN " + ui->comboBox_DN->currentText() + "\n";
    stream<<"PCB_SN " + ui->lineEdit_PCB_SN->text() + "\n";
    //
    stream<<"Flow_min " + ui->lineEdit_Flow_min->text() + "\n";
    stream<<"Flow_max " + ui->lineEdit_Flow_max->text() + "\n";
    stream<<"Tin_min " + QString::number(ui->spinBox_Tin_min->value()) + "\n";
    stream<<"Tin_max " + QString::number(ui->spinBox_Tin_max->value()) + "\n";
    stream<<"Tout_min " + QString::number(ui->spinBox_Tout_min->value()) + "\n";
    stream<<"Tout_max " + QString::number(ui->spinBox_Tout_max->value()) + "\n";
    stream<<"ReportData " + QString::number(ui->spinBox_ReportData->value()) + "\n";
    stream<<"Average_T " + ui->comboBox_Average_T->currentText() + "\n";
    stream<<"PulsesMode1 " + ui->comboBox_PulsesMode1->currentText() + "\n";
    stream<<"PulsesMode2 " + ui->comboBox_PulsesMode2->currentText() + "\n";
    stream<<"PulsesValue1 " + ui->lineEdit_PulsesValue1->text() + "\n";
    stream<<"PulsesValue2 " + ui->lineEdit_PulsesValue2->text() + "\n";
    //
    stream<<"FlowRate " + ui->comboBox_FlowRate->currentText() + "\n";
    stream<<"Pressure " + ui->lineEdit_Pressure->text() + "\n";
    stream<<"RTD_Type " + ui->comboBox_RTD_Type->currentText() + "\n";
    stream<<"R_RTD " + ui->lineEdit_R_RTD->text() + "\n";
    stream<<"RWire1 " + ui->lineEdit_RWire1->text() + "\n";
    stream<<"RWire2 " + ui->lineEdit_RWire2->text() + "\n";
    stream<<"FlowNom " + ui->comboBox_FlowNom->currentText() + "\n";
    //
    stream<<"FlCoeff0 " + ui->lineEdit_coef0->text() + "\n";
    stream<<"FlCoeff1 " + ui->lineEdit_coef1->text() + "\n";
    stream<<"FlCoeff2 " + ui->lineEdit_coef2->text() + "\n";
    stream<<"FlCoeff3 " + ui->lineEdit_coef3->text() + "\n";
    stream<<"FlCoeff4 " + ui->lineEdit_coef4->text() + "\n";
    stream<<"FlCoeff5 " + ui->lineEdit_coef5->text() + "\n";
    //
    stream<<"FS_DiffThrs " + ui->lineEdit_FS_DiffThrs->text() + "\n";
    //
    QDateTime dateTimeRealClock = ui->dateTimeEdit_realClock->dateTime();
    stream<<"DateTime_RealClock " + dateTimeRealClock.toString("dd.MM.yyyy hh:mm:ss") + "\n";
    stream<<"ASW_flag " + ui->comboBox_ASW_flag->currentText() + "\n";
    //
    stream<<"Shift_T1 " + ui->lineEdit_Shift_T1->text() + "\n";
    stream<<"Shift_T2 " + ui->lineEdit_Shift_T2->text() + "\n";
    stream<<"Scale_T1 " + ui->lineEdit_Scale_T1->text() + "\n";
    stream<<"Scale_T2 " + ui->lineEdit_Scale_T2->text() + "\n";
    //
    stream<<"PrimAddr " + QString::number(ui->spinBox_Addr->value()) + "\n";
    stream<<"BaudRate " + ui->comboBox_BaudRate->currentText() + "\n";
    stream<<"HMP_Trans " + ui->lineEdit_HMP_Trans->text() + "\n";
    stream<<"EPP_Trans " + ui->lineEdit_EPP_Trans->text() + "\n";
    stream<<"P1PrimAddr " + QString::number(ui->spinBox_P1PrimAddr->value()) + "\n";
    stream<<"P2PrimAddr " + QString::number(ui->spinBox_P2PrimAddr->value()) + "\n";
    stream<<"ProtType " + ui->lineEdit_ProtType->text() + "\n";
    //
    stream<<"Serial_P1 " + ui->lineEdit_Serial_P1->text() + "\n";
    stream<<"ManCode_P1 " + ui->lineEdit_ManCode_P1->text() + "\n";
    stream<<"DevType_P1 " + ui->lineEdit_DevType_P1->text() + "\n";
    stream<<"Version_P1 " + ui->lineEdit_Version_P1->text() + "\n";
    stream<<"Initial_value_P1 " + ui->lineEdit_Initial_value_P1->text() + "\n";
    stream<<"Service_P1 " + ui->lineEdit_Service_P1->text() + "\n";
    //
    stream<<"Serial_P2 " + ui->lineEdit_Serial_P2->text() + "\n";
    stream<<"ManCode_P2 " + ui->lineEdit_ManCode_P2->text() + "\n";
    stream<<"DevType_P2 " + ui->lineEdit_DevType_P2->text() + "\n";
    stream<<"Version_P2 " + ui->lineEdit_Version_P2->text() + "\n";
    stream<<"Initial_value_P2 " + ui->lineEdit_Initial_value_P2->text() + "\n";
    stream<<"Service_P2 " + ui->lineEdit_Service_P2->text() + "\n";
    //
    //

    saveTemplate.close();
}
/*************************************************************/
void MainWindow::on_toolButton_loadTemplate_clicked()
{
    QMessageBox box;
    QFileDialog fileDialog;
    fileDialog.setFileMode(QFileDialog::Directory);
    QString fileName = fileDialog.getOpenFileName(this, tr("Open File"),
                                                  QDir::currentPath() + "/cfg",
                                                  tr("Текст (*.prm)"));
    qDebug()<<"fileName"<<fileName;
    ui->lineEdit_loadParamsFile->setText(fileName);

    QFile loadTemplate(fileName);
    if(fileName.isEmpty()) {
        return;
    }
    if(!loadTemplate.open(QIODevice::ReadOnly | QIODevice::Text)) {
        box.setText("Не удалось открыть файл");
        box.exec();
        qDebug()<<"не удалось открыть файл";
//        ui->toolButton_writeParams->setEnabled(false);
//        ui->toolButton_pulsesInputVolume->setEnabled(false);
//        ui->toolButton_pulsesOutputHeat->setEnabled(false);
//        ui->toolButton_pulsesOutputOff->setEnabled(false);
//        ui->toolButton_digitalWireInterfaceChecking->setEnabled(false);
//        ui->toolButton_MBusOn->setEnabled(false);
//        ui->toolButton_MBusOff->setEnabled(false);
//        ui->toolButton_CheckMbus->setEnabled(false);
//        ui->toolButton_calibrationModeOff->setEnabled(false);
//        ui->toolButton_result->setEnabled(false);
//        ui->toolButton_resultFileChecking->setEnabled(false);
        initFileNameResult = "";
        return;
    }
    //прочитываем файл в строку далее в лист
    QString fileToString = loadTemplate.readAll();
    qDebug()<<"fileToString"<<fileToString;
    QStringList fileToStringList;
    QString sym = "";
    for(int i=0; i<fileToString.size(); i++) {
        sym = sym + fileToString[i];
        if(fileToString[i+1] == "\n") {
 //           sym = sym + "\n";
            fileToStringList<<sym;
            sym = "";
 //           i=i+1;
        }
    }
    qDebug()<<"fileToStringList"<<fileToStringList;

    if(fileToStringList.size() == 62) {
//        ui->toolButton_writeParams->setEnabled(true);
//        ui->toolButton_pulsesInputVolume->setEnabled(true);
//        ui->toolButton_pulsesOutputHeat->setEnabled(true);
//        ui->toolButton_pulsesOutputOff->setEnabled(true);
//        ui->toolButton_digitalWireInterfaceChecking->setEnabled(true);
//        ui->toolButton_MBusOn->setEnabled(true);
//        ui->toolButton_MBusOff->setEnabled(true);
//        ui->toolButton_CheckMbus->setEnabled(true);
//        ui->toolButton_calibrationModeOff->setEnabled(true);
//        ui->toolButton_result->setEnabled(true);
//        ui->toolButton_resultFileChecking->setEnabled(true);
        initFileNameResult = fileName;

    }
    else {
//        ui->toolButton_writeParams->setEnabled(false);
//        ui->toolButton_pulsesInputVolume->setEnabled(false);
//        ui->toolButton_pulsesOutputHeat->setEnabled(false);
//        ui->toolButton_pulsesOutputOff->setEnabled(false);
//        ui->toolButton_digitalWireInterfaceChecking->setEnabled(false);
//        ui->toolButton_MBusOn->setEnabled(false);
//        ui->toolButton_MBusOff->setEnabled(false);
//        ui->toolButton_CheckMbus->setEnabled(false);
//        ui->toolButton_calibrationModeOff->setEnabled(false);
//        ui->toolButton_result->setEnabled(false);
//        ui->toolButton_resultFileChecking->setEnabled(false);
        initFileNameResult ="";
        QMessageBox::information(this, "", "Неверный формат файла");
        return;
    }

    emit sendParamsStringListFromFileToFormParamsedit(fileToStringList);

    global::pause(300);

    loadTemplate.close();



    QString serialString = fileToStringList[0];
    if(!serialString.contains("serial ")) {
        QMessageBox::information(this, "", tr("Отсутствует параментр: serial"));
        return;
    }
    serialString.remove("serial ");
 //   ui->lineEdit_serial->setText(serialString.left(3));
    ui->spinBox_serial_->setValue(serialString.right(5).toInt());
    on_spinBox_serial__valueChanged(serialString.right(5));

    QString serialString2 = fileToStringList[1];
    if(!serialString2.contains("serial2")) {
        QMessageBox::information(this, "", tr("Отсутствует параментр: serial2"));
        return;
    }
    serialString2.remove("\nserial2 ");
 //   ui->lineEdit_serial_2->setText(serialString2.left(3));
    ui->spinBox_serial_2->setValue(serialString2.right(5).toInt());
    on_spinBox_serial_2_valueChanged(serialString2.right(5));

    QString serialString3 = fileToStringList[2];
    if(!serialString3.contains("serial3 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параментр: serial3"));
        return;
    }
    serialString3.remove("\nserial3 ");
 //   ui->lineEdit_serial_3->setText(serialString3.left(3));
    ui->spinBox_serial_3->setValue(serialString3.right(5).toInt());
    on_spinBox_serial_3_valueChanged(serialString3.right(5));

    QString serialString4 = fileToStringList[3];
    if(!serialString4.contains("serial4 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параментр: serial4"));
        return;
    }
    serialString4.remove("\nserial4 ");
  //  ui->lineEdit_serial_4->setText(serialString4.left(3));
    ui->spinBox_serial_4->setValue(serialString4.right(5).toInt());
    on_spinBox_serial_4_valueChanged(serialString4.right(5));

    //
    QString ManCodeString = fileToStringList[4];
    if(!ManCodeString.contains("ManCode ")) {
        QMessageBox::information(this, "", tr("Отсутствует параментр: ManCode"));
        return;
    }
    ManCodeString.remove("\nManCode ");
    if(manCodeList.contains(ManCodeString)) {
       ui->comboBox_ManCode->setCurrentText(ManCodeString);
    }
    else {
        QMessageBox::information(this, "", tr("Неверное значение ManCode: ") + ManCodeString);
    }
    //
    QString DevTypeString = fileToStringList[5];
    if(!DevTypeString.contains("DevType ")) {
        QMessageBox::information(this, "", tr("Отсутствует параментр: DevType"));
        return;
    }
    DevTypeString.remove("\nDevType ");
    if(devTypeList.contains(DevTypeString)) {
       ui->comboBox_DevType->setCurrentText(DevTypeString);
    }
    else {
        QMessageBox::information(this, "", tr("Неверное значение DevType: ") + DevTypeString);
    }
    //
    QString DNString = fileToStringList[6];
    if(!DNString.contains("DN ")) {
        QMessageBox::information(this, "", tr("Отсутствует параментр: DN"));
        return;
    }
    DNString.remove("\nDN ");
    if(DNList.contains(DNString)) {
       ui->comboBox_DN->setCurrentText(DNString);
    }
    else {
        QMessageBox::information(this, "", tr("Неверное значение DN: ") + DNString);
    }

    //
//    QString PCB_SNString = fileToStringList[7];
//    PCB_SNString.remove("\nPCB_SN ");
//    ui->lineEdit_PCB_SN->setText(PCB_SNString);

//    QString PCB_SNString2 = fileToStringList[8];
//    PCB_SNString2.remove("\nPCB_SN2 ");
//    ui->lineEdit_PCB_SN->setText(PCB_SNString);

//    QString PCB_SNString = fileToStringList[9];
//    PCB_SNString.remove("\nPCB_SN ");
//    ui->lineEdit_PCB_SN->setText(PCB_SNString);

//    QString PCB_SNString = fileToStringList[10];
//    PCB_SNString.remove("\nPCB_SN ");
//    ui->lineEdit_PCB_SN->setText(PCB_SNString);

    //
    QString Flow_minString = fileToStringList[11];
    if(!Flow_minString.contains("Flow_min ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Flow_min"));
        return;
    }
    Flow_minString.remove("\nFlow_min ");
    ui->lineEdit_Flow_min->setText(Flow_minString);

    //
    QString Flow_maxString = fileToStringList[12];
    if(!Flow_maxString.contains("Flow_max ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Flow_max"));
        return;
    }
    Flow_maxString.remove("\nFlow_max ");
    ui->lineEdit_Flow_max->setText(Flow_maxString);

    //
    QString Tin_minString = fileToStringList[13];
    if(!Tin_minString.contains("Tin_min ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Tin_min"));
        return;
    }
    Tin_minString.remove("\nTin_min ");
    ui->spinBox_Tin_min->setValue(Tin_minString.toInt());

    //
    QString Tin_maxString = fileToStringList[14];
    if(!Tin_maxString.contains("Tin_max ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Tin_max"));
        return;
    }
    Tin_maxString.remove("\nTin_max ");
    ui->spinBox_Tin_max->setValue(Tin_maxString.toInt());

    //
    QString Tout_minString = fileToStringList[15];
    if(!Tout_minString.contains("Tout_min ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Tout_min"));
        return;
    }
    Tout_minString.remove("\nTout_min ");
    ui->spinBox_Tout_min->setValue(Tout_minString.toInt());

    //
    QString Tout_maxString = fileToStringList[16];
    if(!Tout_maxString.contains("Tout_max ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Tout_max"));
        return;
    }
    Tout_maxString.remove("\nTout_max ");
    ui->spinBox_Tout_max->setValue(Tout_maxString.toInt());

    //
    QString ReportDataString = fileToStringList[17];
    if(!ReportDataString.contains("ReportData ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: ReportData"));
        return;
    }
    ReportDataString.remove("\nReportData ");
    ui->spinBox_ReportData->setValue(ReportDataString.toInt());

    //
    QString Average_TString = fileToStringList[18];
    if(!Average_TString.contains("Average_T ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Average_T"));
        return;
    }
    Average_TString.remove("\nAverage_T ");
    if(AverageTList.contains(Average_TString)) {
       ui->comboBox_Average_T->setCurrentText(Average_TString);
    }
    else {
        QMessageBox::information(this, "", tr("Неверное значение Average_TS: ") + Average_TString);
    }
    //
    QString PulsesMode1String = fileToStringList[19];
    if(!PulsesMode1String.contains("PulsesMode1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: PulsesMode1"));
        return;
    }
    PulsesMode1String.remove("\nPulsesMode1 ");
    if(pulsesMode1List.contains(PulsesMode1String)) {
       ui->comboBox_PulsesMode1->setCurrentText(PulsesMode1String);
       pulsesMode1PrimalInt = PulsesMode1String.toInt();
       paramsMapToThreads["pulsesMode1PrimalInt"] = pulsesMode1PrimalInt;
    }
    else {
        QMessageBox::information(this, "", tr("Неверное значение PulsesMode1: ") + PulsesMode1String);
    }
    //

    QString PulsesMode2String = fileToStringList[20];
    if(!PulsesMode2String.contains("PulsesMode2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: PulsesMode2"));
        return;
    }
    PulsesMode2String.remove("\nPulsesMode2 ");
    if(pulsesMode1List.contains(PulsesMode2String)) {
       ui->comboBox_PulsesMode2->setCurrentText(PulsesMode2String);
       pulsesMode2PrimalInt = PulsesMode2String.toInt();
       paramsMapToThreads["pulsesMode2PrimalInt"] = pulsesMode2PrimalInt;
    }
    else {
        QMessageBox::information(this, "", tr("Неверное значение PulsesMode2: ") + PulsesMode2String);
    }
    //

    QString PulsesValue1String = fileToStringList[21];
    if(!PulsesValue1String.contains("PulsesValue1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: PulsesValue1"));
        return;
    }
    PulsesValue1String.remove("\nPulsesValue1 ");
    pulsesValue1PrimeInt = PulsesValue1String.toInt();
    paramsMapToThreads["pulsesValue1PrimeInt"] = pulsesValue1PrimeInt;

    ui->lineEdit_PulsesValue1->setText(PulsesValue1String);
    //

    QString PulsesValue2String = fileToStringList[22];
    if(!PulsesValue2String.contains("PulsesValue2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: PulsesValue2"));
        return;
    }
    PulsesValue2String.remove("\nPulsesValue2 ");
    pulsesValue2PrimeInt = PulsesValue2String.toInt();
    paramsMapToThreads["pulsesValue2PrimeInt"] = pulsesValue2PrimeInt;

    ui->lineEdit_PulsesValue2->setText(PulsesValue2String);
    //

    QString FlowRateString = fileToStringList[23];
    if(!FlowRateString.contains("FlowRate ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: FlowRate"));
        return;
    }
    FlowRateString.remove("\nFlowRate ");
    if(flowRateList.contains(FlowRateString)) {
       ui->comboBox_FlowRate->setCurrentText(FlowRateString);
    }
    else {
        QMessageBox::information(this, "", tr("Неверное значение FlowRate: ") + FlowRateString);
    }
    //

    QString PressureString = fileToStringList[24];
    if(!PressureString.contains("Pressure ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Pressure"));
        return;
    }
    PressureString.remove("\nPressure ");
    ui->lineEdit_Pressure->setText(PressureString);
    //

    QString RTD_TypeString = fileToStringList[25];
    if(!RTD_TypeString.contains("RTD_Type ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: RTD_Type"));
        return;
    }
    RTD_TypeString.remove("\nRTD_Type ");
    if(RTD_TypeList.contains(RTD_TypeString)) {
       ui->comboBox_RTD_Type->setCurrentText(RTD_TypeString);
    }
    else {
        QMessageBox::information(this, "", tr("Неверное значение RTD_Type: ") + RTD_TypeString);
    }
    //

    QString R_RTDString = fileToStringList[26];
    if(!R_RTDString.contains("R_RTD ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: R_RTD"));
        return;
    }
    R_RTDString.remove("\nR_RTD ");
    ui->lineEdit_R_RTD->setText(R_RTDString);
    //

    QString RWire1String = fileToStringList[27];
    if(!RWire1String.contains("RWire1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: RWire1"));
        return;
    }
    RWire1String.remove("\nRWire1 ");
    ui->lineEdit_RWire1->setText(RWire1String);
    //

    QString RWire2String = fileToStringList[28];
    if(!RWire2String.contains("RWire2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: RWire2"));
        return;
    }
    RWire2String.remove("\nRWire2 ");
    ui->lineEdit_RWire2->setText(RWire2String);
    //

    QString FlowNomString = fileToStringList[29];
    if(!FlowNomString.contains("FlowNom ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: FlowNom"));
        return;
    }
    FlowNomString.remove("\nFlowNom ");
    if(flowNomList.contains(FlowNomString)) {
       ui->comboBox_FlowNom->setCurrentText(FlowNomString);
    }
    else {
        QMessageBox::information(this, "", tr("Неверное значение FlowNom: ") + FlowNomString);
    }

    //
    QString FlCoeff0String = fileToStringList[30];
    if(!FlCoeff0String.contains("FlCoeff0 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: FlCoeff0"));
        return;
    }
    FlCoeff0String.remove("\nFlCoeff0 ");
    ui->lineEdit_coef0->setText(FlCoeff0String);

    //
    QString FlCoeff1String = fileToStringList[31];
    if(!FlCoeff1String.contains("FlCoeff1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: FlCoeff1"));
        return;
    }
    FlCoeff1String.remove("\nFlCoeff1 ");
    ui->lineEdit_coef1->setText(FlCoeff1String);

    //
    QString FlCoeff2String = fileToStringList[32];
    if(!FlCoeff2String.contains("FlCoeff2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: FlCoeff2"));
        return;
    }
    FlCoeff2String.remove("\nFlCoeff2 ");
    ui->lineEdit_coef2->setText(FlCoeff2String);

    //
    QString FlCoeff3String = fileToStringList[33];
    if(!FlCoeff3String.contains("FlCoeff3 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: FlCoeff3"));
        return;
    }
    FlCoeff3String.remove("\nFlCoeff3 ");
    ui->lineEdit_coef3->setText(FlCoeff3String);

    //
    QString FlCoeff4String = fileToStringList[34];
    if(!FlCoeff4String.contains("FlCoeff4 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: FlCoeff4"));
        return;
    }
    FlCoeff4String.remove("\nFlCoeff4 ");
    ui->lineEdit_coef4->setText(FlCoeff4String);

    //
    QString FlCoeff5String = fileToStringList[35];
    if(!FlCoeff5String.contains("FlCoeff5 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: FlCoeff5"));
        return;
    }
    FlCoeff5String.remove("\nFlCoeff5 ");
    ui->lineEdit_coef5->setText(FlCoeff5String);

    //
    QString FS_DiffThrsString = fileToStringList[36];
    if(!FS_DiffThrsString.contains("FS_DiffThrs ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: FS_DiffThrs"));
        return;
    }
    FS_DiffThrsString.remove("\nFS_DiffThrs ");
    ui->lineEdit_FS_DiffThrs->setText(FS_DiffThrsString);

    //
    QString DateTime_RealClockString = fileToStringList[37];
    if(!DateTime_RealClockString.contains("DateTime_RealClock ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: DateTime_RealClock"));
        return;
    }
    DateTime_RealClockString.remove("\nDateTime_RealClock ");
    QDateTime dateTimeFromFile = QDateTime::fromString(DateTime_RealClockString, "dd.MM.yyyy hh:mm:ss");
    ui->dateTimeEdit_realClock->setDateTime(dateTimeFromFile);

    //
    QString ASW_flagString = fileToStringList[38];
    if(!ASW_flagString.contains("ASW_flag ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: ASW_flag"));
        return;
    }
    ASW_flagString.remove("\nASW_flag ");
    if(ASW_flagList.contains(ASW_flagString)) {
       ui->comboBox_ASW_flag->setCurrentText(ASW_flagString);
    }
    else {
        QMessageBox::information(this, "", tr("Неверное значение ASW_flag: ") + ASW_flagString);
    }
    //

    QString Shift_T1String = fileToStringList[39];
    if(!Shift_T1String.contains("Shift_T1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Shift_T1"));
        return;
    }
    Shift_T1String.remove("\nShift_T1 ");
    ui->lineEdit_Shift_T1->setText(Shift_T1String);

    //
    QString Shift_T2String = fileToStringList[40];
    if(!Shift_T2String.contains("Shift_T2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Shift_T2"));
        return;
    }
    Shift_T2String.remove("\nShift_T2 ");
    ui->lineEdit_Shift_T2->setText(Shift_T2String);

    //
    QString Scale_T1String = fileToStringList[41];
    if(!Scale_T1String.contains("Scale_T1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Scale_T1"));
        return;
    }
    Scale_T1String.remove("\nScale_T1 ");
    ui->lineEdit_Scale_T1->setText(Scale_T1String);

    //
    QString Scale_T2String = fileToStringList[42];
    if(!Scale_T2String.contains("Scale_T2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Scale_T2"));
        return;
    }
    Scale_T2String.remove("\nScale_T2 ");
    ui->lineEdit_Scale_T2->setText(Scale_T2String);

    //
    QString PrimAddrString = fileToStringList[43];
    if(!PrimAddrString.contains("PrimAddr ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: PrimAddr"));
        return;
    }
    PrimAddrString.remove("\nPrimAddr ");
    ui->spinBox_Addr->setValue(PrimAddrString.toInt());

    //
    QString BaudRateString = fileToStringList[44];
    if(!BaudRateString.contains("BaudRate ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: BaudRate"));
        return;
    }
    BaudRateString.remove("\nBaudRate ");
    if(BaudRateList.contains(BaudRateString)) {
       ui->comboBox_BaudRate->setCurrentText(BaudRateString);
    }
    else {
        QMessageBox::information(this, "", tr("Неверное значение BaudRate: ") + BaudRateString);
    }
    //

    QString HMP_TransString = fileToStringList[45];
    if(!HMP_TransString.contains("HMP_Trans ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: HMP_Trans"));
        return;
    }
    HMP_TransString.remove("\nHMP_Trans ");
    ui->lineEdit_HMP_Trans->setText(HMP_TransString);

    //
    QString EPP_TransString = fileToStringList[46];
    if(!EPP_TransString.contains("EPP_Trans ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: EPP_Trans"));
        return;
    }
    EPP_TransString.remove("\nEPP_Trans ");
    ui->lineEdit_EPP_Trans->setText(EPP_TransString);

    //
    QString P1PrimAddrString = fileToStringList[47];
    if(!P1PrimAddrString.contains("P1PrimAddr ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: P1PrimAddr"));
        return;
    }
    P1PrimAddrString.remove("\nP1PrimAddr ");
    ui->spinBox_P1PrimAddr->setValue(P1PrimAddrString.toInt());

    //
    QString P2PrimAddrString = fileToStringList[48];
    if(!P2PrimAddrString.contains("P2PrimAddr ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: P2PrimAddr"));
        return;
    }
    P2PrimAddrString.remove("\nP2PrimAddr ");
    ui->spinBox_P2PrimAddr->setValue(P2PrimAddrString.toInt());

    //
    QString ProtTypeString = fileToStringList[49];
    if(!ProtTypeString.contains("ProtType ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: ProtType"));
        return;
    }
    ProtTypeString.remove("\nProtType ");
    ui->lineEdit_ProtType->setText(ProtTypeString);

    //
    QString Serial_P1String = fileToStringList[50];
    if(!Serial_P1String.contains("Serial_P1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Serial_P1"));
        return;
    }
    Serial_P1String.remove("\nSerial_P1 ");
    ui->lineEdit_Serial_P1->setText(Serial_P1String);

    //
    QString ManCode_P1String = fileToStringList[51];
    if(!ManCode_P1String.contains("ManCode_P1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: ManCode_P1"));
        return;
    }
    ManCode_P1String.remove("\nManCode_P1 ");
    ui->lineEdit_ManCode_P1->setText(ManCode_P1String);

    //
    QString DevType_P1String = fileToStringList[52];
    if(!DevType_P1String.contains("DevType_P1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: DevType_P1"));
        return;
    }
    DevType_P1String.remove("\nDevType_P1 ");
    ui->lineEdit_DevType_P1->setText(DevType_P1String);

    //
    QString Version_P1String = fileToStringList[53];
    if(!Version_P1String.contains("Version_P1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Version_P1"));
        return;
    }
    Version_P1String.remove("\nVersion_P1 ");
    ui->lineEdit_Version_P1->setText(Version_P1String);

    //
    QString Initial_value_P1String = fileToStringList[54];
    if(!Initial_value_P1String.contains("Initial_value_P1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Initial_value_P1"));
        return;
    }
    Initial_value_P1String.remove("\nInitial_value_P1 ");
    ui->lineEdit_Initial_value_P1->setText(Initial_value_P1String);

    //
    QString Service_P1String = fileToStringList[55];
    if(!Service_P1String.contains("Service_P1 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Service_P1"));
        return;
    }
    Service_P1String.remove("\nService_P1 ");
    ui->lineEdit_Service_P1->setText(Service_P1String);

    //
    QString Serial_P2String = fileToStringList[56];
    if(!Serial_P2String.contains("Serial_P2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Serial_P2"));
        return;
    }
    Serial_P2String.remove("\nSerial_P2 ");
    ui->lineEdit_Serial_P2->setText(Serial_P2String);

    //
    QString ManCode_P2String = fileToStringList[57];
    if(!ManCode_P2String.contains("ManCode_P2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: ManCode_P2"));
        return;
    }
    ManCode_P2String.remove("\nManCode_P2 ");
    ui->lineEdit_ManCode_P2->setText(ManCode_P2String);
    //
    QString DevType_P2String = fileToStringList[58];
    if(!DevType_P2String.contains("DevType_P2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: DevType_P2"));
        return;
    }
    DevType_P2String.remove("\nDevType_P2 ");
    ui->lineEdit_DevType_P2->setText(DevType_P2String);

    //
    QString Version_P2String = fileToStringList[59];
    if(!Version_P2String.contains("Version_P2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Version_P2"));
        return;
    }
    Version_P2String.remove("\nVersion_P2 ");
    ui->lineEdit_Version_P2->setText(Version_P2String);

    //
    QString Initial_value_P2String = fileToStringList[60];
    if(!Initial_value_P2String.contains("Initial_value_P2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Initial_value_P2"));
        return;
    }
    Initial_value_P2String.remove("\nInitial_value_P2 ");
    ui->lineEdit_Initial_value_P2->setText(Initial_value_P2String);

    //
    QString Service_P2String = fileToStringList[61];
    if(!Service_P2String.contains("Service_P2 ")) {
        QMessageBox::information(this, "", tr("Отсутствует параметр: Service_P2"));
        return;
    }
    Service_P2String.remove("\nService_P2 ");
    ui->lineEdit_Service_P2->setText(Service_P2String);


}
/*************************************************************/
void MainWindow::on_lineEdit_sendCommandOptical_textChanged(const QString &arg1)
{
    packetFromLineEdit.clear();

    QString strArg = arg1;
    QByteArray byteArrayArg;
    bool ok;
    if(strArg.length()%2 == 0) {
       for(int i=0; i<strArg.length(); i=i+2) {
           QString byteStr = strArg[i] + "" + strArg[i+1];
           byteArrayArg.append(byteStr.toInt(&ok, 16));
       }

       packetFromLineEdit = byteArrayArg;
       quint8 crc = makeCRC(packetFromLineEdit);
       packetFromLineEdit.append(crc);
    }

    qDebug()<<"byteArrayArg.toHex() "<<byteArrayArg.toHex();


}
/*************************************************************/
void MainWindow::on_toolButton_readParams_clicked()
{
    //   readFromCounter();

    paramsVector.clear();

       QByteArray buffer;

       if(!portOptical->isOpen()) {
           if(!portOptical->open(QIODevice::ReadWrite)) {
               QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
               return;
           }
       }


       //
       //Set Password Default
//       for(int i=0; i<3;i++) {

//          portOptical->clear();
//          packetToRead.clear();
//          buffer.clear();
//          quint8 byte = 0x5a;
//          packetToRead.append(byte);
//          byte = 0x00;
//          packetToRead.append(byte);
//          byte = 0x05;
//          packetToRead.append(byte);
//          byte = 0x1b;
//          packetToRead.append(byte);
//          quint8 crc = makeCRC(packetToRead);
//          packetToRead.append(crc);

//          quint64 cnt = portOptical->write(packetToRead);

//          qDebug()<<"cnt "<<cnt
//                  <<"packetToRead.toHex() "<<packetToRead.toHex()
//                  <<"portOptical->portName() "<<portOptical->portName();

//          if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

//          global::pause(200);

//          buffer = portOptical->readAll();
//          qDebug()<<"buffer.toHex()"<<buffer.toHex();
//          ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

//          if(buffer.isEmpty()) {
//              if(i==2) {
//                  QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
//                  return;
//              } else{}

//          }
//          else {
//              //проверяем crc и первые четыре байта ответного пакета
//              QByteArray bytesForChecking;
//              quint8 byte = 0x5a;
//              bytesForChecking.append(byte);
//              byte = 0x00;
//              bytesForChecking.append(byte);
//              byte = 0x07;
//              bytesForChecking.append(byte);
//              byte = 0x9b;
//              bytesForChecking.append(byte);

//              if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
//                                          bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

//                 qDebug()<<"buffer.toHex() "<<buffer.toHex()
//                      <<"checkCRC(buffer) "<<checkCRC(buffer);
//                 ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

//                 //
//                 //Addr
//                 QByteArray AddrArray;
//                 AddrArray.append(buffer[4]);
//                 qDebug()<<"AddrArray.toHex() "<<AddrArray.toHex();

//                 quint8 AddrQuint8 = buffer[4];

//                 if(AddrQuint8>=0 && AddrQuint8<=252) {
//                     ui->spinBox_Addr->setValue(AddrQuint8);
//                 }
//                 else {
//                     QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес счётчика"));
//                     ui->spinBox_Addr->setValue(AddrQuint8);
//                 }

//                 //
//                 //BaudRate
//                 QByteArray BaudRateArray;
//                 BaudRateArray.append(buffer[5]);
//                 qDebug()<<"BaudRateArray.toHex() "<<BaudRateArray.toHex();

//                 quint8 BaudRateQuint8 = buffer[5];

//                 if(BaudRateList.contains(QString::number(BaudRateQuint8, 16))) {
//                     ui->comboBox_BaudRate->setCurrentText(QString::number(BaudRateQuint8, 16));
//                 }
//                 else {
//                     QMessageBox::information(this, "", tr("Недопустимое значение: Скорость обмена"));
//                     ui->comboBox_BaudRate->setCurrentText(QString::number(BaudRateQuint8, 16));
//                 }

//                 //
//                 //



//                 break;
//              }
//              else {
//                  QMessageBox::information(this, "", tr("Ошибка данных"));
//                  return;
//              }



//          }


//       }


       //Read Hardware Configuration 5a000501
   for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x01;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) {
           QMessageBox::information(this, "", tr("Данные в порт не записаны"));
           return;
       }

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex() "<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());


       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x26;
           bytesForChecking.append(byte);
           byte = 0x81;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);              

              emit sendbufferReadHardwareConfiguration(buffer, 0);

              //
              //serial
              QByteArray serialByteAray;
              serialByteAray.append(buffer[12]);
              serialByteAray.append(buffer[13]);
              serialByteAray.append(buffer[14]);
              serialByteAray.append(buffer[15]);
              ui->lineEdit_serial->setText(serialByteAray.toHex());
              qDebug()<<"serialByteAray.toHex() "<<serialByteAray.toHex();
              paramsVector.append(serialByteAray);
              mapRead["serialNumber"] = serialByteAray;

              //
              //ManCode
              QByteArray manCodeByteArray;
              manCodeByteArray.append(buffer[16]);
              manCodeByteArray.append(buffer[17]);
              int manufacturerSum = static_cast<quint8>(manCodeByteArray[0]);//manufacturer.toInt();
              manufacturerSum = (manufacturerSum<<8)|(static_cast<quint8>(manCodeByteArray[1]));
              quint8 symbol1, symbol2, symbol3;
              symbol1 = ((manufacturerSum/(32*32))&0x1F) + 64;
              symbol2 = ((manufacturerSum/32)&0x1F) + 64;
              symbol3 = (manufacturerSum&0x1F) + 64;
              QByteArray manufacturerString;
              manufacturerString[0] = symbol1;
              manufacturerString[1] = symbol2;
              manufacturerString[2] = symbol3;
              if(manCodeList.contains(QString::fromLatin1(manufacturerString))) {
                  ui->comboBox_ManCode->setCurrentText(QString::fromLatin1(manufacturerString));
              }
              else {
  //               QMessageBox::information(this, "", tr("Недопустимое значение: Производитель"));
              }
              qDebug()<<"QString::fromLatin1(manufacturerString)"<<QString::fromLatin1(manufacturerString);
              paramsVector.append(manCodeByteArray);
              mapRead["manCode"] = manCodeByteArray;

              //
              //DevType
              QByteArray devType;
              devType.append(buffer[18]);

              if(devType[0] == 0x04) {
                  ui->comboBox_DevType->setCurrentText("Обратный");
              }

              if(devType[0] == 0x0c) {
                  ui->comboBox_DevType->setCurrentText("Подающий");
              }

              if((devType[0] != 0x04) && (devType[0] != 0x0c) ) {
                  QMessageBox::information(this, "", tr("Недопустимое значение: Тип счётчика"));
              }

              qDebug()<<"devType.toHex() "<<devType.toHex();
              paramsVector.append(devType);
              mapRead["devType"] = devType;

              //
              //DN
              QByteArray DN;
              DN.append(buffer[19]);
              if(DNList.contains(QString::number((quint8)buffer[19], 16))) {
                  ui->comboBox_DN->setCurrentText(QString::number((quint8)buffer[19], 16));
              }
              else {
//                 QMessageBox::information(this, "", tr("Недопустимое значение: Диаметр условного прохода"));
              }
              qDebug()<<"DN.toHex() "<<DN.toHex();
              paramsVector.append(DN);
              mapRead["DN"] = DN;

              //
              //PCB_SN 8bytes (29-36)
              QByteArray PCB_SN_Array;
              PCB_SN_Array.append(buffer[29]);
              PCB_SN_Array.append(buffer[30]);
              PCB_SN_Array.append(buffer[31]);
              PCB_SN_Array.append(buffer[32]);
              PCB_SN_Array.append(buffer[33]);
              PCB_SN_Array.append(buffer[34]);
              PCB_SN_Array.append(buffer[35]);
              PCB_SN_Array.append(buffer[36]);

              PCB_SN_ByteArray.clear();
              PCB_SN_ByteArray = PCB_SN_Array;

              ui->lineEdit_PCB_SN->setText(PCB_SN_Array.toHex());
              qDebug()<<"PCB_SN_Array.toHex() "<<PCB_SN_Array.toHex();
              qDebug()<<"PCB_SN_ByteArray.toHex() "<<PCB_SN_ByteArray.toHex();
              paramsVector.append(PCB_SN_Array);
              mapRead["PCB_SN_ByteArray"] = PCB_SN_Array;


              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  return;
               }
           }

       }



    }
       //
       //
       //Read Software Configuration 5a000502
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x02;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x16;
           bytesForChecking.append(byte);
           byte = 0x82;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
//              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

              emit sendbufferReadSoftWareConfiguration(buffer);

              //
              //flowMin
              QByteArray flowMinArray;
              flowMinArray.append(buffer[4]);
              flowMinArray.append(buffer[5]);
 //             ui->lineEdit_Flow_min->setText(flowMinArray.toHex());

 //             float flowMinFloat = buffer[4];
              quint16 flowMinQuint16 = buffer[4];
              flowMinQuint16 = flowMinQuint16<<8 | buffer[5];
              float flowMinFloat = (float)flowMinQuint16/1000;
              if(flowMinFloat>=0 && flowMinFloat<=0.2) {
                  ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальный расход"));
                  ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
              }

              qDebug()<<"flowMinArray.toHex() "<<flowMinArray.toHex();
              paramsVector.append(flowMinArray);
              mapRead["flowMinByteArray"] = flowMinArray;

              //
              //flowMax
              QByteArray flowMaxArray;
              flowMaxArray.append(buffer[6]);
              flowMaxArray.append(buffer[7]);

 //             float flowMaxFloat = buffer[6];
              quint16 flowMaxQuint16 = buffer[6];
              flowMaxQuint16 = (flowMaxQuint16<<8) | (quint8)(buffer.at(7));
              float flowMaxFloat = flowMaxQuint16;
              flowMaxFloat = flowMaxFloat/1000;
              if(flowMaxFloat>=2 && flowMaxFloat<=5) {
                  ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальный расход"));
                  ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
              }

              qDebug()<<"flowMaxArray.toHex() "<<flowMaxArray.toHex();
              paramsVector.append(flowMaxArray);
              mapRead["flowMaxByteArray"] = flowMaxArray;

              //
              //tinMin
              QByteArray tinMinArray;
              tinMinArray.append(buffer[8]);


              quint8 tinMinQuint8 = buffer[8];
              if(tinMinQuint8>=10 && tinMinQuint8<=60) {
                  ui->spinBox_Tin_min->setValue(tinMinQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура подачи"));
              }

              qDebug()<<"tinMinArray.toHex() "<<tinMinArray.toHex();
              paramsVector.append(tinMinArray);
              mapRead["tinMinByteArray"] = tinMinArray;

              //
              //tinMax
              QByteArray tinMaxArray;
              tinMaxArray.append(buffer[9]);


              quint8 tinMaxQuint8 = buffer[9];
              if(tinMaxQuint8>=50 && tinMaxQuint8<=150) {
                  ui->spinBox_Tin_max->setValue(tinMaxQuint8);
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура подачи"));
              }

              qDebug()<<"tinMaxArray.toHex() "<<tinMaxArray.toHex();
              paramsVector.append(tinMaxArray);
              mapRead["tinMaxByteArray"] = tinMaxArray;

              //
              //toutMin
              QByteArray toutMinArray;
              toutMinArray.append(buffer[10]);

              quint8 toutMinQuint8 = buffer[10];
              if(toutMinQuint8>=10 && toutMinQuint8<=60) {
                  ui->spinBox_Tout_min->setValue(toutMinQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура обратки"));
              }

              qDebug()<<"toutMinArray.toHex() "<<toutMinArray.toHex();
              paramsVector.append(toutMinArray);
              mapRead["toutMinByteArray"] = toutMinArray;


              //
              //toutMax
              QByteArray toutMaxArray;
              toutMaxArray.append(buffer[11]);             

              quint8 toutMaxQuint8 = buffer[11];
              if(toutMaxQuint8>=50 && toutMaxQuint8<=150) {
                  ui->spinBox_Tout_max->setValue(toutMaxQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура обратки"));
              }

              qDebug()<<"toutMaxArray.toHex() "<<toutMaxArray.toHex();
              paramsVector.append(toutMaxArray);
              mapRead["toutMaxByteArray"] = toutMaxArray;

              //
              //reportData
              QByteArray reportDataArray;
              reportDataArray.append(buffer[12]);              

              quint8 reportDataInt = buffer[12];
              if(reportDataInt>=0 && reportDataInt<=31) {
                  ui->spinBox_ReportData->setValue(reportDataInt);
              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: Дата сохранения в журнал"));
              }

              qDebug()<<"reportDataArray.toHex() "<<reportDataArray.toHex();
              paramsVector.append(reportDataArray);
              mapRead["reportDataByteArray"] = reportDataArray;

              //
              //AverageT
              QByteArray AverageTArray;
              AverageTArray.append(buffer[13]);


              quint8 AverageTInt = buffer[13];
              if(AverageTList.contains(QString::number(AverageTInt))) {
                  ui->comboBox_Average_T->setCurrentText(QString::number(AverageTInt));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Тип усреднения температуры"));
              }

              qDebug()<<"AverageTArray.toHex() "<<AverageTArray.toHex();
              paramsVector.append(AverageTArray);
              mapRead["averageTByteArray"] = AverageTArray;

              //
              //pulsesMode1
              QByteArray pulsesMode1Array;
              pulsesMode1Array.append(buffer[14]);


              quint8 pulsesMode1Int = (quint8)buffer[14];
              if(pulsesMode1List.contains(QString::number(pulsesMode1Int))) {
                  ui->comboBox_PulsesMode1->setCurrentText(QString::number(pulsesMode1Int));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
              }

              qDebug()<<"pulsesMode1Array.toHex() "<<pulsesMode1Array.toHex();
              paramsVector.append(pulsesMode1Array);
              mapRead["pulsesMode1ByteArray"] = pulsesMode1Array;

              //
              //pulsesMode2
              QByteArray pulsesMode2Array;
              pulsesMode2Array.append(buffer[15]);


              quint8 pulsesMode2Int = (quint8)buffer[15];
              if(pulsesMode1List.contains(QString::number(pulsesMode2Int))) {
                  ui->comboBox_PulsesMode2->setCurrentText(QString::number(pulsesMode2Int));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
              }

              qDebug()<<"pulsesMode2Array.toHex() "<<pulsesMode2Array.toHex();
              paramsVector.append(pulsesMode2Array);
              mapRead["pulsesMode2ByteArray"] = pulsesMode2Array;

              //
              //pulsesValue1
              QByteArray pulsesValue1Array;
              pulsesValue1Array.append(buffer[16]);
              pulsesValue1Array.append(buffer[17]);


              quint16 pulsesValue1Int = buffer[16];
              pulsesValue1Int = pulsesValue1Int<<8 | (quint8)buffer[17];
//              if((pulsesValue1Int<=101) && (pulsesValue1Int>=99)) {

//              }
              ui->lineEdit_PulsesValue1->setText(QString::number(pulsesValue1Int));

              qDebug()<<"pulsesValue1Array.toHex() "<<pulsesValue1Array.toHex();
              paramsVector.append(pulsesValue1Array);
              mapRead["pulsesValue1ByteArray"] = pulsesValue1Array;

              //
              //pulsesValue2
              QByteArray pulsesValue2Array;
              pulsesValue2Array.append(buffer[18]);
              pulsesValue2Array.append(buffer[19]);
              qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();

              quint16 pulsesValue2Int = buffer[18];
              pulsesValue2Int = pulsesValue2Int<<8 | (quint8)buffer[19];
              ui->lineEdit_PulsesValue2->setText(QString::number(pulsesValue2Int));

              qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();
              paramsVector.append(pulsesValue2Array);
              mapRead["pulsesValue2ByteArray"] = pulsesValue2Array;

              //
              //DevType
              QByteArray devType;
              devType.append(buffer[20]);

              if(devType[0] == 0x04) {
                  ui->comboBox_DevType->setCurrentText("Обратный");
              }

              if(devType[0] == 0x0c) {
                  ui->comboBox_DevType->setCurrentText("Подающий");
              }

              if((devType[0] != 0x04) && (devType[0] != 0x0c) ) {
                  QMessageBox::information(this, "", tr("Недопустимое значение: Тип счётчика"));
              }

              qDebug()<<"devType.toHex() "<<devType.toHex();
              paramsVector.append(devType);
              mapRead["devType"] = devType;




              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  return;
               }
           }

       }


    }

       //
       //
       //Read Sensor Parameters      5a00050b
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x0b;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x18;
           bytesForChecking.append(byte);
           byte = 0x8b;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
//              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

              emit sendbufferReadSensorParameters(buffer);

              //
              //flowRate 4 bytes (4-7)
              QByteArray flowRateArray;
              flowRateArray.append(buffer[4]);
              flowRateArray.append(buffer[5]);
              flowRateArray.append(buffer[6]);
              flowRateArray.append(buffer[7]);


              quint32 flowRateQuint32 = buffer[4];
              flowRateQuint32 = flowRateQuint32<<8 | (quint8)buffer[5];
              flowRateQuint32 = flowRateQuint32<<8 | (quint8)buffer[6];
              flowRateQuint32 = flowRateQuint32<<8 | (quint8)buffer[7];
              float flowRateFloat = (float)flowRateQuint32/1000;
              QString flowRateString = QString::number(flowRateFloat);
              if((flowRateFloat - round(flowRateFloat)) == 0 ) { //проверка на отсутствие дробной части
                  flowRateString = flowRateString + ".00";
              }

              if(flowRateList.contains(flowRateString)) {
                  ui->comboBox_FlowRate->setCurrentText(QString::number(flowRateFloat));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Вес импульса вертушки"));
 //                 ui->comboBox_FlowRate->setCurrentText(QString::number(flowRateFloat));
              }

              qDebug()<<"flowRateArray.toHex() "<<flowRateArray.toHex();
              paramsVector.append(flowRateArray);
              mapRead["flowRateByteArray"] = flowRateArray;

              //
              //pressure 1 byte (8)
              QByteArray pressureArray;
              pressureArray.append(buffer[8]);

              quint8 pressureQuint8 = buffer[8];
              if(pressureQuint8 == 6) {
                  ui->lineEdit_Pressure->setText(QString::number(pressureQuint8));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Условное давление"));
                  ui->lineEdit_Pressure->setText(QString::number(pressureQuint8));
              }

              qDebug()<<"pressureArray.toHex() "<<pressureArray.toHex();
              paramsVector.append(pressureArray);
              mapRead["pressureByteArray"] = pressureArray;

              //
              //RTD_Type 1 byte (9)
              QByteArray RTD_TypeArray;
              RTD_TypeArray.append(buffer[9]);

              quint8 RTD_TypeQuint8 = buffer[9];
              if((RTD_TypeQuint8 >= 0) && (RTD_TypeQuint8 <= (RTD_TypeList.count() - 1))) {
                  ui->comboBox_RTD_Type->setCurrentIndex(RTD_TypeQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Тип термометров сопротивления"));
 //                 ui->comboBox_RTD_Type->setCurrentText(QString::number(RTD_TypeQuint8));
              }

              qDebug()<<"RTD_TypeArray.toHex() "<<RTD_TypeArray.toHex();
              paramsVector.append(RTD_TypeArray);
              mapRead["RTD_TypeByteArray"] = RTD_TypeArray;


              //
              //R_RTD 4 bytes (10-13)
              QByteArray R_RTDArray;
              R_RTDArray.append(buffer[10]);
              R_RTDArray.append(buffer[11]);
              R_RTDArray.append(buffer[12]);
              R_RTDArray.append(buffer[13]);


              quint32 R_RTDQuint32 = (quint8)buffer[10];
              R_RTDQuint32 = R_RTDQuint32<<8 | (quint8)buffer[11];
              R_RTDQuint32 = R_RTDQuint32<<8 | (quint8)buffer[12];
              R_RTDQuint32 = R_RTDQuint32<<8 | (quint8)buffer[13];

              if(R_RTDQuint32 == 1000) {
                  ui->lineEdit_R_RTD->setText(QString::number(R_RTDQuint32));
              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: Номинальное сопротивление термометров") + QString::number(R_RTDQuint32));
              }

              qDebug()<<"R_RTDArray.toHex() "<<R_RTDArray.toHex();
              paramsVector.append(R_RTDArray);
              mapRead["R_RTDByteArray"] = R_RTDArray;

              //
              //RWire1 4 bytes (14-17)
              QByteArray RWire1Array;
              RWire1Array.append(buffer[14]);
              RWire1Array.append(buffer[15]);
              RWire1Array.append(buffer[16]);
              RWire1Array.append(buffer[17]);


              quint32 RWire1Quint8 = buffer[14];
              RWire1Quint8 = RWire1Quint8<<8 | (quint8)buffer[15];
              RWire1Quint8 = RWire1Quint8<<8 | (quint8)buffer[16];
              RWire1Quint8 = RWire1Quint8<<8 | (quint8)buffer[17];

              if(RWire1Quint8 == 0) {
                  ui->lineEdit_RWire1->setText(QString::number(RWire1Quint8));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Сопротивление проводов термомнтров сопротивления"));
              }

              qDebug()<<"RWire1Array.toHex() "<<RWire1Array.toHex();
              paramsVector.append(RWire1Array);
              mapRead["RWire1ByteArray"] = RWire1Array;

              //
              //RWire2 4 bytes (18-21)
              QByteArray RWire2Array;
              RWire2Array.append(buffer[18]);
              RWire2Array.append(buffer[19]);
              RWire2Array.append(buffer[20]);
              RWire2Array.append(buffer[21]);


              quint32 RWire2Quint8 = buffer[18];
              RWire2Quint8 = RWire2Quint8<<8 | (quint8)buffer[19];
              RWire2Quint8 = RWire2Quint8<<8 | (quint8)buffer[20];
              RWire2Quint8 = RWire2Quint8<<8 | (quint8)buffer[21];

              if(RWire2Quint8 == 0) {
                  ui->lineEdit_RWire2->setText(QString::number(RWire2Quint8));
              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: Сопротивление проводов термомнтров сопротивления"));
              }

              qDebug()<<"RWire2Array.toHex() "<<RWire2Array.toHex();
              paramsVector.append(RWire2Array);
              mapRead["RWire2ByteArray"] = RWire2Array;

              //
              //flowNom 1 byte (22)
              QByteArray flowNomArray;
              flowNomArray.append(buffer[22]);


              quint8 flowNomInt = buffer[22];
              float flowNomFloat = (float)flowNomInt/10;
              if(flowNomList.contains(QString::number(flowNomFloat))) {
                  ui->comboBox_FlowNom->setCurrentText(QString::number(flowNomFloat));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Номинальный расход"));
              }

              qDebug()<<"flowNomArray.toHex() "<<flowNomArray.toHex();
              paramsVector.append(flowNomArray);
              mapRead["flowNomByteArray"] = flowNomArray;



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  return;
               }
           }

       }


    }

//    //
//    //
//    //Read Flow Coefficient  5a 00 05 1d

    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x1d;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x1d;
           bytesForChecking.append(byte);
           byte = 0x9d;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
 //             ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

              emit sendbufferReadFlowCoefficient(buffer);

              //
              //flowCoef0 4 bytes (4-7)
              QByteArray flowCoef0Array;
              flowCoef0Array.append(buffer[4]);
              flowCoef0Array.append(buffer[5]);
              flowCoef0Array.append(buffer[6]);
              flowCoef0Array.append(buffer[7]);


              quint32 flowCoef0Quint32 = (quint8)buffer[4];
              flowCoef0Quint32 = flowCoef0Quint32<<8 | (quint8)buffer[5];
              flowCoef0Quint32 = flowCoef0Quint32<<8 | (quint8)buffer[6];
              flowCoef0Quint32 = flowCoef0Quint32<<8 | (quint8)buffer[7];
              float flowCoef0Float = (float)flowCoef0Quint32/1000000;
              if(flowCoef0Float == 1) {
                  ui->lineEdit_coef0->setText(QString::number(flowCoef0Float, 'g', 6) + ".000000");
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 0"));
                  ui->lineEdit_coef0->setText(QString::number(flowCoef0Float));
              }

              qDebug()<<"flowCoef0Array.toHex() "<<flowCoef0Array.toHex();
              paramsVector.append(flowCoef0Array);
              mapRead["flowCoef0ByteArray"] = flowCoef0Array;

              //
              //flowCoef1 4 bytes (8-11)
              QByteArray flowCoef1Array;
              flowCoef1Array.append(buffer[8]);
              flowCoef1Array.append(buffer[9]);
              flowCoef1Array.append(buffer[10]);
              flowCoef1Array.append(buffer[11]);


              quint32 flowCoef1Quint32 = (quint8)buffer[8];
              flowCoef1Quint32 = flowCoef1Quint32<<8 | (quint8)buffer[9];
              flowCoef1Quint32 = flowCoef1Quint32<<8 | (quint8)buffer[10];
              flowCoef1Quint32 = flowCoef1Quint32<<8 | (quint8)buffer[11];
              float flowCoef1Float = (float)flowCoef1Quint32/1000000;
              if(flowCoef1Float == 1) {
                  ui->lineEdit_coef1->setText(QString::number(flowCoef1Float) + ".000000");
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 1"));
                  ui->lineEdit_coef1->setText(QString::number(flowCoef1Float));
              }

              qDebug()<<"flowCoef1Array.toHex() "<<flowCoef1Array.toHex();
              paramsVector.append(flowCoef1Array);
              mapRead["flowCoef1ByteArray"] = flowCoef1Array;


              //
              //flowCoef2 4 bytes (12-15)
              QByteArray flowCoef2Array;
              flowCoef2Array.append(buffer[12]);
              flowCoef2Array.append(buffer[13]);
              flowCoef2Array.append(buffer[14]);
              flowCoef2Array.append(buffer[15]);


              quint32 flowCoef2Quint32 = (quint8)buffer[12];
              flowCoef2Quint32 = flowCoef2Quint32<<8 | (quint8)buffer[13];
              flowCoef2Quint32 = flowCoef2Quint32<<8 | (quint8)buffer[14];
              flowCoef2Quint32 = flowCoef2Quint32<<8 | (quint8)buffer[15];
              float flowCoef2Float = (float)flowCoef2Quint32/1000000;
              if(flowCoef2Float == 1) {
                  ui->lineEdit_coef2->setText(QString::number(flowCoef2Float) + ".000000");
              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 2"));
                  ui->lineEdit_coef2->setText(QString::number(flowCoef2Float));
              }

              qDebug()<<"flowCoef2Array.toHex() "<<flowCoef2Array.toHex();
              paramsVector.append(flowCoef2Array);
              mapRead["flowCoef2ByteArray"] = flowCoef2Array;


              //
              //flowCoef3 4 bytes (16-19)
              QByteArray flowCoef3Array;
              flowCoef3Array.append(buffer[16]);
              flowCoef3Array.append(buffer[17]);
              flowCoef3Array.append(buffer[18]);
              flowCoef3Array.append(buffer[19]);


              quint32 flowCoef3Quint32 = (quint8)buffer[16];
              flowCoef3Quint32 = flowCoef3Quint32<<8 | (quint8)buffer[17];
              flowCoef3Quint32 = flowCoef3Quint32<<8 | (quint8)buffer[18];
              flowCoef3Quint32 = flowCoef3Quint32<<8 | (quint8)buffer[19];
              float flowCoef3Float = (float)flowCoef3Quint32/1000000;
              if(flowCoef3Float == 1) {
                  ui->lineEdit_coef3->setText(QString::number(flowCoef3Float) + ".000000");
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 3"));
                  ui->lineEdit_coef3->setText(QString::number(flowCoef3Float));
              }

              qDebug()<<"flowCoef3Array.toHex() "<<flowCoef3Array.toHex();
              paramsVector.append(flowCoef3Array);
              mapRead["flowCoef3ByteArray"] = flowCoef3Array;


              //
              //flowCoef4 4 bytes (20-23)
              QByteArray flowCoef4Array;
              flowCoef4Array.append(buffer[20]);
              flowCoef4Array.append(buffer[21]);
              flowCoef4Array.append(buffer[22]);
              flowCoef4Array.append(buffer[23]);


              quint32 flowCoef4Quint32 = (quint8)buffer[20];
              flowCoef4Quint32 = flowCoef4Quint32<<8 | (quint8)buffer[21];
              flowCoef4Quint32 = flowCoef4Quint32<<8 | (quint8)buffer[22];
              flowCoef4Quint32 = flowCoef4Quint32<<8 | (quint8)buffer[23];
              float flowCoef4Float = (float)flowCoef4Quint32/1000000;
              if(flowCoef4Float == 1) {
                  ui->lineEdit_coef4->setText(QString::number(flowCoef4Float) + ".000000");
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 4"));
                  ui->lineEdit_coef4->setText(QString::number(flowCoef4Float));
              }

              qDebug()<<"flowCoef4Array.toHex() "<<flowCoef4Array.toHex();
              paramsVector.append(flowCoef4Array);
              mapRead["flowCoef4ByteArray"] = flowCoef4Array;


              //
              //flowCoef5 4 bytes (24-27)
              QByteArray flowCoef5Array;
              flowCoef5Array.append(buffer[24]);
              flowCoef5Array.append(buffer[25]);
              flowCoef5Array.append(buffer[26]);
              flowCoef5Array.append(buffer[27]);


              quint32 flowCoef5Quint32 = (quint8)buffer[24];
              flowCoef5Quint32 = flowCoef5Quint32<<8 | (quint8)buffer[25];
              flowCoef5Quint32 = flowCoef5Quint32<<8 | (quint8)buffer[26];
              flowCoef5Quint32 = flowCoef5Quint32<<8 | (quint8)buffer[27];
              float flowCoef5Float = (float)flowCoef5Quint32/1000000;
              if(flowCoef5Float == 1) {
                  ui->lineEdit_coef5->setText(QString::number(flowCoef5Float) + ".000000");
              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 5"));
                  ui->lineEdit_coef5->setText(QString::number(flowCoef5Float));
              }

              qDebug()<<"flowCoef5Array.toHex() "<<flowCoef5Array.toHex();
              paramsVector.append(flowCoef5Array);
              mapRead["flowCoef5ByteArray"] = flowCoef5Array;





              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  return;
               }
           }

       }


    }


//    //
//    //Read Calibration Factor 5a 00 05 06
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x06;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x23;
           bytesForChecking.append(byte);
           byte = 0x86;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
//              ui->textBrowser->append("buffer.toHex()      " + buffer.toHex());

              emit sendbufferReadCalibrationFactor(buffer);

              //
              //FS_DiffThrs
              QByteArray FS_DiffThrsArray;
              FS_DiffThrsArray.append(buffer[8]);
              FS_DiffThrsArray.append(buffer[9]);


              quint16 FS_DiffThrsQuint16 = buffer[8];
              FS_DiffThrsQuint16 = FS_DiffThrsQuint16<<8 | buffer[9];

              if(FS_DiffThrsQuint16 == 30) {
                  ui->lineEdit_FS_DiffThrs->setText(QString::number(FS_DiffThrsQuint16));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Порог срабатывания датчика расхода "));
                  ui->lineEdit_FS_DiffThrs->setText(QString::number(FS_DiffThrsQuint16));
              }

              qDebug()<<"FS_DiffThrsArray.toHex() "<<FS_DiffThrsArray.toHex();
              paramsVector.append(FS_DiffThrsArray);
              mapRead["FS_DiffThrsByteArray"] = FS_DiffThrsArray;



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  return;
               }
           }

       }


    }

    //
    //Read Real Clock 5a 00 05 05
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x0e;
           bytesForChecking.append(byte);
           byte = 0x85;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
//              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

              emit sendbufferReadRealClock(buffer);

              //
              //Hour
              QDateTime dateTime_RealClock;
              QDate date_RealClock;
              QTime time_RealClock;

              QByteArray HourArray;
              HourArray.append(buffer[4]);


              quint8 HourQuint8 = buffer[4];

              if(HourQuint8>=0 && HourQuint8<=23) {
 //                 time_RealClock.
              }
              else {
                  QMessageBox::information(this, "", tr("Недопустимое значение: Часы"));
              }

              qDebug()<<"HourArray.toHex() "<<HourArray.toHex();
              paramsVector.append(HourArray);
              mapRead["hourByteArray"] = HourArray;

              //
              //Minute
              QByteArray MinuteArray;
              MinuteArray.append(buffer[5]);


              quint8 MinuteQuint8 = buffer[5];

              if(MinuteQuint8>=0 && MinuteQuint8<=59) {
 //                 time_RealClock.
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минуты"));
 //                 ui->lineEdit_FS_DiffThrs->setText(QString::number(FS_DiffThrsQuint16));
              }

              qDebug()<<"MinuteArray.toHex() "<<MinuteArray.toHex();
              paramsVector.append(MinuteArray);
              mapRead["minuteByteArray"] = MinuteArray;

              //
              //Second
              QByteArray SecondArray;
              SecondArray.append(buffer[6]);              

              quint8 SecondQuint8 = buffer[6];

              if(SecondQuint8>=0 && SecondQuint8<=59) {
 //                 time_RealClock.
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Секунды"));
 //                 ui->lineEdit_FS_DiffThrs->setText(QString::number(FS_DiffThrsQuint16));
              }

              qDebug()<<"SecondArray.toHex() "<<SecondArray.toHex();
              paramsVector.append(SecondArray);
              mapRead["secondByteArray"] = SecondArray;

              time_RealClock.setHMS(HourQuint8, MinuteQuint8, SecondQuint8);

              //
              //Day
              QByteArray dayArray;
              dayArray.append(buffer[7]);              

              quint8 dayQuint8 = buffer[7];

              if(dayQuint8>=1 && dayQuint8<=31) {

              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: День месяца"));
              }

              qDebug()<<"dayArray.toHex()"<<dayArray.toHex();
              paramsVector.append(dayArray);
              mapRead["dayByteArray"] = dayArray;

              //
              //Month
              QByteArray monthArray;
              monthArray.append(buffer[8]);              

              quint8 monthQuint8 = buffer[8];

              if(monthQuint8>=1 && monthQuint8<=12) {

              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Месяц"));
              }

              qDebug()<<"monthArray.toHex()"<<monthArray.toHex();
              paramsVector.append(monthArray);
              mapRead["monthByteArray"] = monthArray;

              //
              //Year
              QByteArray yearArray;
              yearArray.append(buffer[9]);


              quint16 yearQuint16 = buffer[9] + 2000;

              if(yearQuint16>=1990 && yearQuint16<=3000) {

              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Год"));
              }

              qDebug()<<"yearArray.toHex()"<<yearArray.toHex();
              paramsVector.append(yearArray);
              mapRead["yearByteArray"] = yearArray;

              //
              //DOW
              QByteArray DOWArray;
              DOWArray.append(buffer[10]);


              quint8 DOWQuint8 = buffer[10];

              if(DOWQuint8>=1 && DOWQuint8<=7) {

              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: День недели"));
              }

              qDebug()<<"DOWArray.toHex()"<<DOWArray.toHex();
              paramsVector.append(DOWArray);
              mapRead["DOWByteArray"] = DOWArray;

              date_RealClock.setDate(yearQuint16, monthQuint8, dayQuint8);

              dateTime_RealClock.setTime(time_RealClock);
              dateTime_RealClock.setDate(date_RealClock);
              ui->dateTimeEdit_realClock->setDisplayFormat("dd.MM.yyyy hh:mm:ss");
              ui->dateTimeEdit_realClock->setDateTime(dateTime_RealClock);

              //
              //ASW_flag
              QByteArray ASW_flagArray;
              ASW_flagArray.append(buffer[12]);


              quint8 ASW_flagQuint8 = buffer[12];

              if(ASW_flagList.contains(QString::number(ASW_flagQuint8))) {
                  ui->comboBox_ASW_flag->setCurrentText(QString::number(ASW_flagQuint8));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Автоматический переход зима-лето"));
              }

              qDebug()<<"ASW_flagArray.toHex()"<<ASW_flagArray.toHex();
              paramsVector.append(ASW_flagArray);
              mapRead["ASW_flagByteArray"] = ASW_flagArray;
              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  return;
               }
           }



       }


    }


    //
    //Read Calibration Factor 2
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x06;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x23;
           bytesForChecking.append(byte);
           byte = 0x86;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
 //             ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

              emit sendbufferReadCalibrationFactor2(buffer);

              //
              //Shift_T1

              QByteArray Shift_T1Array;
              Shift_T1Array.append(buffer[18]);
              Shift_T1Array.append(buffer[19]);
              qDebug()<<"Shift_T1Array.toHex() "<<Shift_T1Array.toHex();

              quint16 Shift_T1Quint16 = buffer[18];
              Shift_T1Quint16 = Shift_T1Quint16<<8 | buffer[19];

              float Shift_T1Float = (float)Shift_T1Quint16/1000000;

              if((int)Shift_T1Float == 0) {
                  ui->lineEdit_Shift_T1->setText("0.000000");
              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: Коэфффициент коррекции shift_t1 ")+ QString::number(Shift_T1Float)) ;
              }

              paramsVector.append(Shift_T1Array);
              mapRead["shift_T1ByteArray"] = Shift_T1Array;

              //
              //Shift_T2
              QByteArray Shift_T2Array;
              Shift_T2Array.append(buffer[20]);
              Shift_T2Array.append(buffer[21]);
              qDebug()<<"Shift_T2Array.toHex() "<<Shift_T2Array.toHex();

              quint16 Shift_T2Quint16 = buffer[20];
              Shift_T2Quint16 = Shift_T2Quint16<<8 | buffer[21];

              float Shift_T2Float = (float)Shift_T2Quint16/1000000;

              if((int)Shift_T2Float == 0) {
                  ui->lineEdit_Shift_T2->setText("0.000000");
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэфффициент коррекции shift_t2 ") + QString::number(Shift_T2Float));
              }

              paramsVector.append(Shift_T2Array);
              mapRead["shift_T2ByteArray"] = Shift_T2Array;

              //
              //Scale_T1
              QByteArray Scale_T1Array;
              Scale_T1Array.append(buffer[22]);
              Scale_T1Array.append(buffer[23]);
              Scale_T1Array.append(buffer[24]);
              Scale_T1Array.append(buffer[25]);
              qDebug()<<"Scale_T1Array.toHex() "<<Scale_T1Array.toHex();

              quint32 Scale_T1Quint32 = (quint8)buffer[22];
              Scale_T1Quint32 = Scale_T1Quint32<<8 | (quint8)buffer[23];
              Scale_T1Quint32 = Scale_T1Quint32<<8 | (quint8)buffer[24];
              Scale_T1Quint32 = Scale_T1Quint32<<8 | (quint8)buffer[25];

              float Scale_T1Float = (float)Scale_T1Quint32/1000000;

              if((int)Scale_T1Float == 1) {
                  ui->lineEdit_Scale_T1->setText("1.000000");
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Коэфффициент коррекции scale_t1 ") + QString::number(Scale_T1Float));
              }

              paramsVector.append(Scale_T1Array);
              mapRead["scale_T1ByteArray"] = Scale_T1Array;

              //
              //Scale_T2
              QByteArray Scale_T2Array;
              Scale_T2Array.append(buffer[26]);
              Scale_T2Array.append(buffer[27]);
              Scale_T2Array.append(buffer[28]);
              Scale_T2Array.append(buffer[29]);
              qDebug()<<"Scale_T2Array.toHex() "<<Scale_T2Array.toHex();

              quint32 Scale_T2Quint32 = (quint8)buffer[26];
              Scale_T2Quint32 = Scale_T2Quint32<<8 | (quint8)buffer[27];
              Scale_T2Quint32 = Scale_T2Quint32<<8 | (quint8)buffer[28];
              Scale_T2Quint32 = Scale_T2Quint32<<8 | (quint8)buffer[29];

              float Scale_T2Float = (float)Scale_T2Quint32/1000000;

              if((int)Scale_T2Float == 1) {
                  ui->lineEdit_Scale_T2->setText("1.000000");
       //           ui->lineEdit_Scale_T2->setText(QString::number((int)Scale_T2Float));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэфффициент коррекции scale_t2 ") + QString::number(Scale_T2Float));
              }

              paramsVector.append(Scale_T2Array);
              mapRead["scale_T2ByteArray"] = Scale_T2Array;

              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  return;
               }
           }



       }


    }


    //
    //Read External Interface Settings 5a 00 05 1b
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x1b;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x0e;
           bytesForChecking.append(byte);
           byte = 0x9b;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
 //             ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

              emit sendbufferReadExternalInterfaceSettings(buffer);

              //
              //Addr
              QByteArray AddrArray;
              AddrArray.append(buffer[4]);
              qDebug()<<"AddrArray.toHex() "<<AddrArray.toHex();

              quint8 AddrQuint8 = (quint8)buffer[4];

              if(AddrQuint8>=0 && AddrQuint8<=252) {
                  ui->spinBox_Addr->setValue(AddrQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес счётчика "));
                  ui->spinBox_Addr->setValue(AddrQuint8);
              }

              paramsVector.append(AddrArray);
              mapRead["addrByteArray"] = AddrArray;

              //
              //BaudRate
              QByteArray BaudRateArray;
              BaudRateArray.append(buffer[5]);
              qDebug()<<"BaudRateArray.toHex() "<<BaudRateArray.toHex();

              quint8 BaudRateQuint8 = (quint8)buffer[5];

              for(int j=0; j< ui->comboBox_BaudRate->count(); j++) {
                  ui->comboBox_BaudRate->setCurrentIndex(j);
                  if(BaudRateQuint8 == (quint8)ui->comboBox_BaudRate->currentData().toInt()) {
                      break;
                  }

                  if(j==3 && (BaudRateQuint8 != (quint8)ui->comboBox_BaudRate->currentData().toInt())) {
                       //                 QMessageBox::information(this, "", tr("Недопустимое значение: Скорость обмена ") + QString::number(BaudRateQuint8, 16));
                  }
              }

//              if(BaudRateList.contains(QString::number(BaudRateQuint8, 16))) {
//                  ui->comboBox_BaudRate->setCurrentText(QString::number(BaudRateQuint8, 16));
//              }
//              else {
//   //                 QMessageBox::information(this, "", tr("Недопустимое значение: Скорость обмена ") + QString::number(BaudRateQuint8, 16));
//              }

              paramsVector.append(BaudRateArray);
              mapRead["baudRateByteArray"] = BaudRateArray;

              //
              //HMP_Trans 2bytes  6,7
              QByteArray HMP_TransArray;
              HMP_TransArray.append(buffer[6]);
              HMP_TransArray.append(buffer[7]);
              qDebug()<<"HMP_TransArray.toHex() "<<HMP_TransArray.toHex();

              quint16 HMP_TransInt = (quint8)buffer[6];
              HMP_TransInt = HMP_TransInt<<8 | (quint8)buffer[7];

              if(HMP_TransInt == 0x3fff) {
                  ui->lineEdit_HMP_Trans->setText(QString::number(HMP_TransInt, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Позиционный код передаваемых параметров HMP_Trans ") +
//                                           QString::number(HMP_TransInt, 16));
              }

              paramsVector.append(HMP_TransArray);
              mapRead["HMP_TransByteArray"] = HMP_TransArray;

              //
              //EPP_Trans 2bytes  8,9
              QByteArray EPP_TransArray;
              EPP_TransArray.append(buffer[8]);
              EPP_TransArray.append(buffer[9]);
              qDebug()<<"EPP_TransArray.toHex() "<<EPP_TransArray.toHex();

              quint16 EPP_TransInt = (quint8)buffer[8];
              EPP_TransInt = EPP_TransInt<<8 | (quint8)buffer[9];

              if(EPP_TransInt == 0x000f) {
                  ui->lineEdit_EPP_Trans->setText(QString::number(EPP_TransInt, 16));
              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: Позиционный код передаваемых параметров EPP_Trans ") +
  //                                         QString::number(EPP_TransInt, 16));
              }

              paramsVector.append(EPP_TransArray);
              mapRead["EPP_TransByteArray"] = EPP_TransArray;

              //
              //P1_PrimAddr 1byte  10
              QByteArray P1_PrimAddrArray;
              P1_PrimAddrArray.append(buffer[10]);
              qDebug()<<"P1_PrimAddrArray.toHex() "<<P1_PrimAddrArray.toHex();

              quint8 P1_PrimAddrInt = (quint8)buffer[10];

              if(P1_PrimAddrInt>=0 && P1_PrimAddrInt<=252) {
                  ui->spinBox_P1PrimAddr->setValue(P1_PrimAddrInt);
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P1_PrimAddr ") +
//                                           QString::number(P1_PrimAddrInt, 10));
              }

              paramsVector.append(P1_PrimAddrArray);
              mapRead["P1PrimAddrByteArray"] = P1_PrimAddrArray;

              //
              //P2_PrimAddr 1byte  11
              QByteArray P2_PrimAddrArray;
              P2_PrimAddrArray.append(buffer[11]);
              qDebug()<<"P2_PrimAddrArray.toHex() "<<P2_PrimAddrArray.toHex();

              quint8 P2_PrimAddrInt = (quint8)buffer[11];

              if(P2_PrimAddrInt>=0 && P2_PrimAddrInt<=252) {
                  ui->spinBox_P2PrimAddr->setValue(P2_PrimAddrInt);
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P2_PrimAddr ") +
//                                           QString::number(P2_PrimAddrInt, 10));
              }

              paramsVector.append(P2_PrimAddrArray);
              mapRead["P2PrimAddrByteArray"] = P2_PrimAddrArray;

              //
              //ProtType 1byte  12
              QByteArray ProtTypeArray;
              ProtTypeArray.append(buffer[12]);
              qDebug()<<"ProtTypeArray.toHex() "<<ProtTypeArray.toHex();

              quint8 ProtTypeInt = (quint8)buffer[12];

              if(ProtTypeInt == 0xff) {
                  ui->lineEdit_ProtType->setText(QString::number(ProtTypeInt, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P2_PrimAddr ") +
//                                           QString::number(ProtTypeInt, 16));
              }

              paramsVector.append(ProtTypeArray);
              mapRead["ProtTypeByteArray"] = ProtTypeArray;




              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  return;
               }
           }



       }


    }

    //
    //
    //Read External Device Settings 5a 00 05 1c
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x1c;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x25;
           bytesForChecking.append(byte);
           byte = 0x9c;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
//              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

              emit sendbufferReadExternalDeviceSettings(buffer);

              //
              //Serial_P1
              QByteArray Serial_P1Array;
              Serial_P1Array.append(buffer[4]);
              Serial_P1Array.append(buffer[5]);
              Serial_P1Array.append(buffer[6]);
              Serial_P1Array.append(buffer[7]);
              qDebug()<<"Serial_P1Array.toHex() "<<Serial_P1Array.toHex();

              quint32 Serial_P1Quint32 = (quint8)buffer[4];
              Serial_P1Quint32 = Serial_P1Quint32<<8 | (quint8)buffer[5];
              Serial_P1Quint32 = Serial_P1Quint32<<8 | (quint8)buffer[6];
              Serial_P1Quint32 = Serial_P1Quint32<<8 | (quint8)buffer[7];

              if(Serial_P1Quint32 == 0x00000000) {
                  ui->lineEdit_Serial_P1->setText(QString::number(Serial_P1Quint32, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 Serial_P1 ")
//                                           + QString::number(Serial_P1Quint32, 16));
              }

              paramsVector.append(Serial_P1Array);
              mapRead["Serial_P1ByteArray"] = Serial_P1Array;

              //
              //ManCode_P1
              QByteArray ManCode_P1Array;
              ManCode_P1Array.append(buffer[8]);
              ManCode_P1Array.append(buffer[9]);
              qDebug()<<"ManCode_P1Array.toHex() "<<ManCode_P1Array.toHex();

              quint16 ManCode_P1Quint16 = (quint8)buffer[8];
              ManCode_P1Quint16 = ManCode_P1Quint16<<8 | (quint8)buffer[9];

              if(ManCode_P1Quint16 == 0x0000) {
                  ui->lineEdit_ManCode_P1->setText(QString::number(ManCode_P1Quint16, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 ManCode_P1 ")
//                                           + QString::number(ManCode_P1Quint16, 16));
              }

              paramsVector.append(ManCode_P1Array);
              mapRead["ManCode_P1ByteArray"] = ManCode_P1Array;

              //
              //DevType_P1
              QByteArray DevType_P1Array;
              DevType_P1Array.append(buffer[10]);
              qDebug()<<"DevType_P1Array.toHex() "<<DevType_P1Array.toHex();

              quint8 DevType_P1Int = (quint8)buffer[10];

              if(DevType_P1Int == 0x00) {
                  ui->lineEdit_DevType_P1->setText(QString::number(DevType_P1Int, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 DevType_P1 ") +
//                                           QString::number(DevType_P1Int, 16));
              }

              paramsVector.append(DevType_P1Array);
              mapRead["DevType_P1ByteArray"] = DevType_P1Array;

              //
              //Version_P1
              QByteArray Version_P1Array;
              Version_P1Array.append(buffer[11]);
              qDebug()<<"Version_P1Array.toHex() "<<Version_P1Array.toHex();

              quint8 Version_P1Int = (quint8)buffer[11];

              if(Version_P1Int == 0) {
                  ui->lineEdit_Version_P1->setText(QString::number(Version_P1Int, 10));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 Version_P1 ") +
//                                           QString::number(Version_P1Int, 10));
              }

              paramsVector.append(Version_P1Array);
              mapRead["Version_P1ByteArray"] = Version_P1Array;

              //
              //Initial_value_P1   12-15
              QByteArray Initial_value_P1Array;
              Initial_value_P1Array.append(buffer[12]);
              Initial_value_P1Array.append(buffer[13]);
              Initial_value_P1Array.append(buffer[14]);
              Initial_value_P1Array.append(buffer[15]);

              qDebug()<<"Initial_value_P1Array.toHex() "<<Initial_value_P1Array.toHex();

              quint32 Initial_value_P1Int = (quint8)buffer[12];
              Initial_value_P1Int = Initial_value_P1Int<<8 | (quint8)buffer[13];
              Initial_value_P1Int = Initial_value_P1Int<<8 | (quint8)buffer[14];
              Initial_value_P1Int = Initial_value_P1Int<<8 | (quint8)buffer[15];

              if(Initial_value_P1Int == 0) {
                  ui->lineEdit_Initial_value_P1->setText(QString::number(Initial_value_P1Int));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 Initial_value_P1 ") +
//                                           QString::number(Initial_value_P1Int));
              }

              paramsVector.append(Initial_value_P1Array);
              mapRead["Initial_value_P1ByteArray"] = Initial_value_P1Array;

              //
              //Service_P1  16-19
              QByteArray Service_P1Array;
              Service_P1Array.append(buffer[16]);
              Service_P1Array.append(buffer[17]);
              Service_P1Array.append(buffer[18]);
              Service_P1Array.append(buffer[19]);

              qDebug()<<"Service_P1Array.toHex() "<<Service_P1Array.toHex();

              quint32 Service_P1Int = (quint8)buffer[16];
              Service_P1Int = Service_P1Int<<8 | (quint8)buffer[17];
              Service_P1Int = Service_P1Int<<8 | (quint8)buffer[18];
              Service_P1Int = Service_P1Int<<8 | (quint8)buffer[19];

              if(Service_P1Int == 0x00000000) {
                  ui->lineEdit_Service_P1->setText(QString::number(Service_P1Int, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 Service_P1 ") +
//                                           QString::number(Service_P1Int, 16));
              }

              paramsVector.append(Service_P1Array);
              mapRead["Service_P1ByteArray"] = Service_P1Array;

              //
              //Serial P2
              QByteArray Serial_P2Array;
              Serial_P2Array.append(buffer[20]);
              Serial_P2Array.append(buffer[21]);
              Serial_P2Array.append(buffer[22]);
              Serial_P2Array.append(buffer[23]);
              qDebug()<<"Serial_P2Array.toHex() "<<Serial_P2Array.toHex();

              quint32 Serial_P2Quint32 = (quint8)buffer[20];
              Serial_P2Quint32 = Serial_P2Quint32<<8 | (quint8)buffer[21];
              Serial_P2Quint32 = Serial_P2Quint32<<8 | (quint8)buffer[22];
              Serial_P2Quint32 = Serial_P2Quint32<<8 | (quint8)buffer[23];

              if(Serial_P2Quint32 == 0x00000000) {
                  ui->lineEdit_Serial_P2->setText(QString::number(Serial_P2Quint32, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 Serial_P2 ")
//                                           + QString::number(Serial_P2Quint32, 16));
              }

              paramsVector.append(Serial_P2Array);
              mapRead["Serial_P2ByteArray"] = Serial_P2Array;

              //
              //ManCode P2
              QByteArray ManCode_P2Array;
              ManCode_P2Array.append(buffer[24]);
              ManCode_P2Array.append(buffer[25]);
              qDebug()<<"ManCode_P2Array.toHex() "<<ManCode_P2Array.toHex();

              quint16 ManCode_P2Quint16 = (quint8)buffer[24];
              ManCode_P2Quint16 = ManCode_P2Quint16<<8 | (quint8)buffer[25];

              if(ManCode_P2Quint16 == 0x0000) {
                  ui->lineEdit_ManCode_P2->setText(QString::number(ManCode_P2Quint16, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 ManCode_P2 ")
//                                           + QString::number(ManCode_P2Quint16, 16));
              }

              paramsVector.append(ManCode_P2Array);
              mapRead["ManCode_P2ByteArray"] = ManCode_P2Array;

              //
              //DevType P2
              QByteArray DevType_P2Array;
              DevType_P2Array.append(buffer[26]);
              qDebug()<<"DevType_P2Array.toHex() "<<DevType_P2Array.toHex();

              quint8 DevType_P2Int = (quint8)buffer[26];

              if(DevType_P2Int == 0x00) {
                  ui->lineEdit_DevType_P2->setText(QString::number(DevType_P2Int, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 DevType_P2 ") +
//                                           QString::number(DevType_P2Int, 16));
              }

              paramsVector.append(DevType_P2Array);
              mapRead["DevType_P2ByteArray"] = DevType_P2Array;

              //
              //Version P2
              QByteArray Version_P2Array;
              Version_P2Array.append(buffer[27]);
              qDebug()<<"Version_P2Array.toHex() "<<Version_P2Array.toHex();

              quint8 Version_P2Int = (quint8)buffer[27];

              if(Version_P2Int == 0) {
                  ui->lineEdit_Version_P2->setText(QString::number(Version_P2Int, 10));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 Version_P2 ") +
//                                           QString::number(Version_P2Int, 10));
              }

              paramsVector.append(Version_P2Array);
              mapRead["Version_P2ByteArray"] = Version_P2Array;

              //
              //Initial value P2
              QByteArray Initial_value_P2Array;
              Initial_value_P2Array.append(buffer[28]);
              Initial_value_P2Array.append(buffer[29]);
              Initial_value_P2Array.append(buffer[30]);
              Initial_value_P2Array.append(buffer[31]);

              qDebug()<<"Initial_value_P2Array.toHex() "<<Initial_value_P2Array.toHex();

              quint32 Initial_value_P2Int = (quint8)buffer[28];
              Initial_value_P2Int = Initial_value_P2Int<<8 | (quint8)buffer[29];
              Initial_value_P2Int = Initial_value_P2Int<<8 | (quint8)buffer[30];
              Initial_value_P2Int = Initial_value_P2Int<<8 | (quint8)buffer[31];

              if(Initial_value_P2Int == 0) {
                  ui->lineEdit_Initial_value_P2->setText(QString::number(Initial_value_P2Int));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 Initial_value_P2 ") +
//                                           QString::number(Initial_value_P2Int));
              }

              paramsVector.append(Initial_value_P2Array);
              mapRead["Initial_value_P2ByteArray"] = Initial_value_P2Array;

              //
              //Service P2   32-35
              QByteArray Service_P2Array;
              Service_P2Array.append(buffer[32]);
              Service_P2Array.append(buffer[33]);
              Service_P2Array.append(buffer[34]);
              Service_P2Array.append(buffer[35]);

              qDebug()<<"Service_P2Array.toHex() "<<Service_P2Array.toHex();

              quint32 Service_P2Int = (quint8)buffer[32];
              Service_P2Int = Service_P2Int<<8 | (quint8)buffer[33];
              Service_P2Int = Service_P2Int<<8 | (quint8)buffer[34];
              Service_P2Int = Service_P2Int<<8 | (quint8)buffer[35];

              if(Service_P2Int == 0x00000000) {
                  ui->lineEdit_Service_P2->setText(QString::number(Service_P2Int, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 Service_P2 ") +
//                                           QString::number(Service_P2Int, 16));
              }

              paramsVector.append(Service_P2Array);
              mapRead["Service_P2ByteArray"] = Service_P2Array;

              //
              //





              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  return;
               }
           }



       }


    }



}
/**********************************************************/
void MainWindow::writeToCounter()
{

}
/**********************************************************/
void MainWindow::writeTCC()
{
    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
            return;
        }
    }


    //
    //Temperature Channel Calibration 5a 00 0d 37 R_Real1(4bytes) R_Real2(4bytes)
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x0d;
       packetToRead.append(byte);
       byte = 0x37;
       packetToRead.append(byte);
       byte = 0x23;
       packetToRead.append(byte);
       byte = 0x17;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xc2;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               QMessageBox::information(this, "", tr("Ошибка данных"));
               return;
           }



       }


    }
}
/**********************************************************/
void MainWindow::readParams(int workPlaceNumber)
{
    vectorIsErrorOccured.fill(false);


    QSerialPort *portTmp = new QSerialPort(this);


    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }
        //   readFromCounter();


    qDebug()<<"portTmp->portName() "<<portTmp->portName();

        paramsVector.clear();

           QByteArray buffer;

           if(!portTmp->isOpen()) {
               if(!portTmp->open(QIODevice::ReadWrite)) {
 //                  QMessageBox::information(this, "", "Не удалось открыть порт УСО-2. Рабочее место: " + QString::number(workPlaceNumber + 1));
                   portTmp->close();
                   ui->label_StatusBar->setText("Не удалось открыть порт УСО-2. Рабочее место: " +
                                                QString::number(workPlaceNumber + 1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   return;
               }
           }



           //Read Hardware Configuration 5a000501
       for(int i=0; i<20;i++) {

           portTmp->clear();
           packetToRead.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
  //             QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               portTmp->close();
               return;
           }

           global::pause(110);

           buffer = portTmp->readAll();

           qDebug()<<"buffer.toHex() "<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + portTmp->portName() + " " + buffer.toHex());


           if(buffer.isEmpty()) {
               if(i==19) {
  //                 QMessageBox::information(this, "", tr("Не удалось прочитать данные") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                   portTmp->close();
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x26;
               bytesForChecking.append(byte);
               byte = 0x81;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

 //                 emit sendbufferReadHardwareConfiguration(buffer, workPlaceNumber);

                  //
                  //serial
                  QByteArray serialByteAray;
                  serialByteAray.append(buffer[12]);
                  serialByteAray.append(buffer[13]);
                  serialByteAray.append(buffer[14]);
                  serialByteAray.append(buffer[15]);
//                  ui->lineEdit_serial->setText(serialByteAray.toHex());
//                  qDebug()<<"serialByteAray.toHex() "<<serialByteAray.toHex();
//                  paramsVector.append(serialByteAray);

                  switch (workPlaceNumber) {
                  case 0:
                      mapRead["serialNumber"] = serialByteAray;
                      ui->lineEdit_serial->setText(serialByteAray.toHex());
                      qDebug()<<"serialByteAray.toHex() "<<serialByteAray.toHex();
                      break;
                  case 1:
                      mapRead["serialNumber2"] = serialByteAray;
                      ui->lineEdit_serial_2->setText(serialByteAray.toHex());
                      qDebug()<<"serialByteAray2.toHex() "<<serialByteAray.toHex();
                      break;
                  case 2:
                      mapRead["serialNumber3"] = serialByteAray;
                      ui->lineEdit_serial_3->setText(serialByteAray.toHex());
                      qDebug()<<"serialByteAray3.toHex() "<<serialByteAray.toHex();
                      break;
                  case 3:
                      mapRead["serialNumber4"] = serialByteAray;
                      ui->lineEdit_serial_4->setText(serialByteAray.toHex());
                      qDebug()<<"serialByteAray4.toHex() "<<serialByteAray.toHex();
                      break;
                  default:
                      break;
                  }

//                  mapRead["serialNumber"] = serialByteAray;

                  //
                  //ManCode
                  QByteArray manCodeByteArray;
                  manCodeByteArray.append(buffer[16]);
                  manCodeByteArray.append(buffer[17]);
                  int manufacturerSum = static_cast<quint8>(manCodeByteArray[0]);//manufacturer.toInt();
                  manufacturerSum = (manufacturerSum<<8)|(static_cast<quint8>(manCodeByteArray[1]));
                  quint8 symbol1, symbol2, symbol3;
                  symbol1 = ((manufacturerSum/(32*32))&0x1F) + 64;
                  symbol2 = ((manufacturerSum/32)&0x1F) + 64;
                  symbol3 = (manufacturerSum&0x1F) + 64;
                  QByteArray manufacturerString;
                  manufacturerString[0] = symbol1;
                  manufacturerString[1] = symbol2;
                  manufacturerString[2] = symbol3;
                  if(manCodeList.contains(QString::fromLatin1(manufacturerString))) {
                      ui->comboBox_ManCode->setCurrentText(QString::fromLatin1(manufacturerString));
                  }
                  else {
      //               QMessageBox::information(this, "", tr("Недопустимое значение: Производитель"));
                  }
                  qDebug()<<"QString::fromLatin1(manufacturerString)"<<QString::fromLatin1(manufacturerString);
                  paramsVector.append(manCodeByteArray);
                  mapRead["manCode"] = manCodeByteArray;

                  //
                  //DevType
                  QByteArray devType;
                  devType.append(buffer[18]);

                  if(devType[0] == 0x04) {
                      ui->comboBox_DevType->setCurrentText("Обратный");
                  }

                  if(devType[0] == 0x0c) {
                      ui->comboBox_DevType->setCurrentText("Подающий");
                  }

                  if((devType[0] != 0x04) && (devType[0] != 0x0c) ) {
                      QMessageBox::information(this, "", tr("Недопустимое значение: Тип счётчика") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                  }

                  qDebug()<<"devType.toHex() "<<devType.toHex();
                  paramsVector.append(devType);
                  mapRead["devType"] = devType;

                  //
                  //DN
                  QByteArray DN;
                  DN.append(buffer[19]);
                  if(DNList.contains(QString::number((quint8)buffer[19], 16))) {
                      ui->comboBox_DN->setCurrentText(QString::number((quint8)buffer[19], 16));
                  }
                  else {
    //                 QMessageBox::information(this, "", tr("Недопустимое значение: Диаметр условного прохода"));
                  }
                  qDebug()<<"DN.toHex() "<<DN.toHex();
                  paramsVector.append(DN);
                  mapRead["DN"] = DN;

                  //
                  //PCB_SN 8bytes (29-36)
                  QByteArray PCB_SN_Array;
                  PCB_SN_Array.append(buffer[29]);
                  PCB_SN_Array.append(buffer[30]);
                  PCB_SN_Array.append(buffer[31]);
                  PCB_SN_Array.append(buffer[32]);
                  PCB_SN_Array.append(buffer[33]);
                  PCB_SN_Array.append(buffer[34]);
                  PCB_SN_Array.append(buffer[35]);
                  PCB_SN_Array.append(buffer[36]);

                  PCB_SN_ByteArray.clear();
                  PCB_SN_ByteArray = PCB_SN_Array;

                  ui->lineEdit_PCB_SN->setText(PCB_SN_Array.toHex());
                  qDebug()<<"PCB_SN_Array.toHex() "<<PCB_SN_Array.toHex();
                  qDebug()<<"PCB_SN_ByteArray.toHex() "<<PCB_SN_ByteArray.toHex();
                  paramsVector.append(PCB_SN_Array);

                  switch (workPlaceNumber) {
                  case 0:
                     mapRead["PCB_SN_ByteArray"] = PCB_SN_Array;
                      break;
                  case 1:
                     mapRead["PCB_SN_ByteArray2"] = PCB_SN_Array;
                      break;
                  case 2:
                     mapRead["PCB_SN_ByteArray3"] = PCB_SN_Array;
                      break;
                  case 3:
                     mapRead["PCB_SN_ByteArray4"] = PCB_SN_Array;
                      break;
                  default:
                      break;
                  }

  //                mapRead["PCB_SN_ByteArray"] = PCB_SN_Array;


                  break;
               }
               else {
                   if(i==19) {
 //                     QMessageBox::information(this, "", tr("Ошибка данных") + ". Рабочее место: " + QString::number(workPlaceNumber + 1) );
                      portTmp->close();
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIsErrorOccured[workPlaceNumber] = true;
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      return;
                   }
               }

           }



        }
           //
           //
           //Read Software Configuration 5a000502
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x02;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
 //              QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               ui->label_writeParams->setVisible(true);
               vectorIsErrorOccured[workPlaceNumber] = true;
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();

           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
  //                 QMessageBox::information(this, "", tr("Не удалось прочитать данные") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                   portTmp->close();
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x16;
               bytesForChecking.append(byte);
               byte = 0x82;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
    //              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

    //              emit sendbufferReadSoftWareConfiguration(buffer);

                  //
                  //flowMin
                  QByteArray flowMinArray;
                  flowMinArray.append(buffer[4]);
                  flowMinArray.append(buffer[5]);
     //             ui->lineEdit_Flow_min->setText(flowMinArray.toHex());

     //             float flowMinFloat = buffer[4];
                  quint16 flowMinQuint16 = buffer[4];
                  flowMinQuint16 = flowMinQuint16<<8 | buffer[5];
                  float flowMinFloat = (float)flowMinQuint16/1000;
                  if(flowMinFloat>=0 && flowMinFloat<=0.2) {
                      ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальный расход"));
                      ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
                  }

                  qDebug()<<"flowMinArray.toHex() "<<flowMinArray.toHex();
                  paramsVector.append(flowMinArray);
                  mapRead["flowMinByteArray"] = flowMinArray;

                  //
                  //flowMax
                  QByteArray flowMaxArray;
                  flowMaxArray.append(buffer[6]);
                  flowMaxArray.append(buffer[7]);

     //             float flowMaxFloat = buffer[6];
                  quint16 flowMaxQuint16 = buffer[6];
                  flowMaxQuint16 = (flowMaxQuint16<<8) | (quint8)(buffer.at(7));
                  float flowMaxFloat = flowMaxQuint16;
                  flowMaxFloat = flowMaxFloat/1000;
                  if(flowMaxFloat>=2 && flowMaxFloat<=5) {
                      ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальный расход"));
                      ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
                  }

                  qDebug()<<"flowMaxArray.toHex() "<<flowMaxArray.toHex();
                  paramsVector.append(flowMaxArray);
                  mapRead["flowMaxByteArray"] = flowMaxArray;

                  //
                  //tinMin
                  QByteArray tinMinArray;
                  tinMinArray.append(buffer[8]);


                  quint8 tinMinQuint8 = buffer[8];
                  if(tinMinQuint8>=10 && tinMinQuint8<=60) {
                      ui->spinBox_Tin_min->setValue(tinMinQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура подачи"));
                  }

                  qDebug()<<"tinMinArray.toHex() "<<tinMinArray.toHex();
                  paramsVector.append(tinMinArray);
                  mapRead["tinMinByteArray"] = tinMinArray;

                  //
                  //tinMax
                  QByteArray tinMaxArray;
                  tinMaxArray.append(buffer[9]);


                  quint8 tinMaxQuint8 = buffer[9];
                  if(tinMaxQuint8>=50 && tinMaxQuint8<=150) {
                      ui->spinBox_Tin_max->setValue(tinMaxQuint8);
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура подачи"));
                  }

                  qDebug()<<"tinMaxArray.toHex() "<<tinMaxArray.toHex();
                  paramsVector.append(tinMaxArray);
                  mapRead["tinMaxByteArray"] = tinMaxArray;

                  //
                  //toutMin
                  QByteArray toutMinArray;
                  toutMinArray.append(buffer[10]);

                  quint8 toutMinQuint8 = buffer[10];
                  if(toutMinQuint8>=10 && toutMinQuint8<=60) {
                      ui->spinBox_Tout_min->setValue(toutMinQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура обратки"));
                  }

                  qDebug()<<"toutMinArray.toHex() "<<toutMinArray.toHex();
                  paramsVector.append(toutMinArray);
                  mapRead["toutMinByteArray"] = toutMinArray;


                  //
                  //toutMax
                  QByteArray toutMaxArray;
                  toutMaxArray.append(buffer[11]);

                  quint8 toutMaxQuint8 = buffer[11];
                  if(toutMaxQuint8>=50 && toutMaxQuint8<=150) {
                      ui->spinBox_Tout_max->setValue(toutMaxQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура обратки"));
                  }

                  qDebug()<<"toutMaxArray.toHex() "<<toutMaxArray.toHex();
                  paramsVector.append(toutMaxArray);
                  mapRead["toutMaxByteArray"] = toutMaxArray;

                  //
                  //reportData
                  QByteArray reportDataArray;
                  reportDataArray.append(buffer[12]);

                  quint8 reportDataInt = buffer[12];
                  if(reportDataInt>=0 && reportDataInt<=31) {
                      ui->spinBox_ReportData->setValue(reportDataInt);
                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: Дата сохранения в журнал"));
                  }

                  qDebug()<<"reportDataArray.toHex() "<<reportDataArray.toHex();
                  paramsVector.append(reportDataArray);
                  mapRead["reportDataByteArray"] = reportDataArray;

                  //
                  //AverageT
                  QByteArray AverageTArray;
                  AverageTArray.append(buffer[13]);


                  quint8 AverageTInt = buffer[13];
                  if(AverageTList.contains(QString::number(AverageTInt))) {
                      ui->comboBox_Average_T->setCurrentText(QString::number(AverageTInt));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Тип усреднения температуры"));
                  }

                  qDebug()<<"AverageTArray.toHex() "<<AverageTArray.toHex();
                  paramsVector.append(AverageTArray);
                  mapRead["averageTByteArray"] = AverageTArray;

                  //
                  //pulsesMode1
                  QByteArray pulsesMode1Array;
                  pulsesMode1Array.append(buffer[14]);


                  quint8 pulsesMode1Int = (quint8)buffer[14];
                  if(pulsesMode1List.contains(QString::number(pulsesMode1Int))) {
                      ui->comboBox_PulsesMode1->setCurrentText(QString::number(pulsesMode1Int));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
                  }

                  qDebug()<<"pulsesMode1Array.toHex() "<<pulsesMode1Array.toHex();
                  paramsVector.append(pulsesMode1Array);
                  mapRead["pulsesMode1ByteArray"] = pulsesMode1Array;

                  //
                  //pulsesMode2
                  QByteArray pulsesMode2Array;
                  pulsesMode2Array.append(buffer[15]);


                  quint8 pulsesMode2Int = (quint8)buffer[15];
                  if(pulsesMode1List.contains(QString::number(pulsesMode2Int))) {
                      ui->comboBox_PulsesMode2->setCurrentText(QString::number(pulsesMode2Int));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
                  }

                  qDebug()<<"pulsesMode2Array.toHex() "<<pulsesMode2Array.toHex();
                  paramsVector.append(pulsesMode2Array);
                  mapRead["pulsesMode2ByteArray"] = pulsesMode2Array;

                  //
                  //pulsesValue1
                  QByteArray pulsesValue1Array;
                  pulsesValue1Array.append(buffer[16]);
                  pulsesValue1Array.append(buffer[17]);


                  quint16 pulsesValue1Int = buffer[16];
                  pulsesValue1Int = pulsesValue1Int<<8 | (quint8)buffer[17];
    //              if((pulsesValue1Int<=101) && (pulsesValue1Int>=99)) {

    //              }
                  ui->lineEdit_PulsesValue1->setText(QString::number(pulsesValue1Int));

                  qDebug()<<"pulsesValue1Array.toHex() "<<pulsesValue1Array.toHex();
                  paramsVector.append(pulsesValue1Array);
                  mapRead["pulsesValue1ByteArray"] = pulsesValue1Array;

                  //
                  //pulsesValue2
                  QByteArray pulsesValue2Array;
                  pulsesValue2Array.append(buffer[18]);
                  pulsesValue2Array.append(buffer[19]);
                  qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();

                  quint16 pulsesValue2Int = buffer[18];
                  pulsesValue2Int = pulsesValue2Int<<8 | (quint8)buffer[19];
                  ui->lineEdit_PulsesValue2->setText(QString::number(pulsesValue2Int));

                  qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();
                  paramsVector.append(pulsesValue2Array);
                  mapRead["pulsesValue2ByteArray"] = pulsesValue2Array;

                  //
                  //DevType
                  QByteArray devType;
                  devType.append(buffer[20]);

                  if(devType[0] == 0x04) {
                      ui->comboBox_DevType->setCurrentText("Обратный");
                  }

                  if(devType[0] == 0x0c) {
                      ui->comboBox_DevType->setCurrentText("Подающий");
                  }

                  if((devType[0] != 0x04) && (devType[0] != 0x0c) ) {
  //                    QMessageBox::information(this, "", tr("Недопустимое значение: Тип счётчика") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                      ui->label_StatusBar->setText(tr("Недопустимое значение: Тип счётчика") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIsErrorOccured[workPlaceNumber] = true;
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      return;
                  }

                  qDebug()<<"devType.toHex() "<<devType.toHex();
                  paramsVector.append(devType);
                  mapRead["devType"] = devType;




                  break;
               }
               else {
                   if(i==2) {
 //                     QMessageBox::information(this, "", tr("Ошибка данных") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                      portTmp->close();
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIsErrorOccured[workPlaceNumber] = true;
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      return;
                   }
               }

           }


        }

           //
           //
           //Read Sensor Parameters      5a00050b
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x0b;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
 //              QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               ui->label_writeParams->setVisible(true);
               vectorIsErrorOccured[workPlaceNumber] = true;
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               return;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();

           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
 //                  QMessageBox::information(this, "", tr("Не удалось прочитать данные") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                   portTmp->close();
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x18;
               bytesForChecking.append(byte);
               byte = 0x8b;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
    //              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

   //               emit sendbufferReadSensorParameters(buffer);

                  //
                  //flowRate 4 bytes (4-7)
                  QByteArray flowRateArray;
                  flowRateArray.append(buffer[4]);
                  flowRateArray.append(buffer[5]);
                  flowRateArray.append(buffer[6]);
                  flowRateArray.append(buffer[7]);


                  quint32 flowRateQuint32 = buffer[4];
                  flowRateQuint32 = flowRateQuint32<<8 | (quint8)buffer[5];
                  flowRateQuint32 = flowRateQuint32<<8 | (quint8)buffer[6];
                  flowRateQuint32 = flowRateQuint32<<8 | (quint8)buffer[7];
                  float flowRateFloat = (float)flowRateQuint32/1000;
                  QString flowRateString = QString::number(flowRateFloat);
                  if((flowRateFloat - round(flowRateFloat)) == 0 ) { //проверка на отсутствие дробной части
                      flowRateString = flowRateString + ".00";
                  }

                  if(flowRateList.contains(flowRateString)) {
                      ui->comboBox_FlowRate->setCurrentText(QString::number(flowRateFloat));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Вес импульса вертушки"));
     //                 ui->comboBox_FlowRate->setCurrentText(QString::number(flowRateFloat));
                  }

                  qDebug()<<"flowRateArray.toHex() "<<flowRateArray.toHex();
                  paramsVector.append(flowRateArray);
                  mapRead["flowRateByteArray"] = flowRateArray;

                  //
                  //pressure 1 byte (8)
                  QByteArray pressureArray;
                  pressureArray.append(buffer[8]);

                  quint8 pressureQuint8 = buffer[8];
                  if(pressureQuint8 == 6) {
                      ui->lineEdit_Pressure->setText(QString::number(pressureQuint8));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Условное давление"));
                      ui->lineEdit_Pressure->setText(QString::number(pressureQuint8));
                  }

                  qDebug()<<"pressureArray.toHex() "<<pressureArray.toHex();
                  paramsVector.append(pressureArray);
                  mapRead["pressureByteArray"] = pressureArray;

                  //
                  //RTD_Type 1 byte (9)
                  QByteArray RTD_TypeArray;
                  RTD_TypeArray.append(buffer[9]);

                  quint8 RTD_TypeQuint8 = buffer[9];
                  if((RTD_TypeQuint8 >= 0) && (RTD_TypeQuint8 <= (RTD_TypeList.count() - 1))) {
                      ui->comboBox_RTD_Type->setCurrentIndex(RTD_TypeQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Тип термометров сопротивления"));
     //                 ui->comboBox_RTD_Type->setCurrentText(QString::number(RTD_TypeQuint8));
                  }

                  qDebug()<<"RTD_TypeArray.toHex() "<<RTD_TypeArray.toHex();
                  paramsVector.append(RTD_TypeArray);
                  mapRead["RTD_TypeByteArray"] = RTD_TypeArray;


                  //
                  //R_RTD 4 bytes (10-13)
                  QByteArray R_RTDArray;
                  R_RTDArray.append(buffer[10]);
                  R_RTDArray.append(buffer[11]);
                  R_RTDArray.append(buffer[12]);
                  R_RTDArray.append(buffer[13]);


                  quint32 R_RTDQuint32 = (quint8)buffer[10];
                  R_RTDQuint32 = R_RTDQuint32<<8 | (quint8)buffer[11];
                  R_RTDQuint32 = R_RTDQuint32<<8 | (quint8)buffer[12];
                  R_RTDQuint32 = R_RTDQuint32<<8 | (quint8)buffer[13];

                  if(R_RTDQuint32 == 1000) {
                      ui->lineEdit_R_RTD->setText(QString::number(R_RTDQuint32));
                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: Номинальное сопротивление термометров") + QString::number(R_RTDQuint32));
                  }

                  qDebug()<<"R_RTDArray.toHex() "<<R_RTDArray.toHex();
                  paramsVector.append(R_RTDArray);
                  mapRead["R_RTDByteArray"] = R_RTDArray;

                  //
                  //RWire1 4 bytes (14-17)
                  QByteArray RWire1Array;
                  RWire1Array.append(buffer[14]);
                  RWire1Array.append(buffer[15]);
                  RWire1Array.append(buffer[16]);
                  RWire1Array.append(buffer[17]);


                  quint32 RWire1Quint8 = buffer[14];
                  RWire1Quint8 = RWire1Quint8<<8 | (quint8)buffer[15];
                  RWire1Quint8 = RWire1Quint8<<8 | (quint8)buffer[16];
                  RWire1Quint8 = RWire1Quint8<<8 | (quint8)buffer[17];

                  if(RWire1Quint8 == 0) {
                      ui->lineEdit_RWire1->setText(QString::number(RWire1Quint8));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Сопротивление проводов термомнтров сопротивления"));
                  }

                  qDebug()<<"RWire1Array.toHex() "<<RWire1Array.toHex();
                  paramsVector.append(RWire1Array);
                  mapRead["RWire1ByteArray"] = RWire1Array;

                  //
                  //RWire2 4 bytes (18-21)
                  QByteArray RWire2Array;
                  RWire2Array.append(buffer[18]);
                  RWire2Array.append(buffer[19]);
                  RWire2Array.append(buffer[20]);
                  RWire2Array.append(buffer[21]);


                  quint32 RWire2Quint8 = buffer[18];
                  RWire2Quint8 = RWire2Quint8<<8 | (quint8)buffer[19];
                  RWire2Quint8 = RWire2Quint8<<8 | (quint8)buffer[20];
                  RWire2Quint8 = RWire2Quint8<<8 | (quint8)buffer[21];

                  if(RWire2Quint8 == 0) {
                      ui->lineEdit_RWire2->setText(QString::number(RWire2Quint8));
                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: Сопротивление проводов термомнтров сопротивления"));
                  }

                  qDebug()<<"RWire2Array.toHex() "<<RWire2Array.toHex();
                  paramsVector.append(RWire2Array);
                  mapRead["RWire2ByteArray"] = RWire2Array;

                  //
                  //flowNom 1 byte (22)
                  QByteArray flowNomArray;
                  flowNomArray.append(buffer[22]);


                  quint8 flowNomInt = buffer[22];
                  float flowNomFloat = (float)flowNomInt/10;
                  if(flowNomList.contains(QString::number(flowNomFloat))) {
                      ui->comboBox_FlowNom->setCurrentText(QString::number(flowNomFloat));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Номинальный расход"));
                  }

                  qDebug()<<"flowNomArray.toHex() "<<flowNomArray.toHex();
                  paramsVector.append(flowNomArray);
                  mapRead["flowNomByteArray"] = flowNomArray;



                  break;
               }
               else {
                   if(i==2) {
 //                     QMessageBox::information(this, "", tr("Ошибка данных") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                      portTmp->close();
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIsErrorOccured[workPlaceNumber] = true;
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      return;
                   }
               }

           }


        }

    //    //
    //    //
    //    //Read Flow Coefficient  5a 00 05 1d

        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x1d;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
  //             QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               ui->label_writeParams->setVisible(true);
               vectorIsErrorOccured[workPlaceNumber] = true;
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               return;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
  //                 QMessageBox::information(this, "", tr("Не удалось прочитать данные") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                   portTmp->close();
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x1d;
               bytesForChecking.append(byte);
               byte = 0x9d;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
     //             ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

    //              emit sendbufferReadFlowCoefficient(buffer);

                  //
                  //flowCoef0 4 bytes (4-7)
                  QByteArray flowCoef0Array;
                  flowCoef0Array.append(buffer[4]);
                  flowCoef0Array.append(buffer[5]);
                  flowCoef0Array.append(buffer[6]);
                  flowCoef0Array.append(buffer[7]);


                  quint32 flowCoef0Quint32 = (quint8)buffer[4];
                  flowCoef0Quint32 = flowCoef0Quint32<<8 | (quint8)buffer[5];
                  flowCoef0Quint32 = flowCoef0Quint32<<8 | (quint8)buffer[6];
                  flowCoef0Quint32 = flowCoef0Quint32<<8 | (quint8)buffer[7];
                  float flowCoef0Float = (float)flowCoef0Quint32/1000000;
                  if(flowCoef0Float == 1) {
                      ui->lineEdit_coef0->setText(QString::number(flowCoef0Float, 'g', 6) + ".000000");
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 0"));
                      ui->lineEdit_coef0->setText(QString::number(flowCoef0Float));
                  }

                  qDebug()<<"flowCoef0Array.toHex() "<<flowCoef0Array.toHex();
                  paramsVector.append(flowCoef0Array);
                  mapRead["flowCoef0ByteArray"] = flowCoef0Array;

                  //
                  //flowCoef1 4 bytes (8-11)
                  QByteArray flowCoef1Array;
                  flowCoef1Array.append(buffer[8]);
                  flowCoef1Array.append(buffer[9]);
                  flowCoef1Array.append(buffer[10]);
                  flowCoef1Array.append(buffer[11]);


                  quint32 flowCoef1Quint32 = (quint8)buffer[8];
                  flowCoef1Quint32 = flowCoef1Quint32<<8 | (quint8)buffer[9];
                  flowCoef1Quint32 = flowCoef1Quint32<<8 | (quint8)buffer[10];
                  flowCoef1Quint32 = flowCoef1Quint32<<8 | (quint8)buffer[11];
                  float flowCoef1Float = (float)flowCoef1Quint32/1000000;
                  if(flowCoef1Float == 1) {
                      ui->lineEdit_coef1->setText(QString::number(flowCoef1Float) + ".000000");
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 1"));
                      ui->lineEdit_coef1->setText(QString::number(flowCoef1Float));
                  }

                  qDebug()<<"flowCoef1Array.toHex() "<<flowCoef1Array.toHex();
                  paramsVector.append(flowCoef1Array);
                  mapRead["flowCoef1ByteArray"] = flowCoef1Array;


                  //
                  //flowCoef2 4 bytes (12-15)
                  QByteArray flowCoef2Array;
                  flowCoef2Array.append(buffer[12]);
                  flowCoef2Array.append(buffer[13]);
                  flowCoef2Array.append(buffer[14]);
                  flowCoef2Array.append(buffer[15]);


                  quint32 flowCoef2Quint32 = (quint8)buffer[12];
                  flowCoef2Quint32 = flowCoef2Quint32<<8 | (quint8)buffer[13];
                  flowCoef2Quint32 = flowCoef2Quint32<<8 | (quint8)buffer[14];
                  flowCoef2Quint32 = flowCoef2Quint32<<8 | (quint8)buffer[15];
                  float flowCoef2Float = (float)flowCoef2Quint32/1000000;
                  if(flowCoef2Float == 1) {
                      ui->lineEdit_coef2->setText(QString::number(flowCoef2Float) + ".000000");
                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 2"));
                      ui->lineEdit_coef2->setText(QString::number(flowCoef2Float));
                  }

                  qDebug()<<"flowCoef2Array.toHex() "<<flowCoef2Array.toHex();
                  paramsVector.append(flowCoef2Array);
                  mapRead["flowCoef2ByteArray"] = flowCoef2Array;


                  //
                  //flowCoef3 4 bytes (16-19)
                  QByteArray flowCoef3Array;
                  flowCoef3Array.append(buffer[16]);
                  flowCoef3Array.append(buffer[17]);
                  flowCoef3Array.append(buffer[18]);
                  flowCoef3Array.append(buffer[19]);


                  quint32 flowCoef3Quint32 = (quint8)buffer[16];
                  flowCoef3Quint32 = flowCoef3Quint32<<8 | (quint8)buffer[17];
                  flowCoef3Quint32 = flowCoef3Quint32<<8 | (quint8)buffer[18];
                  flowCoef3Quint32 = flowCoef3Quint32<<8 | (quint8)buffer[19];
                  float flowCoef3Float = (float)flowCoef3Quint32/1000000;
                  if(flowCoef3Float == 1) {
                      ui->lineEdit_coef3->setText(QString::number(flowCoef3Float) + ".000000");
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 3"));
                      ui->lineEdit_coef3->setText(QString::number(flowCoef3Float));
                  }

                  qDebug()<<"flowCoef3Array.toHex() "<<flowCoef3Array.toHex();
                  paramsVector.append(flowCoef3Array);
                  mapRead["flowCoef3ByteArray"] = flowCoef3Array;


                  //
                  //flowCoef4 4 bytes (20-23)
                  QByteArray flowCoef4Array;
                  flowCoef4Array.append(buffer[20]);
                  flowCoef4Array.append(buffer[21]);
                  flowCoef4Array.append(buffer[22]);
                  flowCoef4Array.append(buffer[23]);


                  quint32 flowCoef4Quint32 = (quint8)buffer[20];
                  flowCoef4Quint32 = flowCoef4Quint32<<8 | (quint8)buffer[21];
                  flowCoef4Quint32 = flowCoef4Quint32<<8 | (quint8)buffer[22];
                  flowCoef4Quint32 = flowCoef4Quint32<<8 | (quint8)buffer[23];
                  float flowCoef4Float = (float)flowCoef4Quint32/1000000;
                  if(flowCoef4Float == 1) {
                      ui->lineEdit_coef4->setText(QString::number(flowCoef4Float) + ".000000");
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 4"));
                      ui->lineEdit_coef4->setText(QString::number(flowCoef4Float));
                  }

                  qDebug()<<"flowCoef4Array.toHex() "<<flowCoef4Array.toHex();
                  paramsVector.append(flowCoef4Array);
                  mapRead["flowCoef4ByteArray"] = flowCoef4Array;


                  //
                  //flowCoef5 4 bytes (24-27)
                  QByteArray flowCoef5Array;
                  flowCoef5Array.append(buffer[24]);
                  flowCoef5Array.append(buffer[25]);
                  flowCoef5Array.append(buffer[26]);
                  flowCoef5Array.append(buffer[27]);


                  quint32 flowCoef5Quint32 = (quint8)buffer[24];
                  flowCoef5Quint32 = flowCoef5Quint32<<8 | (quint8)buffer[25];
                  flowCoef5Quint32 = flowCoef5Quint32<<8 | (quint8)buffer[26];
                  flowCoef5Quint32 = flowCoef5Quint32<<8 | (quint8)buffer[27];
                  float flowCoef5Float = (float)flowCoef5Quint32/1000000;
                  if(flowCoef5Float == 1) {
                      ui->lineEdit_coef5->setText(QString::number(flowCoef5Float) + ".000000");
                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: Коэффициент коррекции расхода 5"));
                      ui->lineEdit_coef5->setText(QString::number(flowCoef5Float));
                  }

                  qDebug()<<"flowCoef5Array.toHex() "<<flowCoef5Array.toHex();
                  paramsVector.append(flowCoef5Array);
                  mapRead["flowCoef5ByteArray"] = flowCoef5Array;





                  break;
               }
               else {
                   if(i==2) {
 //                     QMessageBox::information(this, "", tr("Ошибка данных") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                      portTmp->close();
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIsErrorOccured[workPlaceNumber] = true;
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      return;
                   }
               }

           }


        }


    //    //
    //    //Read Calibration Factor 5a 00 05 06
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x06;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
  //             QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               ui->label_writeParams->setVisible(true);
               vectorIsErrorOccured[workPlaceNumber] = true;
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               return;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
 //                  QMessageBox::information(this, "", tr("Не удалось прочитать данные") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                   portTmp->close();
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x23;
               bytesForChecking.append(byte);
               byte = 0x86;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
    //              ui->textBrowser->append("buffer.toHex()      " + buffer.toHex());

    //              emit sendbufferReadCalibrationFactor(buffer);

                  //
                  //FS_DiffThrs
                  QByteArray FS_DiffThrsArray;
                  FS_DiffThrsArray.append(buffer[8]);
                  FS_DiffThrsArray.append(buffer[9]);


                  quint16 FS_DiffThrsQuint16 = buffer[8];
                  FS_DiffThrsQuint16 = FS_DiffThrsQuint16<<8 | buffer[9];

                  if(FS_DiffThrsQuint16 == 30) {
                      ui->lineEdit_FS_DiffThrs->setText(QString::number(FS_DiffThrsQuint16));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Порог срабатывания датчика расхода "));
                      ui->lineEdit_FS_DiffThrs->setText(QString::number(FS_DiffThrsQuint16));
                  }

                  qDebug()<<"FS_DiffThrsArray.toHex() "<<FS_DiffThrsArray.toHex();
                  paramsVector.append(FS_DiffThrsArray);
                  mapRead["FS_DiffThrsByteArray"] = FS_DiffThrsArray;



                  break;
               }
               else {
                   if(i==2) {
 //                     QMessageBox::information(this, "", tr("Ошибка данных") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                      portTmp->close();
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIsErrorOccured[workPlaceNumber] = true;
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      return;
                   }
               }

           }


        }

        //
        //Read Real Clock 5a 00 05 05
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
 //              QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               ui->label_writeParams->setVisible(true);
               vectorIsErrorOccured[workPlaceNumber] = true;
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               return;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось прочитать данные") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
//                   portTmp->close();
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x0e;
               bytesForChecking.append(byte);
               byte = 0x85;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
    //              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

    //              emit sendbufferReadRealClock(buffer);

                  //
                  //Hour
                  QDateTime dateTime_RealClock;
                  QDate date_RealClock;
                  QTime time_RealClock;

                  QByteArray HourArray;
                  HourArray.append(buffer[4]);


                  quint8 HourQuint8 = buffer[4];

                  if(HourQuint8>=0 && HourQuint8<=23) {
     //                 time_RealClock.
                  }
                  else {
  //                    QMessageBox::information(this, "", tr("Недопустимое значение: Часы") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
                      ui->label_StatusBar->setText(tr("Недопустимое значение: Часы") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIsErrorOccured[workPlaceNumber] = true;
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      return;
                  }

                  qDebug()<<"HourArray.toHex() "<<HourArray.toHex();
                  paramsVector.append(HourArray);
                  mapRead["hourByteArray"] = HourArray;

                  //
                  //Minute
                  QByteArray MinuteArray;
                  MinuteArray.append(buffer[5]);


                  quint8 MinuteQuint8 = buffer[5];

                  if(MinuteQuint8>=0 && MinuteQuint8<=59) {
     //                 time_RealClock.
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минуты"));
     //                 ui->lineEdit_FS_DiffThrs->setText(QString::number(FS_DiffThrsQuint16));
                  }

                  qDebug()<<"MinuteArray.toHex() "<<MinuteArray.toHex();
                  paramsVector.append(MinuteArray);
                  mapRead["minuteByteArray"] = MinuteArray;

                  //
                  //Second
                  QByteArray SecondArray;
                  SecondArray.append(buffer[6]);

                  quint8 SecondQuint8 = buffer[6];

                  if(SecondQuint8>=0 && SecondQuint8<=59) {
     //                 time_RealClock.
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Секунды"));
     //                 ui->lineEdit_FS_DiffThrs->setText(QString::number(FS_DiffThrsQuint16));
                  }

                  qDebug()<<"SecondArray.toHex() "<<SecondArray.toHex();
                  paramsVector.append(SecondArray);
                  mapRead["secondByteArray"] = SecondArray;

                  time_RealClock.setHMS(HourQuint8, MinuteQuint8, SecondQuint8);

                  //
                  //Day
                  QByteArray dayArray;
                  dayArray.append(buffer[7]);

                  quint8 dayQuint8 = buffer[7];

                  if(dayQuint8>=1 && dayQuint8<=31) {

                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: День месяца"));
                  }

                  qDebug()<<"dayArray.toHex()"<<dayArray.toHex();
                  paramsVector.append(dayArray);
                  mapRead["dayByteArray"] = dayArray;

                  //
                  //Month
                  QByteArray monthArray;
                  monthArray.append(buffer[8]);

                  quint8 monthQuint8 = buffer[8];

                  if(monthQuint8>=1 && monthQuint8<=12) {

                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Месяц"));
                  }

                  qDebug()<<"monthArray.toHex()"<<monthArray.toHex();
                  paramsVector.append(monthArray);
                  mapRead["monthByteArray"] = monthArray;

                  //
                  //Year
                  QByteArray yearArray;
                  yearArray.append(buffer[9]);


                  quint16 yearQuint16 = buffer[9] + 2000;

                  if(yearQuint16>=1990 && yearQuint16<=3000) {

                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Год"));
                  }

                  qDebug()<<"yearArray.toHex()"<<yearArray.toHex();
                  paramsVector.append(yearArray);
                  mapRead["yearByteArray"] = yearArray;

                  //
                  //DOW
                  QByteArray DOWArray;
                  DOWArray.append(buffer[10]);


                  quint8 DOWQuint8 = buffer[10];

                  if(DOWQuint8>=1 && DOWQuint8<=7) {

                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: День недели"));
                  }

                  qDebug()<<"DOWArray.toHex()"<<DOWArray.toHex();
                  paramsVector.append(DOWArray);
                  mapRead["DOWByteArray"] = DOWArray;

                  date_RealClock.setDate(yearQuint16, monthQuint8, dayQuint8);

                  dateTime_RealClock.setTime(time_RealClock);
                  dateTime_RealClock.setDate(date_RealClock);
                  ui->dateTimeEdit_realClock->setDisplayFormat("dd.MM.yyyy hh:mm:ss");
                  ui->dateTimeEdit_realClock->setDateTime(dateTime_RealClock);

                  //
                  //ASW_flag
                  QByteArray ASW_flagArray;
                  ASW_flagArray.append(buffer[12]);


                  quint8 ASW_flagQuint8 = buffer[12];

                  if(ASW_flagList.contains(QString::number(ASW_flagQuint8))) {
                      ui->comboBox_ASW_flag->setCurrentText(QString::number(ASW_flagQuint8));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Автоматический переход зима-лето"));
                  }

                  qDebug()<<"ASW_flagArray.toHex()"<<ASW_flagArray.toHex();
                  paramsVector.append(ASW_flagArray);
                  mapRead["ASW_flagByteArray"] = ASW_flagArray;
                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка данных"));
//                      portTmp->close();
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIsErrorOccured[workPlaceNumber] = true;
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }


        //
        //Read Calibration Factor 2
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x06;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
   //            QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               ui->label_writeParams->setVisible(true);
               vectorIsErrorOccured[workPlaceNumber] = true;
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               return;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось прочитать данные") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
//                   portTmp->close();
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x23;
               bytesForChecking.append(byte);
               byte = 0x86;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
     //             ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

     //             emit sendbufferReadCalibrationFactor2(buffer);

                  //
                  //Shift_T1

                  QByteArray Shift_T1Array;
                  Shift_T1Array.append(buffer[18]);
                  Shift_T1Array.append(buffer[19]);
                  qDebug()<<"Shift_T1Array.toHex() "<<Shift_T1Array.toHex();

                  quint16 Shift_T1Quint16 = buffer[18];
                  Shift_T1Quint16 = Shift_T1Quint16<<8 | buffer[19];

                  float Shift_T1Float = (float)Shift_T1Quint16/1000000;

                  if((int)Shift_T1Float == 0) {
                      ui->lineEdit_Shift_T1->setText("0.000000");
                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: Коэфффициент коррекции shift_t1 ")+ QString::number(Shift_T1Float)) ;
                  }

                  paramsVector.append(Shift_T1Array);
                  mapRead["shift_T1ByteArray"] = Shift_T1Array;

                  //
                  //Shift_T2
                  QByteArray Shift_T2Array;
                  Shift_T2Array.append(buffer[20]);
                  Shift_T2Array.append(buffer[21]);
                  qDebug()<<"Shift_T2Array.toHex() "<<Shift_T2Array.toHex();

                  quint16 Shift_T2Quint16 = buffer[20];
                  Shift_T2Quint16 = Shift_T2Quint16<<8 | buffer[21];

                  float Shift_T2Float = (float)Shift_T2Quint16/1000000;

                  if((int)Shift_T2Float == 0) {
                      ui->lineEdit_Shift_T2->setText("0.000000");
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэфффициент коррекции shift_t2 ") + QString::number(Shift_T2Float));
                  }

                  paramsVector.append(Shift_T2Array);
                  mapRead["shift_T2ByteArray"] = Shift_T2Array;

                  //
                  //Scale_T1
                  QByteArray Scale_T1Array;
                  Scale_T1Array.append(buffer[22]);
                  Scale_T1Array.append(buffer[23]);
                  Scale_T1Array.append(buffer[24]);
                  Scale_T1Array.append(buffer[25]);
                  qDebug()<<"Scale_T1Array.toHex() "<<Scale_T1Array.toHex();

                  quint32 Scale_T1Quint32 = (quint8)buffer[22];
                  Scale_T1Quint32 = Scale_T1Quint32<<8 | (quint8)buffer[23];
                  Scale_T1Quint32 = Scale_T1Quint32<<8 | (quint8)buffer[24];
                  Scale_T1Quint32 = Scale_T1Quint32<<8 | (quint8)buffer[25];

                  float Scale_T1Float = (float)Scale_T1Quint32/1000000;

                  if((int)Scale_T1Float == 1) {
                      ui->lineEdit_Scale_T1->setText("1.000000");
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Коэфффициент коррекции scale_t1 ") + QString::number(Scale_T1Float));
                  }

                  paramsVector.append(Scale_T1Array);
                  mapRead["scale_T1ByteArray"] = Scale_T1Array;

                  //
                  //Scale_T2
                  QByteArray Scale_T2Array;
                  Scale_T2Array.append(buffer[26]);
                  Scale_T2Array.append(buffer[27]);
                  Scale_T2Array.append(buffer[28]);
                  Scale_T2Array.append(buffer[29]);
                  qDebug()<<"Scale_T2Array.toHex() "<<Scale_T2Array.toHex();

                  quint32 Scale_T2Quint32 = (quint8)buffer[26];
                  Scale_T2Quint32 = Scale_T2Quint32<<8 | (quint8)buffer[27];
                  Scale_T2Quint32 = Scale_T2Quint32<<8 | (quint8)buffer[28];
                  Scale_T2Quint32 = Scale_T2Quint32<<8 | (quint8)buffer[29];

                  float Scale_T2Float = (float)Scale_T2Quint32/1000000;

                  if((int)Scale_T2Float == 1) {
                      ui->lineEdit_Scale_T2->setText("1.000000");
           //           ui->lineEdit_Scale_T2->setText(QString::number((int)Scale_T2Float));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Коэфффициент коррекции scale_t2 ") + QString::number(Scale_T2Float));
                  }

                  paramsVector.append(Scale_T2Array);
                  mapRead["scale_T2ByteArray"] = Scale_T2Array;

                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка данных") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
//                      portTmp->close();
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIsErrorOccured[workPlaceNumber] = true;
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }


        //
        //Read External Interface Settings 5a 00 05 1b
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x1b;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
   //            QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               ui->label_writeParams->setVisible(true);
               vectorIsErrorOccured[workPlaceNumber] = true;
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               return;;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось прочитать данные") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
//                   portTmp->close();
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x0e;
               bytesForChecking.append(byte);
               byte = 0x9b;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
     //             ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

     //             emit sendbufferReadExternalInterfaceSettings(buffer);

                  //
                  //Addr
                  QByteArray AddrArray;
                  AddrArray.append(buffer[4]);
                  qDebug()<<"AddrArray.toHex() "<<AddrArray.toHex();

                  quint8 AddrQuint8 = (quint8)buffer[4];

                  if(AddrQuint8>=0 && AddrQuint8<=252) {
                      ui->spinBox_Addr->setValue(AddrQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес счётчика "));
                      ui->spinBox_Addr->setValue(AddrQuint8);
                  }

                  paramsVector.append(AddrArray);
                  mapRead["addrByteArray"] = AddrArray;

                  //
                  //BaudRate
                  QByteArray BaudRateArray;
                  BaudRateArray.append(buffer[5]);
                  qDebug()<<"BaudRateArray.toHex() "<<BaudRateArray.toHex();

                  quint8 BaudRateQuint8 = (quint8)buffer[5];

                  for(int j=0; j< ui->comboBox_BaudRate->count(); j++) {
                      ui->comboBox_BaudRate->setCurrentIndex(j);
                      if(BaudRateQuint8 == (quint8)ui->comboBox_BaudRate->currentData().toInt()) {
                          break;
                      }

                      if(j==3 && (BaudRateQuint8 != (quint8)ui->comboBox_BaudRate->currentData().toInt())) {
                           //                 QMessageBox::information(this, "", tr("Недопустимое значение: Скорость обмена ") + QString::number(BaudRateQuint8, 16));
                      }
                  }

    //              if(BaudRateList.contains(QString::number(BaudRateQuint8, 16))) {
    //                  ui->comboBox_BaudRate->setCurrentText(QString::number(BaudRateQuint8, 16));
    //              }
    //              else {
    //   //                 QMessageBox::information(this, "", tr("Недопустимое значение: Скорость обмена ") + QString::number(BaudRateQuint8, 16));
    //              }

                  paramsVector.append(BaudRateArray);
                  mapRead["baudRateByteArray"] = BaudRateArray;

                  //
                  //HMP_Trans 2bytes  6,7
                  QByteArray HMP_TransArray;
                  HMP_TransArray.append(buffer[6]);
                  HMP_TransArray.append(buffer[7]);
                  qDebug()<<"HMP_TransArray.toHex() "<<HMP_TransArray.toHex();

                  quint16 HMP_TransInt = (quint8)buffer[6];
                  HMP_TransInt = HMP_TransInt<<8 | (quint8)buffer[7];

                  if(HMP_TransInt == 0x3fff) {
                      ui->lineEdit_HMP_Trans->setText(QString::number(HMP_TransInt, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Позиционный код передаваемых параметров HMP_Trans ") +
    //                                           QString::number(HMP_TransInt, 16));
                  }

                  paramsVector.append(HMP_TransArray);
                  mapRead["HMP_TransByteArray"] = HMP_TransArray;

                  //
                  //EPP_Trans 2bytes  8,9
                  QByteArray EPP_TransArray;
                  EPP_TransArray.append(buffer[8]);
                  EPP_TransArray.append(buffer[9]);
                  qDebug()<<"EPP_TransArray.toHex() "<<EPP_TransArray.toHex();

                  quint16 EPP_TransInt = (quint8)buffer[8];
                  EPP_TransInt = EPP_TransInt<<8 | (quint8)buffer[9];

                  if(EPP_TransInt == 0x000f) {
                      ui->lineEdit_EPP_Trans->setText(QString::number(EPP_TransInt, 16));
                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: Позиционный код передаваемых параметров EPP_Trans ") +
      //                                         QString::number(EPP_TransInt, 16));
                  }

                  paramsVector.append(EPP_TransArray);
                  mapRead["EPP_TransByteArray"] = EPP_TransArray;

                  //
                  //P1_PrimAddr 1byte  10
                  QByteArray P1_PrimAddrArray;
                  P1_PrimAddrArray.append(buffer[10]);
                  qDebug()<<"P1_PrimAddrArray.toHex() "<<P1_PrimAddrArray.toHex();

                  quint8 P1_PrimAddrInt = (quint8)buffer[10];

                  if(P1_PrimAddrInt>=0 && P1_PrimAddrInt<=252) {
                      ui->spinBox_P1PrimAddr->setValue(P1_PrimAddrInt);
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P1_PrimAddr ") +
    //                                           QString::number(P1_PrimAddrInt, 10));
                  }

                  paramsVector.append(P1_PrimAddrArray);
                  mapRead["P1PrimAddrByteArray"] = P1_PrimAddrArray;

                  //
                  //P2_PrimAddr 1byte  11
                  QByteArray P2_PrimAddrArray;
                  P2_PrimAddrArray.append(buffer[11]);
                  qDebug()<<"P2_PrimAddrArray.toHex() "<<P2_PrimAddrArray.toHex();

                  quint8 P2_PrimAddrInt = (quint8)buffer[11];

                  if(P2_PrimAddrInt>=0 && P2_PrimAddrInt<=252) {
                      ui->spinBox_P2PrimAddr->setValue(P2_PrimAddrInt);
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P2_PrimAddr ") +
    //                                           QString::number(P2_PrimAddrInt, 10));
                  }

                  paramsVector.append(P2_PrimAddrArray);
                  mapRead["P2PrimAddrByteArray"] = P2_PrimAddrArray;

                  //
                  //ProtType 1byte  12
                  QByteArray ProtTypeArray;
                  ProtTypeArray.append(buffer[12]);
                  qDebug()<<"ProtTypeArray.toHex() "<<ProtTypeArray.toHex();

                  quint8 ProtTypeInt = (quint8)buffer[12];

                  if(ProtTypeInt == 0xff) {
                      ui->lineEdit_ProtType->setText(QString::number(ProtTypeInt, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P2_PrimAddr ") +
    //                                           QString::number(ProtTypeInt, 16));
                  }

                  paramsVector.append(ProtTypeArray);
                  mapRead["ProtTypeByteArray"] = ProtTypeArray;




                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка данных") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
//                      portTmp->close();
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIsErrorOccured[workPlaceNumber] = true;
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Read External Device Settings 5a 00 05 1c
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x1c;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
 //              QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               ui->label_writeParams->setVisible(true);
               vectorIsErrorOccured[workPlaceNumber] = true;
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               return;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось прочитать данные") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
//                   portTmp->close();
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x25;
               bytesForChecking.append(byte);
               byte = 0x9c;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
    //              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

    //              emit sendbufferReadExternalDeviceSettings(buffer);

                  //
                  //Serial_P1
                  QByteArray Serial_P1Array;
                  Serial_P1Array.append(buffer[4]);
                  Serial_P1Array.append(buffer[5]);
                  Serial_P1Array.append(buffer[6]);
                  Serial_P1Array.append(buffer[7]);
                  qDebug()<<"Serial_P1Array.toHex() "<<Serial_P1Array.toHex();

                  quint32 Serial_P1Quint32 = (quint8)buffer[4];
                  Serial_P1Quint32 = Serial_P1Quint32<<8 | (quint8)buffer[5];
                  Serial_P1Quint32 = Serial_P1Quint32<<8 | (quint8)buffer[6];
                  Serial_P1Quint32 = Serial_P1Quint32<<8 | (quint8)buffer[7];

                  if(Serial_P1Quint32 == 0x00000000) {
                      ui->lineEdit_Serial_P1->setText(QString::number(Serial_P1Quint32, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 Serial_P1 ")
    //                                           + QString::number(Serial_P1Quint32, 16));
                  }

                  paramsVector.append(Serial_P1Array);
                  mapRead["Serial_P1ByteArray"] = Serial_P1Array;

                  //
                  //ManCode_P1
                  QByteArray ManCode_P1Array;
                  ManCode_P1Array.append(buffer[8]);
                  ManCode_P1Array.append(buffer[9]);
                  qDebug()<<"ManCode_P1Array.toHex() "<<ManCode_P1Array.toHex();

                  quint16 ManCode_P1Quint16 = (quint8)buffer[8];
                  ManCode_P1Quint16 = ManCode_P1Quint16<<8 | (quint8)buffer[9];

                  if(ManCode_P1Quint16 == 0x0000) {
                      ui->lineEdit_ManCode_P1->setText(QString::number(ManCode_P1Quint16, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 ManCode_P1 ")
    //                                           + QString::number(ManCode_P1Quint16, 16));
                  }

                  paramsVector.append(ManCode_P1Array);
                  mapRead["ManCode_P1ByteArray"] = ManCode_P1Array;

                  //
                  //DevType_P1
                  QByteArray DevType_P1Array;
                  DevType_P1Array.append(buffer[10]);
                  qDebug()<<"DevType_P1Array.toHex() "<<DevType_P1Array.toHex();

                  quint8 DevType_P1Int = (quint8)buffer[10];

                  if(DevType_P1Int == 0x00) {
                      ui->lineEdit_DevType_P1->setText(QString::number(DevType_P1Int, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 DevType_P1 ") +
    //                                           QString::number(DevType_P1Int, 16));
                  }

                  paramsVector.append(DevType_P1Array);
                  mapRead["DevType_P1ByteArray"] = DevType_P1Array;

                  //
                  //Version_P1
                  QByteArray Version_P1Array;
                  Version_P1Array.append(buffer[11]);
                  qDebug()<<"Version_P1Array.toHex() "<<Version_P1Array.toHex();

                  quint8 Version_P1Int = (quint8)buffer[11];

                  if(Version_P1Int == 0) {
                      ui->lineEdit_Version_P1->setText(QString::number(Version_P1Int, 10));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 Version_P1 ") +
    //                                           QString::number(Version_P1Int, 10));
                  }

                  paramsVector.append(Version_P1Array);
                  mapRead["Version_P1ByteArray"] = Version_P1Array;

                  //
                  //Initial_value_P1   12-15
                  QByteArray Initial_value_P1Array;
                  Initial_value_P1Array.append(buffer[12]);
                  Initial_value_P1Array.append(buffer[13]);
                  Initial_value_P1Array.append(buffer[14]);
                  Initial_value_P1Array.append(buffer[15]);

                  qDebug()<<"Initial_value_P1Array.toHex() "<<Initial_value_P1Array.toHex();

                  quint32 Initial_value_P1Int = (quint8)buffer[12];
                  Initial_value_P1Int = Initial_value_P1Int<<8 | (quint8)buffer[13];
                  Initial_value_P1Int = Initial_value_P1Int<<8 | (quint8)buffer[14];
                  Initial_value_P1Int = Initial_value_P1Int<<8 | (quint8)buffer[15];

                  if(Initial_value_P1Int == 0) {
                      ui->lineEdit_Initial_value_P1->setText(QString::number(Initial_value_P1Int));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 Initial_value_P1 ") +
    //                                           QString::number(Initial_value_P1Int));
                  }

                  paramsVector.append(Initial_value_P1Array);
                  mapRead["Initial_value_P1ByteArray"] = Initial_value_P1Array;

                  //
                  //Service_P1  16-19
                  QByteArray Service_P1Array;
                  Service_P1Array.append(buffer[16]);
                  Service_P1Array.append(buffer[17]);
                  Service_P1Array.append(buffer[18]);
                  Service_P1Array.append(buffer[19]);

                  qDebug()<<"Service_P1Array.toHex() "<<Service_P1Array.toHex();

                  quint32 Service_P1Int = (quint8)buffer[16];
                  Service_P1Int = Service_P1Int<<8 | (quint8)buffer[17];
                  Service_P1Int = Service_P1Int<<8 | (quint8)buffer[18];
                  Service_P1Int = Service_P1Int<<8 | (quint8)buffer[19];

                  if(Service_P1Int == 0x00000000) {
                      ui->lineEdit_Service_P1->setText(QString::number(Service_P1Int, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 1 Service_P1 ") +
    //                                           QString::number(Service_P1Int, 16));
                  }

                  paramsVector.append(Service_P1Array);
                  mapRead["Service_P1ByteArray"] = Service_P1Array;

                  //
                  //Serial P2
                  QByteArray Serial_P2Array;
                  Serial_P2Array.append(buffer[20]);
                  Serial_P2Array.append(buffer[21]);
                  Serial_P2Array.append(buffer[22]);
                  Serial_P2Array.append(buffer[23]);
                  qDebug()<<"Serial_P2Array.toHex() "<<Serial_P2Array.toHex();

                  quint32 Serial_P2Quint32 = (quint8)buffer[20];
                  Serial_P2Quint32 = Serial_P2Quint32<<8 | (quint8)buffer[21];
                  Serial_P2Quint32 = Serial_P2Quint32<<8 | (quint8)buffer[22];
                  Serial_P2Quint32 = Serial_P2Quint32<<8 | (quint8)buffer[23];

                  if(Serial_P2Quint32 == 0x00000000) {
                      ui->lineEdit_Serial_P2->setText(QString::number(Serial_P2Quint32, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 Serial_P2 ")
    //                                           + QString::number(Serial_P2Quint32, 16));
                  }

                  paramsVector.append(Serial_P2Array);
                  mapRead["Serial_P2ByteArray"] = Serial_P2Array;

                  //
                  //ManCode P2
                  QByteArray ManCode_P2Array;
                  ManCode_P2Array.append(buffer[24]);
                  ManCode_P2Array.append(buffer[25]);
                  qDebug()<<"ManCode_P2Array.toHex() "<<ManCode_P2Array.toHex();

                  quint16 ManCode_P2Quint16 = (quint8)buffer[24];
                  ManCode_P2Quint16 = ManCode_P2Quint16<<8 | (quint8)buffer[25];

                  if(ManCode_P2Quint16 == 0x0000) {
                      ui->lineEdit_ManCode_P2->setText(QString::number(ManCode_P2Quint16, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 ManCode_P2 ")
    //                                           + QString::number(ManCode_P2Quint16, 16));
                  }

                  paramsVector.append(ManCode_P2Array);
                  mapRead["ManCode_P2ByteArray"] = ManCode_P2Array;

                  //
                  //DevType P2
                  QByteArray DevType_P2Array;
                  DevType_P2Array.append(buffer[26]);
                  qDebug()<<"DevType_P2Array.toHex() "<<DevType_P2Array.toHex();

                  quint8 DevType_P2Int = (quint8)buffer[26];

                  if(DevType_P2Int == 0x00) {
                      ui->lineEdit_DevType_P2->setText(QString::number(DevType_P2Int, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 DevType_P2 ") +
    //                                           QString::number(DevType_P2Int, 16));
                  }

                  paramsVector.append(DevType_P2Array);
                  mapRead["DevType_P2ByteArray"] = DevType_P2Array;

                  //
                  //Version P2
                  QByteArray Version_P2Array;
                  Version_P2Array.append(buffer[27]);
                  qDebug()<<"Version_P2Array.toHex() "<<Version_P2Array.toHex();

                  quint8 Version_P2Int = (quint8)buffer[27];

                  if(Version_P2Int == 0) {
                      ui->lineEdit_Version_P2->setText(QString::number(Version_P2Int, 10));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 Version_P2 ") +
    //                                           QString::number(Version_P2Int, 10));
                  }

                  paramsVector.append(Version_P2Array);
                  mapRead["Version_P2ByteArray"] = Version_P2Array;

                  //
                  //Initial value P2
                  QByteArray Initial_value_P2Array;
                  Initial_value_P2Array.append(buffer[28]);
                  Initial_value_P2Array.append(buffer[29]);
                  Initial_value_P2Array.append(buffer[30]);
                  Initial_value_P2Array.append(buffer[31]);

                  qDebug()<<"Initial_value_P2Array.toHex() "<<Initial_value_P2Array.toHex();

                  quint32 Initial_value_P2Int = (quint8)buffer[28];
                  Initial_value_P2Int = Initial_value_P2Int<<8 | (quint8)buffer[29];
                  Initial_value_P2Int = Initial_value_P2Int<<8 | (quint8)buffer[30];
                  Initial_value_P2Int = Initial_value_P2Int<<8 | (quint8)buffer[31];

                  if(Initial_value_P2Int == 0) {
                      ui->lineEdit_Initial_value_P2->setText(QString::number(Initial_value_P2Int));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 Initial_value_P2 ") +
    //                                           QString::number(Initial_value_P2Int));
                  }

                  paramsVector.append(Initial_value_P2Array);
                  mapRead["Initial_value_P2ByteArray"] = Initial_value_P2Array;

                  //
                  //Service P2   32-35
                  QByteArray Service_P2Array;
                  Service_P2Array.append(buffer[32]);
                  Service_P2Array.append(buffer[33]);
                  Service_P2Array.append(buffer[34]);
                  Service_P2Array.append(buffer[35]);

                  qDebug()<<"Service_P2Array.toHex() "<<Service_P2Array.toHex();

                  quint32 Service_P2Int = (quint8)buffer[32];
                  Service_P2Int = Service_P2Int<<8 | (quint8)buffer[33];
                  Service_P2Int = Service_P2Int<<8 | (quint8)buffer[34];
                  Service_P2Int = Service_P2Int<<8 | (quint8)buffer[35];

                  if(Service_P2Int == 0x00000000) {
                      ui->lineEdit_Service_P2->setText(QString::number(Service_P2Int, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Параметр счётчика, подключенного к счётному входу 2 Service_P2 ") +
    //                                           QString::number(Service_P2Int, 16));
                  }

                  paramsVector.append(Service_P2Array);
                  mapRead["Service_P2ByteArray"] = Service_P2Array;

                  //
                  //





                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка данных") + ". Рабочее место: " + QString::number(workPlaceNumber + 1));
//                      portTmp->close();
                      ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIsErrorOccured[workPlaceNumber] = true;
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }


//     portTmp->close();


        checkWritingError(currentIndicatorNumber);


}
/**********************************************************/
void MainWindow::writeParams2(int workPlaceNumber)
{
    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

    workPlaceNumber = 1;

    if(!vectorIsWorkPlaceUse.at(1)) return;

//    indicatorReset();

//    repaint();



    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }

    portTmp->setBaudRate(QSerialPort::Baud19200);
    portTmp->setDataBits(QSerialPort::Data8);
    portTmp->setParity(QSerialPort::NoParity);
    portTmp->setStopBits(QSerialPort::OneStop);


    currentBoxNumber = 0;
    vectorIsErrorOccured[workPlaceNumber] = false;

    //


    switch (workPlaceNumber) {
    case 0:
        timerWriteParams.start(10000);
        break;
    case 1:
        timerWriteParams2.start(10000);
        break;
    case 2:
        timerWriteParams3.start(10000);
        break;
    case 3:
        timerWriteParams4.start(10000);
        break;

    default:
        break;
    }
  //      timerWriteParams.start(10000);

        bool ok;
        ProtTypeByteArray.clear();
        quint8 byteProtType = 0xff;
        ProtTypeByteArray.append(byteProtType);

        ui->label_writeParams->setVisible(false);
        ui->label_Calibration->setVisible(false);
        ui->label_pulsesOutputHeat->setVisible(false);
        ui->label_pulsesInputVolume->setVisible(false);
        ui->label_pulsesOutputOff->setVisible(false);
        ui->label_MBusOn->setVisible(false);
        ui->label_MBusOff->setVisible(false);
        ui->label_CheckMbus->setVisible(false);
        ui->label_digitalWireInterfaceChecking->setVisible(false);
        ui->label_RMV_ErrorFlags_tick->setVisible(false);
        ui->label_calibrationModeOff->setVisible(false);
        ui->label_realClockCalibration->setVisible(false);

        ui->lineEdit_RMV_ErrorFlags->setText("");

        //
        //индикатор
        QColor color(255, 127, 50);
        ui->label_writeParams->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_writeParams->setText("X");
        ui->label_writeParams->setVisible(false);
        //
        //

        ui->label_StatusBar->setText("");

        //
        pulsesMode1ByteArray.clear();
        pulsesMode2ByteArray.clear();

        pulsesMode1ByteArray.append(pulsesMode1PrimalInt); //append(byte);
        pulsesMode2ByteArray.append(pulsesMode2PrimalInt); //append(byte);
        //
        //
        if(pulsesValue1PrimeInt == 0) {
  //          QMessageBox::information(this, "", tr("Недопустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt));
            ui->label_StatusBar->setText(tr("Недопустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt) +
                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text() + '\n');
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkWritingError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
            return;
        }
        if(pulsesValue2PrimeInt == 0) {
 //           QMessageBox::information(this, "", tr("Недопустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt));
            ui->label_StatusBar->setText(tr("Недопустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt) +
                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text() + '\n');
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkWritingError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
            return;
        }
        pulsesValue1ByteArray.clear();
        pulsesValue2ByteArray.clear();
        pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt>>8));
        pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt));

        pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt>>8));
        pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt));
        //

        bool isWritingCorrect = false;

        paramsVectorToWrite.clear();

        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
//                QMessageBox::information(this, "", "Не удалось открыть порт УСО-2. Рабочее место: " +
//                                         QString::number(workPlaceNumber + 1) );
                ui->label_StatusBar->setText("Не удалось открыть порт УСО-2. Рабочее место: " +
                                             QString::number(workPlaceNumber + 1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkWritingError(currentIndicatorNumber);
                workPlaceOff(currentIndicatorNumber);
                return;
            }
        }


        //
        //Set Password Default 5a 00 07 42 23 17
        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x07;
           packetToRead.append(byte);
           byte = 0x42;
           packetToRead.append(byte);
           byte = 0x23;
           packetToRead.append(byte);
           byte = 0x17;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
//                   QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка установки пароля по умолчанию") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc2;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);



                  //
                  //



                  break;
               }
               else {
                        if(i==9) {
//                            QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию") +
//                                                     "Рабочее место: " + QString::number(workPlaceNumber+1));
                            ui->label_StatusBar->setText(tr("Ошибка установки пароля по умолчанию") +
                                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            ui->label_writeParams->setVisible(true);
                            vectorIsErrorOccured[workPlaceNumber] = true;
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkWritingError(currentIndicatorNumber);
                            workPlaceOff(currentIndicatorNumber);

                            return;
                        }

               }



           }


        }

        //
        //Set Password Default 5a 00 07 42 23 17/


        //
        //Открыть парольную сессию 5a 00 08 40 01 04 57
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x08;
           packetToRead.append(byte);
           byte = 0x40;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);
           byte = 0x04;
           packetToRead.append(byte);
           byte = 0x57;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(110);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc0;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);


                  //
                  //



                  break;
               }
               else {
                        if(i==2) {
//                            QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                                     "Рабочее место: " + QString::number(workPlaceNumber+1));
                            ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            ui->label_writeParams->setVisible(true);
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkWritingError(currentIndicatorNumber);
                            workPlaceOff(currentIndicatorNumber);

                            return;
                        }

               }



           }


        }

        //
        //Открыть парольную сессию 5a 00 08 40 01 04 57/


        //
        //Write Hardware Configuration 5a 00 15 29 serial(4) manCode(2) devType(1) DN(1)
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x15;
           packetToRead.append(byte);
           byte = 0x29;
           packetToRead.append(byte);

           //
           switch (workPlaceNumber) {
           case 0:
                byte = serialNumber[0];
                packetToRead.append(byte);
                byte = serialNumber[1];
                packetToRead.append(byte);
                byte = serialNumber[2];
                packetToRead.append(byte);
                byte = serialNumber[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber);
                mapwrite["serialNumber"] = serialNumber;
               break;
           case 1:
                byte = serialNumber2[0];
                packetToRead.append(byte);
                byte = serialNumber2[1];
                packetToRead.append(byte);
                byte = serialNumber2[2];
                packetToRead.append(byte);
                byte = serialNumber2[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber2);
                mapwrite["serialNumber2"] = serialNumber2;
               break;
           case 2:
                byte = serialNumber3[0];
                packetToRead.append(byte);
                byte = serialNumber3[1];
                packetToRead.append(byte);
                byte = serialNumber3[2];
                packetToRead.append(byte);
                byte = serialNumber3[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber3);
                mapwrite["serialNumber3"] = serialNumber3;
               break;
           case 3:
                byte = serialNumber4[0];
                packetToRead.append(byte);
                byte = serialNumber4[1];
                packetToRead.append(byte);
                byte = serialNumber4[2];
                packetToRead.append(byte);
                byte = serialNumber4[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber4);
                mapwrite["serialNumber4"] = serialNumber4;
               break;
           default:
               break;
           }
           //


           byte = manCode[0];
           packetToRead.append(byte);
           byte = manCode[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(manCode);
           mapwrite["manCode"] = manCode;


           byte = devType[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(devType);
           mapwrite["devType"] = devType;


           byte = DN[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DN);
           mapwrite["DN"] = DN;


           //
           switch (workPlaceNumber) {
           case 0:
               byte = PCB_SN_ByteArray[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray);
               mapwrite["PCB_SN_ByteArray"] = PCB_SN_ByteArray;
              break;
           case 1:
               byte = PCB_SN_ByteArray2[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray2);
               mapwrite["PCB_SN_ByteArray2"] = PCB_SN_ByteArray2;
              break;
           case 2:
               byte = PCB_SN_ByteArray3[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray3);
               mapwrite["PCB_SN_ByteArray3"] = PCB_SN_ByteArray3;
              break;
           case 3:
               byte = PCB_SN_ByteArray4[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray4);
               mapwrite["PCB_SN_ByteArray4"] = PCB_SN_ByteArray4;
              break;
           default:
              break;
           }


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Hardware Configuration") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Hardware Configuration ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa9;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                         if(i==2) {
//                             QMessageBox::information(this, "", tr("Ошибка записи данных : Hardware Configuration ") +
//                                                      "Рабочее место: " + QString::number(workPlaceNumber+1));
                             ui->label_StatusBar->setText(tr("Ошибка записи данных : Hardware Configuration ") +
                                                          ". Рабочее место: " + QString::number(workPlaceNumber+1));
                             errorString.append(ui->label_StatusBar->text() + '\n');
                             ui->label_writeParams->setVisible(true);
                             vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                             checkWritingError(currentIndicatorNumber);
                             workPlaceOff(currentIndicatorNumber);
                             return;
                         }

               }



           }


        }

        //
        //Write Software Configuration 5a 00 16 20
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x16;
           packetToRead.append(byte);
           byte = 0x20;
           packetToRead.append(byte);

           byte = flowMinByteArray[0];
           packetToRead.append(byte);
           byte = flowMinByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMinByteArray);
           mapwrite["flowMinByteArray"] = flowMinByteArray;


           byte = flowMaxByteArray[0];
           packetToRead.append(byte);
           byte = flowMaxByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMaxByteArray);
           mapwrite["flowMaxByteArray"] = flowMaxByteArray;


           byte = tinMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMinByteArray);
           mapwrite["tinMinByteArray"] = tinMinByteArray;


           byte = tinMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMaxByteArray);
           mapwrite["tinMaxByteArray"] = tinMaxByteArray;


           byte = toutMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMinByteArray);
           mapwrite["toutMinByteArray"] = toutMinByteArray;


           byte = toutMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMaxByteArray);
           mapwrite["toutMaxByteArray"] = toutMaxByteArray;


           byte = reportDataByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(reportDataByteArray);
           mapwrite["reportDataByteArray"] = reportDataByteArray;


           byte = averageTByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(averageTByteArray);
           mapwrite["averageTByteArray"] = averageTByteArray;


           byte = pulsesMode1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode1ByteArray);
           mapwrite["pulsesMode1ByteArray"] = pulsesMode1ByteArray;


           byte = pulsesMode2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode2ByteArray);
           mapwrite["pulsesMode2ByteArray"] = pulsesMode2ByteArray;


    //       quint16 pulseV1Int = (quint8)pulsesValue1ByteArray[0];
    //       pulseV1Int = pulseV1Int | (quint8)pulsesValue1ByteArray[1];
    //       if(pulseV1Int == 0) {
    //           QMessageBox::information(this, "", tr("Недопустимое для записи значение: pulsesValue1 ") + QString::number(pulseV1Int));
    //           return;
    //       }
           byte = pulsesValue1ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue1ByteArray);
           mapwrite["pulsesValue1ByteArray"] = pulsesValue1ByteArray;


    //       quint16 pulseV2Int = (quint8)pulsesValue2ByteArray[0];
    //       pulseV2Int = pulseV2Int | (quint8)pulsesValue2ByteArray[1];
    //       if(pulseV2Int == 0) {
    //           QMessageBox::information(this, "", tr("Недопустимое для записи значение: pulsesValue2 ") + QString::number(pulseV2Int));
    //           return;
    //       }
           byte = pulsesValue2ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue2ByteArray);
           mapwrite["pulsesValue2ByteArray"] = pulsesValue2ByteArray;

           byte = devType[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(devType);
           mapwrite["devType"] = devType;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"porTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);;//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Software Configuration ") +
//                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Software Configuration ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa0;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Software Configuration ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Software Configuration ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Sensor Parameters 5a 00 18 2d
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x18;
           packetToRead.append(byte);
           byte = 0x2d;
           packetToRead.append(byte);

           byte = flowRateByteArray[0];
           packetToRead.append(byte);
           byte = flowRateByteArray[1];
           packetToRead.append(byte);
           byte = flowRateByteArray[2];
           packetToRead.append(byte);
           byte = flowRateByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowRateByteArray);
           mapwrite["flowRateByteArray"] = flowRateByteArray;


           byte = pressureByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pressureByteArray);
           mapwrite["pressureByteArray"] = pressureByteArray;


           byte = RTD_TypeByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RTD_TypeByteArray);
           mapwrite["RTD_TypeByteArray"] = RTD_TypeByteArray;


           byte = R_RTDByteArray[0];
           packetToRead.append(byte);
           byte = R_RTDByteArray[1];
           packetToRead.append(byte);
           byte = R_RTDByteArray[2];
           packetToRead.append(byte);
           byte = R_RTDByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(R_RTDByteArray);

           quint32 r_rtdInt = (quint8)R_RTDByteArray[0];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[1];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[2];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[3];

           r_rtdInt = r_rtdInt/1000;

           QByteArray r_rtd_NotMultiplicationByteArray;
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>24));
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>16));
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>8));
           r_rtd_NotMultiplicationByteArray.append((quint8)r_rtdInt);
           mapwrite["R_RTDByteArray"] = r_rtd_NotMultiplicationByteArray; //проверять нужно неумноженное значение


           byte = RWire1ByteArray[0];
           packetToRead.append(byte);
           byte = RWire1ByteArray[1];
           packetToRead.append(byte);
           byte = RWire1ByteArray[2];
           packetToRead.append(byte);
           byte = RWire1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RWire1ByteArray);
           mapwrite["RWire1ByteArray"] = RWire1ByteArray;


           byte = RWire2ByteArray[0];
           packetToRead.append(byte);
           byte = RWire2ByteArray[1];
           packetToRead.append(byte);
           byte = RWire2ByteArray[2];
           packetToRead.append(byte);
           byte = RWire2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RWire2ByteArray);
           mapwrite["RWire2ByteArray"] = RWire2ByteArray;


           byte = flowNomByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowNomByteArray);
           mapwrite["flowNomByteArray"] = flowNomByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Sensor Parameters ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Sensor Parameters ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xad;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Sensor Parameters ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Sensor Parameters ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Flow Coefficient 5a 00 1d 3d
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x1d;
           packetToRead.append(byte);
           byte = 0x3d;
           packetToRead.append(byte);

           byte = flowCoef0ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef0ByteArray);
           mapwrite["flowCoef0ByteArray"] = flowCoef0ByteArray;


           byte = flowCoef1ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef1ByteArray);
           mapwrite["flowCoef1ByteArray"] = flowCoef1ByteArray;


           byte = flowCoef2ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef2ByteArray);
           mapwrite["flowCoef2ByteArray"] = flowCoef2ByteArray;


           byte = flowCoef3ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef3ByteArray);
           mapwrite["flowCoef3ByteArray"] = flowCoef3ByteArray;


           byte = flowCoef4ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef4ByteArray);
           mapwrite["flowCoef4ByteArray"] = flowCoef4ByteArray;


           byte = flowCoef5ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef5ByteArray);
           mapwrite["flowCoef5ByteArray"] = flowCoef5ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Flow Coefficient") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Flow Coefficient ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbd;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Flow Coefficient ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Flow Coefficient ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Differential Threshold 5a 00 07 3e
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x07;
           packetToRead.append(byte);
           byte = 0x3e;
           packetToRead.append(byte);

           byte = FS_DiffThrsByteArray[0];
           packetToRead.append(byte);
           byte = FS_DiffThrsByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(FS_DiffThrsByteArray);
           mapwrite["FS_DiffThrsByteArray"] = FS_DiffThrsByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Differential Threshold ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Differential Threshold ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbe;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Differential Threshold ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Differential Threshold ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Real Clock 5a 00 0d 22
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x0d;
           packetToRead.append(byte);
           byte = 0x22;
           packetToRead.append(byte);

           byte = hourByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(hourByteArray);
           mapwrite["hourByteArray"] = hourByteArray;


           byte = minuteByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(minuteByteArray);
           mapwrite["minuteByteArray"] = minuteByteArray;


           byte = secondByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(secondByteArray);
           mapwrite["secondByteArray"] = secondByteArray;

           byte = dayByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(dayByteArray);
           mapwrite["dayByteArray"] = dayByteArray;


           byte = monthByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(monthByteArray);
           mapwrite["monthByteArray"] = monthByteArray;


           byte = yearByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(yearByteArray);
           mapwrite["yearByteArray"] = yearByteArray;


           byte = DOWByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DOWByteArray);
           mapwrite["DOWByteArray"] = DOWByteArray;


           byte = ASW_flagByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ASW_flagByteArray);
           mapwrite["ASW_flagByteArray"] = ASW_flagByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Real Clock ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Real Clock ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa2;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Real Clock ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Real Clock ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Temperature Calibration Coefficient 5a 00 11 36
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x11;
           packetToRead.append(byte);
           byte = 0x36;
           packetToRead.append(byte);

           byte = shift_T1ByteArray[0];
           packetToRead.append(byte);
           byte = shift_T1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(shift_T1ByteArray);
           mapwrite["shift_T1ByteArray"] = shift_T1ByteArray;


           byte = shift_T2ByteArray[0];
           packetToRead.append(byte);
           byte = shift_T2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(shift_T2ByteArray);
           mapwrite["shift_T2ByteArray"] = shift_T2ByteArray;


           byte = scale_T1ByteArray[0];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[1];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[2];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(scale_T1ByteArray);
           mapwrite["scale_T1ByteArray"] = scale_T1ByteArray;


           byte = scale_T2ByteArray[0];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[1];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[2];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(scale_T2ByteArray);
           mapwrite["scale_T2ByteArray"] = scale_T2ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Temperature Calibration Coefficient ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Temperature Calibration Coefficient ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xb6;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных: Temperature Calibration Coefficient") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных: Temperature Calibration Coefficient ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write External Interface Settings 5a 00 0e 2b
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x0e;
           packetToRead.append(byte);
           byte = 0x2b;
           packetToRead.append(byte);

           byte = addrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(addrByteArray);
           mapwrite["addrByteArray"] = addrByteArray;


           byte = baudRateByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(baudRateByteArray);
           mapwrite["baudRateByteArray"] = baudRateByteArray;


           byte = HMP_TransByteArray[0];
           packetToRead.append(byte);
           byte = HMP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(HMP_TransByteArray);
           mapwrite["HMP_TransByteArray"] = HMP_TransByteArray;


           byte = EPP_TransByteArray[0];
           packetToRead.append(byte);
           byte = EPP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(EPP_TransByteArray);
           mapwrite["EPP_TransByteArray"] = EPP_TransByteArray;


           byte = P1PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P1PrimAddrByteArray);
           mapwrite["P1PrimAddrByteArray"] = P1PrimAddrByteArray;


           byte = P2PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P2PrimAddrByteArray);
           mapwrite["P2PrimAddrByteArray"] = P2PrimAddrByteArray;


           byte = ProtTypeByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ProtTypeByteArray);
           mapwrite["ProtTypeByteArray"] = ProtTypeByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Interface Settings ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : External Interface Settings ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xab;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                       QMessageBox::information(this, "", tr("Ошибка записи данных : External Interface Settings ") +
//                                                "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : External Interface Settings ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write External Device Settings  5a 00 25 3c
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x25;
           packetToRead.append(byte);
           byte = 0x3c;
           packetToRead.append(byte);

           byte = Serial_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Serial_P1ByteArray);
           mapwrite["Serial_P1ByteArray"] = Serial_P1ByteArray;


           byte = ManCode_P1ByteArray[0];
           packetToRead.append(byte);
           byte = ManCode_P1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ManCode_P1ByteArray);
           mapwrite["ManCode_P1ByteArray"] = ManCode_P1ByteArray;


           byte = DevType_P1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DevType_P1ByteArray);
           mapwrite["DevType_P1ByteArray"] = DevType_P1ByteArray;


           byte = Version_P1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Version_P1ByteArray);
           mapwrite["Version_P1ByteArray"] = Version_P1ByteArray;


           byte = Initial_value_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Initial_value_P1ByteArray);
           mapwrite["Initial_value_P1ByteArray"] = Initial_value_P1ByteArray;


           byte = Service_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Service_P1ByteArray);
           mapwrite["Service_P1ByteArray"] = Service_P1ByteArray;


           byte = Serial_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Serial_P2ByteArray);
           mapwrite["Serial_P2ByteArray"] = Serial_P2ByteArray;


           byte = ManCode_P2ByteArray[0];
           packetToRead.append(byte);
           byte = ManCode_P2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ManCode_P2ByteArray);
           mapwrite["ManCode_P2ByteArray"] = ManCode_P2ByteArray;


           byte = DevType_P2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DevType_P2ByteArray);
           mapwrite["DevType_P2ByteArray"] = DevType_P2ByteArray;


           byte = Version_P2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Version_P2ByteArray);
           mapwrite["Version_P2ByteArray"] = Version_P2ByteArray;


           byte = Initial_value_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Initial_value_P2ByteArray);
           mapwrite["Initial_value_P2ByteArray"] = Initial_value_P2ByteArray;


           byte = Service_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Service_P2ByteArray);
           mapwrite["Service_P2ByteArray"] = Service_P2ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Device Settings ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : External Device Settings ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbc;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : External Device Settings") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : External Device Settings ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }



        //
        //
        //проверка записанного. из списка проверяемых параметров удаляем те серийный номера и PCB_SN, которые не являются текущим для рабочего места

//        on_toolButton_readParams_clicked();

        readParams(workPlaceNumber);



        allParamsNameList.removeOne("minuteByteArray");
        allParamsNameList.removeOne("secondByteArray");
        allParamsNameList.removeOne("hourByteArray");

        switch (workPlaceNumber) {
        case 0:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 1:
           mapwrite["serialNumber"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 2:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 3:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
            break;
        default:
            break;
        }



        for(int i=0; i<allParamsNameList.size(); i++) {
            qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
            qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();

            if((allParamsNameList[i] != "pulsesValue1ByteArray") && (allParamsNameList[i] != "pulsesValue2ByteArray")) {
               if(mapwrite[allParamsNameList[i]] != mapRead[allParamsNameList[i]]) {
//                   QMessageBox::information(this, "", "Параметр записан некорректно : " +
//                                            allParamsNameList[i] + " " + mapRead[allParamsNameList[i]].toHex());
                   ui->label_StatusBar->setText(tr("Параметр записан некорректно : ") + allParamsNameList[i] + " " +
                                                mapRead[allParamsNameList[i]].toHex() +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
//                   ui->label_StatusBar->setText("Запись : Неудачно");
//                   ui->label_writeParams->setVisible(true);
                   return;
               }
            }

            //pulsesValue1
            if(allParamsNameList[i] == "pulsesValue1ByteArray") {
                quint16 pulsesValue1IntRead = mapRead["pulsesValue1ByteArray"].at(0);
                pulsesValue1IntRead = pulsesValue1IntRead<<8 | mapRead["pulsesValue1ByteArray"].at(1);

                quint16 pulsesValue1IntWrite = mapwrite["pulsesValue1ByteArray"].at(0);
                pulsesValue1IntWrite = pulsesValue1IntWrite<<8 | mapwrite["pulsesValue1ByteArray"].at(1);

                if((pulsesValue1IntRead <= (pulsesValue1IntWrite + 1)) && (pulsesValue1IntRead >= (pulsesValue1IntWrite - 1))) {

                }
                else {
//                    QMessageBox::information(this, "", "Параметр записан некорректно : pulsesValue1 " +
//                                             QString::number(pulsesValue1IntRead));
                    ui->label_StatusBar->setText(tr("Параметр записан некорректно : pulsesValue1 ") +
                                                 QString::number(pulsesValue1IntRead) +
                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
                    errorString.append(ui->label_StatusBar->text() + '\n');
                    vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                    checkWritingError(currentIndicatorNumber);
                    workPlaceOff(currentIndicatorNumber);
//                    ui->label_StatusBar->setText("Запись : Неудачно");
//                    ui->label_writeParams->setVisible(true);
                    return;
                }
            }

            //pulsesValue2
            if(allParamsNameList[i] == "pulsesValue2ByteArray") {
                quint16 pulsesValue2IntRead = mapRead["pulsesValue2ByteArray"].at(0);
                pulsesValue2IntRead = pulsesValue2IntRead<<8 | mapRead["pulsesValue2ByteArray"].at(1);

                quint16 pulsesValue2IntWrite = mapwrite["pulsesValue2ByteArray"].at(0);
                pulsesValue2IntWrite = pulsesValue2IntWrite<<8 | mapwrite["pulsesValue2ByteArray"].at(1);

                if((pulsesValue2IntRead <= (pulsesValue2IntWrite + 1)) && (pulsesValue2IntRead >= (pulsesValue2IntWrite - 1))) {

                }
                else {
//                    QMessageBox::information(this, "", "Параметр записан некорректно : pulsesValue2 " +
//                                             QString::number(pulsesValue2IntRead));
                    ui->label_StatusBar->setText(tr("Параметр записан некорректно : pulsesValue2 ") +
                                                 QString::number(pulsesValue2IntRead) +
                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
                    errorString.append(ui->label_StatusBar->text() + '\n');
                    vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                    checkWritingError(currentIndicatorNumber);
                    workPlaceOff(currentIndicatorNumber);
//                    ui->label_StatusBar->setText("Запись : Неудачно");
//                    ui->label_writeParams->setVisible(true);
                    return;
                }
            }

        }

  //      ui->label_StatusBar->setText("Запись : Успешно ");

        ui->label_writeParams->setStyleSheet(QString("color: green").arg(color.name()));
        ui->label_writeParams->setText("V");
  //      ui->label_writeParams->setVisible(true);



//        vectorIsErrorOccured[workPlaceNumber] = true;



//        isNeedPaintEvent = true;
//        switch (currentIndicatorNumber) {
//        case 0:
//            isWritingFinished1 = true;
//            break;
//        case 1:
//            isWritingFinished2 = true;
//            break;
//        case 2:
//            isWritingFinished3 = true;
//            break;
//        case 3:
//            isWritingFinished4 = true;
//            break;
//        default:
//            break;
//        }
//        repaint();
//        isNeedPaintEvent = false;

        checkWritingError(currentIndicatorNumber);



}

/**********************************************************/
void MainWindow::writeParams3(int workPlaceNumber)
{
    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

    workPlaceNumber = 2;

    if(!vectorIsWorkPlaceUse.at(2)) return;

//    indicatorReset();

//    repaint();



    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }

    portTmp->setBaudRate(QSerialPort::Baud19200);
    portTmp->setDataBits(QSerialPort::Data8);
    portTmp->setParity(QSerialPort::NoParity);
    portTmp->setStopBits(QSerialPort::OneStop);


    currentBoxNumber = 0;
    vectorIsErrorOccured[workPlaceNumber] = false;

    //


    switch (workPlaceNumber) {
    case 0:
        timerWriteParams.start(10000);
        break;
    case 1:
        timerWriteParams2.start(10000);
        break;
    case 2:
        timerWriteParams3.start(10000);
        break;
    case 3:
        timerWriteParams4.start(10000);
        break;

    default:
        break;
    }
  //      timerWriteParams.start(10000);

        bool ok;
        ProtTypeByteArray.clear();
        quint8 byteProtType = 0xff;
        ProtTypeByteArray.append(byteProtType);

        ui->label_writeParams->setVisible(false);
        ui->label_Calibration->setVisible(false);
        ui->label_pulsesOutputHeat->setVisible(false);
        ui->label_pulsesInputVolume->setVisible(false);
        ui->label_pulsesOutputOff->setVisible(false);
        ui->label_MBusOn->setVisible(false);
        ui->label_MBusOff->setVisible(false);
        ui->label_CheckMbus->setVisible(false);
        ui->label_digitalWireInterfaceChecking->setVisible(false);
        ui->label_RMV_ErrorFlags_tick->setVisible(false);
        ui->label_calibrationModeOff->setVisible(false);
        ui->label_realClockCalibration->setVisible(false);

        ui->lineEdit_RMV_ErrorFlags->setText("");

        //
        //индикатор
        QColor color(255, 127, 50);
        ui->label_writeParams->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_writeParams->setText("X");
        ui->label_writeParams->setVisible(false);
        //
        //

        ui->label_StatusBar->setText("");

        //
        pulsesMode1ByteArray.clear();
        pulsesMode2ByteArray.clear();

        pulsesMode1ByteArray.append(pulsesMode1PrimalInt); //append(byte);
        pulsesMode2ByteArray.append(pulsesMode2PrimalInt); //append(byte);
        //
        //
        if(pulsesValue1PrimeInt == 0) {
  //          QMessageBox::information(this, "", tr("Недопустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt));
            ui->label_StatusBar->setText(tr("Недопустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt) +
                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text() + '\n');
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkWritingError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
            return;
        }
        if(pulsesValue2PrimeInt == 0) {
 //           QMessageBox::information(this, "", tr("Недопустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt));
            ui->label_StatusBar->setText(tr("Недопустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt) +
                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text() + '\n');
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkWritingError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
            return;
        }
        pulsesValue1ByteArray.clear();
        pulsesValue2ByteArray.clear();
        pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt>>8));
        pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt));

        pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt>>8));
        pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt));
        //

        bool isWritingCorrect = false;

        paramsVectorToWrite.clear();

        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
//                QMessageBox::information(this, "", "Не удалось открыть порт УСО-2. Рабочее место: " +
//                                         QString::number(workPlaceNumber + 1) );
                ui->label_StatusBar->setText("Не удалось открыть порт УСО-2. Рабочее место: " +
                                             QString::number(workPlaceNumber + 1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkWritingError(currentIndicatorNumber);
                workPlaceOff(currentIndicatorNumber);
                return;
            }
        }


        //
        //Set Password Default 5a 00 07 42 23 17
        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x07;
           packetToRead.append(byte);
           byte = 0x42;
           packetToRead.append(byte);
           byte = 0x23;
           packetToRead.append(byte);
           byte = 0x17;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
//                   QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка установки пароля по умолчанию") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc2;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);



                  //
                  //



                  break;
               }
               else {
                        if(i==9) {
//                            QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию") +
//                                                     "Рабочее место: " + QString::number(workPlaceNumber+1));
                            ui->label_StatusBar->setText(tr("Ошибка установки пароля по умолчанию") +
                                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            ui->label_writeParams->setVisible(true);
                            vectorIsErrorOccured[workPlaceNumber] = true;
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkWritingError(currentIndicatorNumber);
                            workPlaceOff(currentIndicatorNumber);

                            return;
                        }

               }



           }


        }

        //
        //Set Password Default 5a 00 07 42 23 17/


        //
        //Открыть парольную сессию 5a 00 08 40 01 04 57
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x08;
           packetToRead.append(byte);
           byte = 0x40;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);
           byte = 0x04;
           packetToRead.append(byte);
           byte = 0x57;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(110);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc0;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);


                  //
                  //



                  break;
               }
               else {
                        if(i==2) {
//                            QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                                     "Рабочее место: " + QString::number(workPlaceNumber+1));
                            ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            ui->label_writeParams->setVisible(true);
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkWritingError(currentIndicatorNumber);
                            workPlaceOff(currentIndicatorNumber);

                            return;
                        }

               }



           }


        }

        //
        //Открыть парольную сессию 5a 00 08 40 01 04 57/


        //
        //Write Hardware Configuration 5a 00 15 29 serial(4) manCode(2) devType(1) DN(1)
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x15;
           packetToRead.append(byte);
           byte = 0x29;
           packetToRead.append(byte);

           //
           switch (workPlaceNumber) {
           case 0:
                byte = serialNumber[0];
                packetToRead.append(byte);
                byte = serialNumber[1];
                packetToRead.append(byte);
                byte = serialNumber[2];
                packetToRead.append(byte);
                byte = serialNumber[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber);
                mapwrite["serialNumber"] = serialNumber;
               break;
           case 1:
                byte = serialNumber2[0];
                packetToRead.append(byte);
                byte = serialNumber2[1];
                packetToRead.append(byte);
                byte = serialNumber2[2];
                packetToRead.append(byte);
                byte = serialNumber2[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber2);
                mapwrite["serialNumber2"] = serialNumber2;
               break;
           case 2:
                byte = serialNumber3[0];
                packetToRead.append(byte);
                byte = serialNumber3[1];
                packetToRead.append(byte);
                byte = serialNumber3[2];
                packetToRead.append(byte);
                byte = serialNumber3[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber3);
                mapwrite["serialNumber3"] = serialNumber3;
               break;
           case 3:
                byte = serialNumber4[0];
                packetToRead.append(byte);
                byte = serialNumber4[1];
                packetToRead.append(byte);
                byte = serialNumber4[2];
                packetToRead.append(byte);
                byte = serialNumber4[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber4);
                mapwrite["serialNumber4"] = serialNumber4;
               break;
           default:
               break;
           }
           //


           byte = manCode[0];
           packetToRead.append(byte);
           byte = manCode[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(manCode);
           mapwrite["manCode"] = manCode;


           byte = devType[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(devType);
           mapwrite["devType"] = devType;


           byte = DN[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DN);
           mapwrite["DN"] = DN;


           //
           switch (workPlaceNumber) {
           case 0:
               byte = PCB_SN_ByteArray[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray);
               mapwrite["PCB_SN_ByteArray"] = PCB_SN_ByteArray;
              break;
           case 1:
               byte = PCB_SN_ByteArray2[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray2);
               mapwrite["PCB_SN_ByteArray2"] = PCB_SN_ByteArray2;
              break;
           case 2:
               byte = PCB_SN_ByteArray3[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray3);
               mapwrite["PCB_SN_ByteArray3"] = PCB_SN_ByteArray3;
              break;
           case 3:
               byte = PCB_SN_ByteArray4[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray4);
               mapwrite["PCB_SN_ByteArray4"] = PCB_SN_ByteArray4;
              break;
           default:
              break;
           }


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Hardware Configuration") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Hardware Configuration ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa9;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                         if(i==2) {
//                             QMessageBox::information(this, "", tr("Ошибка записи данных : Hardware Configuration ") +
//                                                      "Рабочее место: " + QString::number(workPlaceNumber+1));
                             ui->label_StatusBar->setText(tr("Ошибка записи данных : Hardware Configuration ") +
                                                          ". Рабочее место: " + QString::number(workPlaceNumber+1));
                             errorString.append(ui->label_StatusBar->text() + '\n');
                             ui->label_writeParams->setVisible(true);
                             vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                             checkWritingError(currentIndicatorNumber);
                             workPlaceOff(currentIndicatorNumber);
                             return;
                         }

               }



           }


        }

        //
        //Write Software Configuration 5a 00 16 20
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x16;
           packetToRead.append(byte);
           byte = 0x20;
           packetToRead.append(byte);

           byte = flowMinByteArray[0];
           packetToRead.append(byte);
           byte = flowMinByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMinByteArray);
           mapwrite["flowMinByteArray"] = flowMinByteArray;


           byte = flowMaxByteArray[0];
           packetToRead.append(byte);
           byte = flowMaxByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMaxByteArray);
           mapwrite["flowMaxByteArray"] = flowMaxByteArray;


           byte = tinMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMinByteArray);
           mapwrite["tinMinByteArray"] = tinMinByteArray;


           byte = tinMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMaxByteArray);
           mapwrite["tinMaxByteArray"] = tinMaxByteArray;


           byte = toutMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMinByteArray);
           mapwrite["toutMinByteArray"] = toutMinByteArray;


           byte = toutMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMaxByteArray);
           mapwrite["toutMaxByteArray"] = toutMaxByteArray;


           byte = reportDataByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(reportDataByteArray);
           mapwrite["reportDataByteArray"] = reportDataByteArray;


           byte = averageTByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(averageTByteArray);
           mapwrite["averageTByteArray"] = averageTByteArray;


           byte = pulsesMode1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode1ByteArray);
           mapwrite["pulsesMode1ByteArray"] = pulsesMode1ByteArray;


           byte = pulsesMode2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode2ByteArray);
           mapwrite["pulsesMode2ByteArray"] = pulsesMode2ByteArray;


    //       quint16 pulseV1Int = (quint8)pulsesValue1ByteArray[0];
    //       pulseV1Int = pulseV1Int | (quint8)pulsesValue1ByteArray[1];
    //       if(pulseV1Int == 0) {
    //           QMessageBox::information(this, "", tr("Недопустимое для записи значение: pulsesValue1 ") + QString::number(pulseV1Int));
    //           return;
    //       }
           byte = pulsesValue1ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue1ByteArray);
           mapwrite["pulsesValue1ByteArray"] = pulsesValue1ByteArray;


    //       quint16 pulseV2Int = (quint8)pulsesValue2ByteArray[0];
    //       pulseV2Int = pulseV2Int | (quint8)pulsesValue2ByteArray[1];
    //       if(pulseV2Int == 0) {
    //           QMessageBox::information(this, "", tr("Недопустимое для записи значение: pulsesValue2 ") + QString::number(pulseV2Int));
    //           return;
    //       }
           byte = pulsesValue2ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue2ByteArray);
           mapwrite["pulsesValue2ByteArray"] = pulsesValue2ByteArray;

           byte = devType[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(devType);
           mapwrite["devType"] = devType;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"porTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);;//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Software Configuration ") +
//                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Software Configuration ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa0;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Software Configuration ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Software Configuration ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Sensor Parameters 5a 00 18 2d
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x18;
           packetToRead.append(byte);
           byte = 0x2d;
           packetToRead.append(byte);

           byte = flowRateByteArray[0];
           packetToRead.append(byte);
           byte = flowRateByteArray[1];
           packetToRead.append(byte);
           byte = flowRateByteArray[2];
           packetToRead.append(byte);
           byte = flowRateByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowRateByteArray);
           mapwrite["flowRateByteArray"] = flowRateByteArray;


           byte = pressureByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pressureByteArray);
           mapwrite["pressureByteArray"] = pressureByteArray;


           byte = RTD_TypeByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RTD_TypeByteArray);
           mapwrite["RTD_TypeByteArray"] = RTD_TypeByteArray;


           byte = R_RTDByteArray[0];
           packetToRead.append(byte);
           byte = R_RTDByteArray[1];
           packetToRead.append(byte);
           byte = R_RTDByteArray[2];
           packetToRead.append(byte);
           byte = R_RTDByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(R_RTDByteArray);

           quint32 r_rtdInt = (quint8)R_RTDByteArray[0];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[1];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[2];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[3];

           r_rtdInt = r_rtdInt/1000;

           QByteArray r_rtd_NotMultiplicationByteArray;
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>24));
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>16));
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>8));
           r_rtd_NotMultiplicationByteArray.append((quint8)r_rtdInt);
           mapwrite["R_RTDByteArray"] = r_rtd_NotMultiplicationByteArray; //проверять нужно неумноженное значение


           byte = RWire1ByteArray[0];
           packetToRead.append(byte);
           byte = RWire1ByteArray[1];
           packetToRead.append(byte);
           byte = RWire1ByteArray[2];
           packetToRead.append(byte);
           byte = RWire1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RWire1ByteArray);
           mapwrite["RWire1ByteArray"] = RWire1ByteArray;


           byte = RWire2ByteArray[0];
           packetToRead.append(byte);
           byte = RWire2ByteArray[1];
           packetToRead.append(byte);
           byte = RWire2ByteArray[2];
           packetToRead.append(byte);
           byte = RWire2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RWire2ByteArray);
           mapwrite["RWire2ByteArray"] = RWire2ByteArray;


           byte = flowNomByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowNomByteArray);
           mapwrite["flowNomByteArray"] = flowNomByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Sensor Parameters ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Sensor Parameters ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xad;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Sensor Parameters ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Sensor Parameters ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Flow Coefficient 5a 00 1d 3d
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x1d;
           packetToRead.append(byte);
           byte = 0x3d;
           packetToRead.append(byte);

           byte = flowCoef0ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef0ByteArray);
           mapwrite["flowCoef0ByteArray"] = flowCoef0ByteArray;


           byte = flowCoef1ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef1ByteArray);
           mapwrite["flowCoef1ByteArray"] = flowCoef1ByteArray;


           byte = flowCoef2ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef2ByteArray);
           mapwrite["flowCoef2ByteArray"] = flowCoef2ByteArray;


           byte = flowCoef3ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef3ByteArray);
           mapwrite["flowCoef3ByteArray"] = flowCoef3ByteArray;


           byte = flowCoef4ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef4ByteArray);
           mapwrite["flowCoef4ByteArray"] = flowCoef4ByteArray;


           byte = flowCoef5ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef5ByteArray);
           mapwrite["flowCoef5ByteArray"] = flowCoef5ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Flow Coefficient") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Flow Coefficient ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbd;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Flow Coefficient ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Flow Coefficient ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Differential Threshold 5a 00 07 3e
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x07;
           packetToRead.append(byte);
           byte = 0x3e;
           packetToRead.append(byte);

           byte = FS_DiffThrsByteArray[0];
           packetToRead.append(byte);
           byte = FS_DiffThrsByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(FS_DiffThrsByteArray);
           mapwrite["FS_DiffThrsByteArray"] = FS_DiffThrsByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Differential Threshold ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Differential Threshold ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbe;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Differential Threshold ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Differential Threshold ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Real Clock 5a 00 0d 22
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x0d;
           packetToRead.append(byte);
           byte = 0x22;
           packetToRead.append(byte);

           byte = hourByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(hourByteArray);
           mapwrite["hourByteArray"] = hourByteArray;


           byte = minuteByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(minuteByteArray);
           mapwrite["minuteByteArray"] = minuteByteArray;


           byte = secondByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(secondByteArray);
           mapwrite["secondByteArray"] = secondByteArray;

           byte = dayByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(dayByteArray);
           mapwrite["dayByteArray"] = dayByteArray;


           byte = monthByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(monthByteArray);
           mapwrite["monthByteArray"] = monthByteArray;


           byte = yearByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(yearByteArray);
           mapwrite["yearByteArray"] = yearByteArray;


           byte = DOWByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DOWByteArray);
           mapwrite["DOWByteArray"] = DOWByteArray;


           byte = ASW_flagByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ASW_flagByteArray);
           mapwrite["ASW_flagByteArray"] = ASW_flagByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Real Clock ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Real Clock ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa2;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Real Clock ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Real Clock ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Temperature Calibration Coefficient 5a 00 11 36
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x11;
           packetToRead.append(byte);
           byte = 0x36;
           packetToRead.append(byte);

           byte = shift_T1ByteArray[0];
           packetToRead.append(byte);
           byte = shift_T1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(shift_T1ByteArray);
           mapwrite["shift_T1ByteArray"] = shift_T1ByteArray;


           byte = shift_T2ByteArray[0];
           packetToRead.append(byte);
           byte = shift_T2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(shift_T2ByteArray);
           mapwrite["shift_T2ByteArray"] = shift_T2ByteArray;


           byte = scale_T1ByteArray[0];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[1];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[2];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(scale_T1ByteArray);
           mapwrite["scale_T1ByteArray"] = scale_T1ByteArray;


           byte = scale_T2ByteArray[0];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[1];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[2];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(scale_T2ByteArray);
           mapwrite["scale_T2ByteArray"] = scale_T2ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Temperature Calibration Coefficient ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Temperature Calibration Coefficient ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xb6;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных: Temperature Calibration Coefficient") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных: Temperature Calibration Coefficient ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write External Interface Settings 5a 00 0e 2b
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x0e;
           packetToRead.append(byte);
           byte = 0x2b;
           packetToRead.append(byte);

           byte = addrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(addrByteArray);
           mapwrite["addrByteArray"] = addrByteArray;


           byte = baudRateByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(baudRateByteArray);
           mapwrite["baudRateByteArray"] = baudRateByteArray;


           byte = HMP_TransByteArray[0];
           packetToRead.append(byte);
           byte = HMP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(HMP_TransByteArray);
           mapwrite["HMP_TransByteArray"] = HMP_TransByteArray;


           byte = EPP_TransByteArray[0];
           packetToRead.append(byte);
           byte = EPP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(EPP_TransByteArray);
           mapwrite["EPP_TransByteArray"] = EPP_TransByteArray;


           byte = P1PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P1PrimAddrByteArray);
           mapwrite["P1PrimAddrByteArray"] = P1PrimAddrByteArray;


           byte = P2PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P2PrimAddrByteArray);
           mapwrite["P2PrimAddrByteArray"] = P2PrimAddrByteArray;


           byte = ProtTypeByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ProtTypeByteArray);
           mapwrite["ProtTypeByteArray"] = ProtTypeByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Interface Settings ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : External Interface Settings ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xab;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                       QMessageBox::information(this, "", tr("Ошибка записи данных : External Interface Settings ") +
//                                                "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : External Interface Settings ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write External Device Settings  5a 00 25 3c
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x25;
           packetToRead.append(byte);
           byte = 0x3c;
           packetToRead.append(byte);

           byte = Serial_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Serial_P1ByteArray);
           mapwrite["Serial_P1ByteArray"] = Serial_P1ByteArray;


           byte = ManCode_P1ByteArray[0];
           packetToRead.append(byte);
           byte = ManCode_P1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ManCode_P1ByteArray);
           mapwrite["ManCode_P1ByteArray"] = ManCode_P1ByteArray;


           byte = DevType_P1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DevType_P1ByteArray);
           mapwrite["DevType_P1ByteArray"] = DevType_P1ByteArray;


           byte = Version_P1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Version_P1ByteArray);
           mapwrite["Version_P1ByteArray"] = Version_P1ByteArray;


           byte = Initial_value_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Initial_value_P1ByteArray);
           mapwrite["Initial_value_P1ByteArray"] = Initial_value_P1ByteArray;


           byte = Service_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Service_P1ByteArray);
           mapwrite["Service_P1ByteArray"] = Service_P1ByteArray;


           byte = Serial_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Serial_P2ByteArray);
           mapwrite["Serial_P2ByteArray"] = Serial_P2ByteArray;


           byte = ManCode_P2ByteArray[0];
           packetToRead.append(byte);
           byte = ManCode_P2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ManCode_P2ByteArray);
           mapwrite["ManCode_P2ByteArray"] = ManCode_P2ByteArray;


           byte = DevType_P2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DevType_P2ByteArray);
           mapwrite["DevType_P2ByteArray"] = DevType_P2ByteArray;


           byte = Version_P2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Version_P2ByteArray);
           mapwrite["Version_P2ByteArray"] = Version_P2ByteArray;


           byte = Initial_value_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Initial_value_P2ByteArray);
           mapwrite["Initial_value_P2ByteArray"] = Initial_value_P2ByteArray;


           byte = Service_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Service_P2ByteArray);
           mapwrite["Service_P2ByteArray"] = Service_P2ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Device Settings ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : External Device Settings ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbc;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : External Device Settings") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : External Device Settings ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }



        //
        //
        //проверка записанного. из списка проверяемых параметров удаляем те серийный номера и PCB_SN, которые не являются текущим для рабочего места

//        on_toolButton_readParams_clicked();

        readParams(workPlaceNumber);



        allParamsNameList.removeOne("minuteByteArray");
        allParamsNameList.removeOne("secondByteArray");
        allParamsNameList.removeOne("hourByteArray");

        switch (workPlaceNumber) {
        case 0:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 1:
           mapwrite["serialNumber"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 2:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 3:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
            break;
        default:
            break;
        }



        for(int i=0; i<allParamsNameList.size(); i++) {
            qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
            qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();

            if((allParamsNameList[i] != "pulsesValue1ByteArray") && (allParamsNameList[i] != "pulsesValue2ByteArray")) {
               if(mapwrite[allParamsNameList[i]] != mapRead[allParamsNameList[i]]) {
//                   QMessageBox::information(this, "", "Параметр записан некорректно : " +
//                                            allParamsNameList[i] + " " + mapRead[allParamsNameList[i]].toHex());
                   ui->label_StatusBar->setText(tr("Параметр записан некорректно : ") + allParamsNameList[i] + " " +
                                                mapRead[allParamsNameList[i]].toHex() +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
//                   ui->label_StatusBar->setText("Запись : Неудачно");
//                   ui->label_writeParams->setVisible(true);
                   return;
               }
            }

            //pulsesValue1
            if(allParamsNameList[i] == "pulsesValue1ByteArray") {
                quint16 pulsesValue1IntRead = mapRead["pulsesValue1ByteArray"].at(0);
                pulsesValue1IntRead = pulsesValue1IntRead<<8 | mapRead["pulsesValue1ByteArray"].at(1);

                quint16 pulsesValue1IntWrite = mapwrite["pulsesValue1ByteArray"].at(0);
                pulsesValue1IntWrite = pulsesValue1IntWrite<<8 | mapwrite["pulsesValue1ByteArray"].at(1);

                if((pulsesValue1IntRead <= (pulsesValue1IntWrite + 1)) && (pulsesValue1IntRead >= (pulsesValue1IntWrite - 1))) {

                }
                else {
//                    QMessageBox::information(this, "", "Параметр записан некорректно : pulsesValue1 " +
//                                             QString::number(pulsesValue1IntRead));
                    ui->label_StatusBar->setText(tr("Параметр записан некорректно : pulsesValue1 ") +
                                                 QString::number(pulsesValue1IntRead) +
                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
                    errorString.append(ui->label_StatusBar->text() + '\n');
                    vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                    checkWritingError(currentIndicatorNumber);
                    workPlaceOff(currentIndicatorNumber);
//                    ui->label_StatusBar->setText("Запись : Неудачно");
//                    ui->label_writeParams->setVisible(true);
                    return;
                }
            }

            //pulsesValue2
            if(allParamsNameList[i] == "pulsesValue2ByteArray") {
                quint16 pulsesValue2IntRead = mapRead["pulsesValue2ByteArray"].at(0);
                pulsesValue2IntRead = pulsesValue2IntRead<<8 | mapRead["pulsesValue2ByteArray"].at(1);

                quint16 pulsesValue2IntWrite = mapwrite["pulsesValue2ByteArray"].at(0);
                pulsesValue2IntWrite = pulsesValue2IntWrite<<8 | mapwrite["pulsesValue2ByteArray"].at(1);

                if((pulsesValue2IntRead <= (pulsesValue2IntWrite + 1)) && (pulsesValue2IntRead >= (pulsesValue2IntWrite - 1))) {

                }
                else {
//                    QMessageBox::information(this, "", "Параметр записан некорректно : pulsesValue2 " +
//                                             QString::number(pulsesValue2IntRead));
                    ui->label_StatusBar->setText(tr("Параметр записан некорректно : pulsesValue2 ") +
                                                 QString::number(pulsesValue2IntRead) +
                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
                    errorString.append(ui->label_StatusBar->text() + '\n');
                    vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                    checkWritingError(currentIndicatorNumber);
                    workPlaceOff(currentIndicatorNumber);
//                    ui->label_StatusBar->setText("Запись : Неудачно");
//                    ui->label_writeParams->setVisible(true);
                    return;
                }
            }

        }

  //      ui->label_StatusBar->setText("Запись : Успешно ");

        ui->label_writeParams->setStyleSheet(QString("color: green").arg(color.name()));
        ui->label_writeParams->setText("V");
  //      ui->label_writeParams->setVisible(true);



//        vectorIsErrorOccured[workPlaceNumber] = true;



//        isNeedPaintEvent = true;
//        switch (currentIndicatorNumber) {
//        case 0:
//            isWritingFinished1 = true;
//            break;
//        case 1:
//            isWritingFinished2 = true;
//            break;
//        case 2:
//            isWritingFinished3 = true;
//            break;
//        case 3:
//            isWritingFinished4 = true;
//            break;
//        default:
//            break;
//        }
//        repaint();
//        isNeedPaintEvent = false;

        checkWritingError(currentIndicatorNumber);



}

/**********************************************************/
void MainWindow::writeParams4(int workPlaceNumber)
{
    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

    workPlaceNumber = 3;

    if(!vectorIsWorkPlaceUse.at(3)) return;

//    indicatorReset();

//    repaint();



    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }

    portTmp->setBaudRate(QSerialPort::Baud19200);
    portTmp->setDataBits(QSerialPort::Data8);
    portTmp->setParity(QSerialPort::NoParity);
    portTmp->setStopBits(QSerialPort::OneStop);


    currentBoxNumber = 0;
    vectorIsErrorOccured[workPlaceNumber] = false;

    //


    switch (workPlaceNumber) {
    case 0:
        timerWriteParams.start(10000);
        break;
    case 1:
        timerWriteParams2.start(10000);
        break;
    case 2:
        timerWriteParams3.start(10000);
        break;
    case 3:
        timerWriteParams4.start(10000);
        break;

    default:
        break;
    }
  //      timerWriteParams.start(10000);

        bool ok;
        ProtTypeByteArray.clear();
        quint8 byteProtType = 0xff;
        ProtTypeByteArray.append(byteProtType);

        ui->label_writeParams->setVisible(false);
        ui->label_Calibration->setVisible(false);
        ui->label_pulsesOutputHeat->setVisible(false);
        ui->label_pulsesInputVolume->setVisible(false);
        ui->label_pulsesOutputOff->setVisible(false);
        ui->label_MBusOn->setVisible(false);
        ui->label_MBusOff->setVisible(false);
        ui->label_CheckMbus->setVisible(false);
        ui->label_digitalWireInterfaceChecking->setVisible(false);
        ui->label_RMV_ErrorFlags_tick->setVisible(false);
        ui->label_calibrationModeOff->setVisible(false);
        ui->label_realClockCalibration->setVisible(false);

        ui->lineEdit_RMV_ErrorFlags->setText("");

        //
        //индикатор
        QColor color(255, 127, 50);
        ui->label_writeParams->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_writeParams->setText("X");
        ui->label_writeParams->setVisible(false);
        //
        //

        ui->label_StatusBar->setText("");

        //
        pulsesMode1ByteArray.clear();
        pulsesMode2ByteArray.clear();

        pulsesMode1ByteArray.append(pulsesMode1PrimalInt); //append(byte);
        pulsesMode2ByteArray.append(pulsesMode2PrimalInt); //append(byte);
        //
        //
        if(pulsesValue1PrimeInt == 0) {
  //          QMessageBox::information(this, "", tr("Недопустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt));
            ui->label_StatusBar->setText(tr("Недопустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt) +
                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text() + '\n');
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkWritingError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
            return;
        }
        if(pulsesValue2PrimeInt == 0) {
 //           QMessageBox::information(this, "", tr("Недопустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt));
            ui->label_StatusBar->setText(tr("Недопустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt) +
                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text() + '\n');
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkWritingError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
            return;
        }
        pulsesValue1ByteArray.clear();
        pulsesValue2ByteArray.clear();
        pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt>>8));
        pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt));

        pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt>>8));
        pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt));
        //

        bool isWritingCorrect = false;

        paramsVectorToWrite.clear();

        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
//                QMessageBox::information(this, "", "Не удалось открыть порт УСО-2. Рабочее место: " +
//                                         QString::number(workPlaceNumber + 1) );
                ui->label_StatusBar->setText("Не удалось открыть порт УСО-2. Рабочее место: " +
                                             QString::number(workPlaceNumber + 1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkWritingError(currentIndicatorNumber);
                workPlaceOff(currentIndicatorNumber);
                return;
            }
        }


        //
        //Set Password Default 5a 00 07 42 23 17
        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x07;
           packetToRead.append(byte);
           byte = 0x42;
           packetToRead.append(byte);
           byte = 0x23;
           packetToRead.append(byte);
           byte = 0x17;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
//                   QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка установки пароля по умолчанию") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc2;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);



                  //
                  //



                  break;
               }
               else {
                        if(i==9) {
//                            QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию") +
//                                                     "Рабочее место: " + QString::number(workPlaceNumber+1));
                            ui->label_StatusBar->setText(tr("Ошибка установки пароля по умолчанию") +
                                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            ui->label_writeParams->setVisible(true);
                            vectorIsErrorOccured[workPlaceNumber] = true;
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkWritingError(currentIndicatorNumber);
                            workPlaceOff(currentIndicatorNumber);

                            return;
                        }

               }



           }


        }

        //
        //Set Password Default 5a 00 07 42 23 17/


        //
        //Открыть парольную сессию 5a 00 08 40 01 04 57
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x08;
           packetToRead.append(byte);
           byte = 0x40;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);
           byte = 0x04;
           packetToRead.append(byte);
           byte = 0x57;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(110);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc0;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);


                  //
                  //



                  break;
               }
               else {
                        if(i==2) {
//                            QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                                     "Рабочее место: " + QString::number(workPlaceNumber+1));
                            ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            ui->label_writeParams->setVisible(true);
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkWritingError(currentIndicatorNumber);
                            workPlaceOff(currentIndicatorNumber);

                            return;
                        }

               }



           }


        }

        //
        //Открыть парольную сессию 5a 00 08 40 01 04 57/


        //
        //Write Hardware Configuration 5a 00 15 29 serial(4) manCode(2) devType(1) DN(1)
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x15;
           packetToRead.append(byte);
           byte = 0x29;
           packetToRead.append(byte);

           //
           switch (workPlaceNumber) {
           case 0:
                byte = serialNumber[0];
                packetToRead.append(byte);
                byte = serialNumber[1];
                packetToRead.append(byte);
                byte = serialNumber[2];
                packetToRead.append(byte);
                byte = serialNumber[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber);
                mapwrite["serialNumber"] = serialNumber;
               break;
           case 1:
                byte = serialNumber2[0];
                packetToRead.append(byte);
                byte = serialNumber2[1];
                packetToRead.append(byte);
                byte = serialNumber2[2];
                packetToRead.append(byte);
                byte = serialNumber2[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber2);
                mapwrite["serialNumber2"] = serialNumber2;
               break;
           case 2:
                byte = serialNumber3[0];
                packetToRead.append(byte);
                byte = serialNumber3[1];
                packetToRead.append(byte);
                byte = serialNumber3[2];
                packetToRead.append(byte);
                byte = serialNumber3[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber3);
                mapwrite["serialNumber3"] = serialNumber3;
               break;
           case 3:
                byte = serialNumber4[0];
                packetToRead.append(byte);
                byte = serialNumber4[1];
                packetToRead.append(byte);
                byte = serialNumber4[2];
                packetToRead.append(byte);
                byte = serialNumber4[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber4);
                mapwrite["serialNumber4"] = serialNumber4;
               break;
           default:
               break;
           }
           //


           byte = manCode[0];
           packetToRead.append(byte);
           byte = manCode[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(manCode);
           mapwrite["manCode"] = manCode;


           byte = devType[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(devType);
           mapwrite["devType"] = devType;


           byte = DN[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DN);
           mapwrite["DN"] = DN;


           //
           switch (workPlaceNumber) {
           case 0:
               byte = PCB_SN_ByteArray[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray);
               mapwrite["PCB_SN_ByteArray"] = PCB_SN_ByteArray;
              break;
           case 1:
               byte = PCB_SN_ByteArray2[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray2);
               mapwrite["PCB_SN_ByteArray2"] = PCB_SN_ByteArray2;
              break;
           case 2:
               byte = PCB_SN_ByteArray3[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray3);
               mapwrite["PCB_SN_ByteArray3"] = PCB_SN_ByteArray3;
              break;
           case 3:
               byte = PCB_SN_ByteArray4[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray4);
               mapwrite["PCB_SN_ByteArray4"] = PCB_SN_ByteArray4;
              break;
           default:
              break;
           }


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Hardware Configuration") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Hardware Configuration ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa9;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                         if(i==2) {
//                             QMessageBox::information(this, "", tr("Ошибка записи данных : Hardware Configuration ") +
//                                                      "Рабочее место: " + QString::number(workPlaceNumber+1));
                             ui->label_StatusBar->setText(tr("Ошибка записи данных : Hardware Configuration ") +
                                                          ". Рабочее место: " + QString::number(workPlaceNumber+1));
                             errorString.append(ui->label_StatusBar->text() + '\n');
                             ui->label_writeParams->setVisible(true);
                             vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                             checkWritingError(currentIndicatorNumber);
                             workPlaceOff(currentIndicatorNumber);
                             return;
                         }

               }



           }


        }

        //
        //Write Software Configuration 5a 00 16 20
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x16;
           packetToRead.append(byte);
           byte = 0x20;
           packetToRead.append(byte);

           byte = flowMinByteArray[0];
           packetToRead.append(byte);
           byte = flowMinByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMinByteArray);
           mapwrite["flowMinByteArray"] = flowMinByteArray;


           byte = flowMaxByteArray[0];
           packetToRead.append(byte);
           byte = flowMaxByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMaxByteArray);
           mapwrite["flowMaxByteArray"] = flowMaxByteArray;


           byte = tinMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMinByteArray);
           mapwrite["tinMinByteArray"] = tinMinByteArray;


           byte = tinMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMaxByteArray);
           mapwrite["tinMaxByteArray"] = tinMaxByteArray;


           byte = toutMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMinByteArray);
           mapwrite["toutMinByteArray"] = toutMinByteArray;


           byte = toutMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMaxByteArray);
           mapwrite["toutMaxByteArray"] = toutMaxByteArray;


           byte = reportDataByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(reportDataByteArray);
           mapwrite["reportDataByteArray"] = reportDataByteArray;


           byte = averageTByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(averageTByteArray);
           mapwrite["averageTByteArray"] = averageTByteArray;


           byte = pulsesMode1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode1ByteArray);
           mapwrite["pulsesMode1ByteArray"] = pulsesMode1ByteArray;


           byte = pulsesMode2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode2ByteArray);
           mapwrite["pulsesMode2ByteArray"] = pulsesMode2ByteArray;


    //       quint16 pulseV1Int = (quint8)pulsesValue1ByteArray[0];
    //       pulseV1Int = pulseV1Int | (quint8)pulsesValue1ByteArray[1];
    //       if(pulseV1Int == 0) {
    //           QMessageBox::information(this, "", tr("Недопустимое для записи значение: pulsesValue1 ") + QString::number(pulseV1Int));
    //           return;
    //       }
           byte = pulsesValue1ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue1ByteArray);
           mapwrite["pulsesValue1ByteArray"] = pulsesValue1ByteArray;


    //       quint16 pulseV2Int = (quint8)pulsesValue2ByteArray[0];
    //       pulseV2Int = pulseV2Int | (quint8)pulsesValue2ByteArray[1];
    //       if(pulseV2Int == 0) {
    //           QMessageBox::information(this, "", tr("Недопустимое для записи значение: pulsesValue2 ") + QString::number(pulseV2Int));
    //           return;
    //       }
           byte = pulsesValue2ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue2ByteArray);
           mapwrite["pulsesValue2ByteArray"] = pulsesValue2ByteArray;

           byte = devType[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(devType);
           mapwrite["devType"] = devType;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"porTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);;//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Software Configuration ") +
//                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Software Configuration ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa0;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Software Configuration ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Software Configuration ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Sensor Parameters 5a 00 18 2d
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x18;
           packetToRead.append(byte);
           byte = 0x2d;
           packetToRead.append(byte);

           byte = flowRateByteArray[0];
           packetToRead.append(byte);
           byte = flowRateByteArray[1];
           packetToRead.append(byte);
           byte = flowRateByteArray[2];
           packetToRead.append(byte);
           byte = flowRateByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowRateByteArray);
           mapwrite["flowRateByteArray"] = flowRateByteArray;


           byte = pressureByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pressureByteArray);
           mapwrite["pressureByteArray"] = pressureByteArray;


           byte = RTD_TypeByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RTD_TypeByteArray);
           mapwrite["RTD_TypeByteArray"] = RTD_TypeByteArray;


           byte = R_RTDByteArray[0];
           packetToRead.append(byte);
           byte = R_RTDByteArray[1];
           packetToRead.append(byte);
           byte = R_RTDByteArray[2];
           packetToRead.append(byte);
           byte = R_RTDByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(R_RTDByteArray);

           quint32 r_rtdInt = (quint8)R_RTDByteArray[0];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[1];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[2];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[3];

           r_rtdInt = r_rtdInt/1000;

           QByteArray r_rtd_NotMultiplicationByteArray;
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>24));
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>16));
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>8));
           r_rtd_NotMultiplicationByteArray.append((quint8)r_rtdInt);
           mapwrite["R_RTDByteArray"] = r_rtd_NotMultiplicationByteArray; //проверять нужно неумноженное значение


           byte = RWire1ByteArray[0];
           packetToRead.append(byte);
           byte = RWire1ByteArray[1];
           packetToRead.append(byte);
           byte = RWire1ByteArray[2];
           packetToRead.append(byte);
           byte = RWire1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RWire1ByteArray);
           mapwrite["RWire1ByteArray"] = RWire1ByteArray;


           byte = RWire2ByteArray[0];
           packetToRead.append(byte);
           byte = RWire2ByteArray[1];
           packetToRead.append(byte);
           byte = RWire2ByteArray[2];
           packetToRead.append(byte);
           byte = RWire2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RWire2ByteArray);
           mapwrite["RWire2ByteArray"] = RWire2ByteArray;


           byte = flowNomByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowNomByteArray);
           mapwrite["flowNomByteArray"] = flowNomByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Sensor Parameters ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Sensor Parameters ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xad;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Sensor Parameters ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Sensor Parameters ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Flow Coefficient 5a 00 1d 3d
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x1d;
           packetToRead.append(byte);
           byte = 0x3d;
           packetToRead.append(byte);

           byte = flowCoef0ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef0ByteArray);
           mapwrite["flowCoef0ByteArray"] = flowCoef0ByteArray;


           byte = flowCoef1ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef1ByteArray);
           mapwrite["flowCoef1ByteArray"] = flowCoef1ByteArray;


           byte = flowCoef2ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef2ByteArray);
           mapwrite["flowCoef2ByteArray"] = flowCoef2ByteArray;


           byte = flowCoef3ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef3ByteArray);
           mapwrite["flowCoef3ByteArray"] = flowCoef3ByteArray;


           byte = flowCoef4ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef4ByteArray);
           mapwrite["flowCoef4ByteArray"] = flowCoef4ByteArray;


           byte = flowCoef5ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef5ByteArray);
           mapwrite["flowCoef5ByteArray"] = flowCoef5ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Flow Coefficient") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Flow Coefficient ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbd;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Flow Coefficient ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Flow Coefficient ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Differential Threshold 5a 00 07 3e
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x07;
           packetToRead.append(byte);
           byte = 0x3e;
           packetToRead.append(byte);

           byte = FS_DiffThrsByteArray[0];
           packetToRead.append(byte);
           byte = FS_DiffThrsByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(FS_DiffThrsByteArray);
           mapwrite["FS_DiffThrsByteArray"] = FS_DiffThrsByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Differential Threshold ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Differential Threshold ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbe;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Differential Threshold ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Differential Threshold ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Real Clock 5a 00 0d 22
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x0d;
           packetToRead.append(byte);
           byte = 0x22;
           packetToRead.append(byte);

           byte = hourByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(hourByteArray);
           mapwrite["hourByteArray"] = hourByteArray;


           byte = minuteByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(minuteByteArray);
           mapwrite["minuteByteArray"] = minuteByteArray;


           byte = secondByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(secondByteArray);
           mapwrite["secondByteArray"] = secondByteArray;

           byte = dayByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(dayByteArray);
           mapwrite["dayByteArray"] = dayByteArray;


           byte = monthByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(monthByteArray);
           mapwrite["monthByteArray"] = monthByteArray;


           byte = yearByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(yearByteArray);
           mapwrite["yearByteArray"] = yearByteArray;


           byte = DOWByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DOWByteArray);
           mapwrite["DOWByteArray"] = DOWByteArray;


           byte = ASW_flagByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ASW_flagByteArray);
           mapwrite["ASW_flagByteArray"] = ASW_flagByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Real Clock ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Real Clock ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa2;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Real Clock ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Real Clock ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Temperature Calibration Coefficient 5a 00 11 36
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x11;
           packetToRead.append(byte);
           byte = 0x36;
           packetToRead.append(byte);

           byte = shift_T1ByteArray[0];
           packetToRead.append(byte);
           byte = shift_T1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(shift_T1ByteArray);
           mapwrite["shift_T1ByteArray"] = shift_T1ByteArray;


           byte = shift_T2ByteArray[0];
           packetToRead.append(byte);
           byte = shift_T2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(shift_T2ByteArray);
           mapwrite["shift_T2ByteArray"] = shift_T2ByteArray;


           byte = scale_T1ByteArray[0];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[1];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[2];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(scale_T1ByteArray);
           mapwrite["scale_T1ByteArray"] = scale_T1ByteArray;


           byte = scale_T2ByteArray[0];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[1];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[2];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(scale_T2ByteArray);
           mapwrite["scale_T2ByteArray"] = scale_T2ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Temperature Calibration Coefficient ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Temperature Calibration Coefficient ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xb6;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных: Temperature Calibration Coefficient") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных: Temperature Calibration Coefficient ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write External Interface Settings 5a 00 0e 2b
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x0e;
           packetToRead.append(byte);
           byte = 0x2b;
           packetToRead.append(byte);

           byte = addrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(addrByteArray);
           mapwrite["addrByteArray"] = addrByteArray;


           byte = baudRateByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(baudRateByteArray);
           mapwrite["baudRateByteArray"] = baudRateByteArray;


           byte = HMP_TransByteArray[0];
           packetToRead.append(byte);
           byte = HMP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(HMP_TransByteArray);
           mapwrite["HMP_TransByteArray"] = HMP_TransByteArray;


           byte = EPP_TransByteArray[0];
           packetToRead.append(byte);
           byte = EPP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(EPP_TransByteArray);
           mapwrite["EPP_TransByteArray"] = EPP_TransByteArray;


           byte = P1PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P1PrimAddrByteArray);
           mapwrite["P1PrimAddrByteArray"] = P1PrimAddrByteArray;


           byte = P2PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P2PrimAddrByteArray);
           mapwrite["P2PrimAddrByteArray"] = P2PrimAddrByteArray;


           byte = ProtTypeByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ProtTypeByteArray);
           mapwrite["ProtTypeByteArray"] = ProtTypeByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Interface Settings ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : External Interface Settings ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xab;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                       QMessageBox::information(this, "", tr("Ошибка записи данных : External Interface Settings ") +
//                                                "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : External Interface Settings ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write External Device Settings  5a 00 25 3c
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x25;
           packetToRead.append(byte);
           byte = 0x3c;
           packetToRead.append(byte);

           byte = Serial_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Serial_P1ByteArray);
           mapwrite["Serial_P1ByteArray"] = Serial_P1ByteArray;


           byte = ManCode_P1ByteArray[0];
           packetToRead.append(byte);
           byte = ManCode_P1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ManCode_P1ByteArray);
           mapwrite["ManCode_P1ByteArray"] = ManCode_P1ByteArray;


           byte = DevType_P1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DevType_P1ByteArray);
           mapwrite["DevType_P1ByteArray"] = DevType_P1ByteArray;


           byte = Version_P1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Version_P1ByteArray);
           mapwrite["Version_P1ByteArray"] = Version_P1ByteArray;


           byte = Initial_value_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Initial_value_P1ByteArray);
           mapwrite["Initial_value_P1ByteArray"] = Initial_value_P1ByteArray;


           byte = Service_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Service_P1ByteArray);
           mapwrite["Service_P1ByteArray"] = Service_P1ByteArray;


           byte = Serial_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Serial_P2ByteArray);
           mapwrite["Serial_P2ByteArray"] = Serial_P2ByteArray;


           byte = ManCode_P2ByteArray[0];
           packetToRead.append(byte);
           byte = ManCode_P2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ManCode_P2ByteArray);
           mapwrite["ManCode_P2ByteArray"] = ManCode_P2ByteArray;


           byte = DevType_P2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DevType_P2ByteArray);
           mapwrite["DevType_P2ByteArray"] = DevType_P2ByteArray;


           byte = Version_P2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Version_P2ByteArray);
           mapwrite["Version_P2ByteArray"] = Version_P2ByteArray;


           byte = Initial_value_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Initial_value_P2ByteArray);
           mapwrite["Initial_value_P2ByteArray"] = Initial_value_P2ByteArray;


           byte = Service_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Service_P2ByteArray);
           mapwrite["Service_P2ByteArray"] = Service_P2ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Device Settings ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : External Device Settings ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbc;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : External Device Settings") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : External Device Settings ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }



        //
        //
        //проверка записанного. из списка проверяемых параметров удаляем те серийный номера и PCB_SN, которые не являются текущим для рабочего места

//        on_toolButton_readParams_clicked();

        readParams(workPlaceNumber);



        allParamsNameList.removeOne("minuteByteArray");
        allParamsNameList.removeOne("secondByteArray");
        allParamsNameList.removeOne("hourByteArray");

        switch (workPlaceNumber) {
        case 0:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 1:
           mapwrite["serialNumber"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 2:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 3:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
            break;
        default:
            break;
        }



        for(int i=0; i<allParamsNameList.size(); i++) {
            qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
            qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();

            if((allParamsNameList[i] != "pulsesValue1ByteArray") && (allParamsNameList[i] != "pulsesValue2ByteArray")) {
               if(mapwrite[allParamsNameList[i]] != mapRead[allParamsNameList[i]]) {
//                   QMessageBox::information(this, "", "Параметр записан некорректно : " +
//                                            allParamsNameList[i] + " " + mapRead[allParamsNameList[i]].toHex());
                   ui->label_StatusBar->setText(tr("Параметр записан некорректно : ") + allParamsNameList[i] + " " +
                                                mapRead[allParamsNameList[i]].toHex() +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
//                   ui->label_StatusBar->setText("Запись : Неудачно");
//                   ui->label_writeParams->setVisible(true);
                   return;
               }
            }

            //pulsesValue1
            if(allParamsNameList[i] == "pulsesValue1ByteArray") {
                quint16 pulsesValue1IntRead = mapRead["pulsesValue1ByteArray"].at(0);
                pulsesValue1IntRead = pulsesValue1IntRead<<8 | mapRead["pulsesValue1ByteArray"].at(1);

                quint16 pulsesValue1IntWrite = mapwrite["pulsesValue1ByteArray"].at(0);
                pulsesValue1IntWrite = pulsesValue1IntWrite<<8 | mapwrite["pulsesValue1ByteArray"].at(1);

                if((pulsesValue1IntRead <= (pulsesValue1IntWrite + 1)) && (pulsesValue1IntRead >= (pulsesValue1IntWrite - 1))) {

                }
                else {
//                    QMessageBox::information(this, "", "Параметр записан некорректно : pulsesValue1 " +
//                                             QString::number(pulsesValue1IntRead));
                    ui->label_StatusBar->setText(tr("Параметр записан некорректно : pulsesValue1 ") +
                                                 QString::number(pulsesValue1IntRead) +
                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
                    errorString.append(ui->label_StatusBar->text() + '\n');
                    vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                    checkWritingError(currentIndicatorNumber);
                    workPlaceOff(currentIndicatorNumber);
//                    ui->label_StatusBar->setText("Запись : Неудачно");
//                    ui->label_writeParams->setVisible(true);
                    return;
                }
            }

            //pulsesValue2
            if(allParamsNameList[i] == "pulsesValue2ByteArray") {
                quint16 pulsesValue2IntRead = mapRead["pulsesValue2ByteArray"].at(0);
                pulsesValue2IntRead = pulsesValue2IntRead<<8 | mapRead["pulsesValue2ByteArray"].at(1);

                quint16 pulsesValue2IntWrite = mapwrite["pulsesValue2ByteArray"].at(0);
                pulsesValue2IntWrite = pulsesValue2IntWrite<<8 | mapwrite["pulsesValue2ByteArray"].at(1);

                if((pulsesValue2IntRead <= (pulsesValue2IntWrite + 1)) && (pulsesValue2IntRead >= (pulsesValue2IntWrite - 1))) {

                }
                else {
//                    QMessageBox::information(this, "", "Параметр записан некорректно : pulsesValue2 " +
//                                             QString::number(pulsesValue2IntRead));
                    ui->label_StatusBar->setText(tr("Параметр записан некорректно : pulsesValue2 ") +
                                                 QString::number(pulsesValue2IntRead) +
                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
                    errorString.append(ui->label_StatusBar->text() + '\n');
                    vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                    checkWritingError(currentIndicatorNumber);
                    workPlaceOff(currentIndicatorNumber);
//                    ui->label_StatusBar->setText("Запись : Неудачно");
//                    ui->label_writeParams->setVisible(true);
                    return;
                }
            }

        }

  //      ui->label_StatusBar->setText("Запись : Успешно ");

        ui->label_writeParams->setStyleSheet(QString("color: green").arg(color.name()));
        ui->label_writeParams->setText("V");
  //      ui->label_writeParams->setVisible(true);



//        vectorIsErrorOccured[workPlaceNumber] = true;



//        isNeedPaintEvent = true;
//        switch (currentIndicatorNumber) {
//        case 0:
//            isWritingFinished1 = true;
//            break;
//        case 1:
//            isWritingFinished2 = true;
//            break;
//        case 2:
//            isWritingFinished3 = true;
//            break;
//        case 3:
//            isWritingFinished4 = true;
//            break;
//        default:
//            break;
//        }
//        repaint();
//        isNeedPaintEvent = false;

        checkWritingError(currentIndicatorNumber);



}
/**********************************************************/
void MainWindow::writeParams(int workPlaceNumber)
{
    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

 //   workPlaceNumber = 0;

    if(!vectorIsWorkPlaceUse.at(workPlaceNumber)) return;

//    indicatorReset();

//    repaint();



    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }

    portTmp->setBaudRate(QSerialPort::Baud19200);
    portTmp->setDataBits(QSerialPort::Data8);
    portTmp->setParity(QSerialPort::NoParity);
    portTmp->setStopBits(QSerialPort::OneStop);


    currentBoxNumber = 0;
    vectorIsErrorOccured[workPlaceNumber] = false;

    //

    
    switch (workPlaceNumber) {
    case 0:
        timerWriteParams.start(10000);
        break;
    case 1:
        timerWriteParams2.start(10000);
        break;
    case 2:
        timerWriteParams3.start(10000);
        break;
    case 3:
        timerWriteParams4.start(10000);
        break;
        
    default:
        break;
    }
  //      timerWriteParams.start(10000);

        bool ok;
        ProtTypeByteArray.clear();
        quint8 byteProtType = 0xff;
        ProtTypeByteArray.append(byteProtType);

        ui->label_writeParams->setVisible(false);
        ui->label_Calibration->setVisible(false);
        ui->label_pulsesOutputHeat->setVisible(false);
        ui->label_pulsesInputVolume->setVisible(false);
        ui->label_pulsesOutputOff->setVisible(false);
        ui->label_MBusOn->setVisible(false);
        ui->label_MBusOff->setVisible(false);
        ui->label_CheckMbus->setVisible(false);
        ui->label_digitalWireInterfaceChecking->setVisible(false);
        ui->label_RMV_ErrorFlags_tick->setVisible(false);
        ui->label_calibrationModeOff->setVisible(false);
        ui->label_realClockCalibration->setVisible(false);

        ui->lineEdit_RMV_ErrorFlags->setText("");

        //
        //индикатор
        QColor color(255, 127, 50);
        ui->label_writeParams->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_writeParams->setText("X");
        ui->label_writeParams->setVisible(false);
        //
        //

        ui->label_StatusBar->setText("");

        //
        pulsesMode1ByteArray.clear();
        pulsesMode2ByteArray.clear();

        pulsesMode1ByteArray.append(pulsesMode1PrimalInt); //append(byte);
        pulsesMode2ByteArray.append(pulsesMode2PrimalInt); //append(byte);
        //
        //
        if(pulsesValue1PrimeInt == 0) {
  //          QMessageBox::information(this, "", tr("Недопустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt));
            ui->label_StatusBar->setText(tr("Недопустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt) +
                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text() + '\n');
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkWritingError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
            return;
        }
        if(pulsesValue2PrimeInt == 0) {
 //           QMessageBox::information(this, "", tr("Недопустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt));
            ui->label_StatusBar->setText(tr("Недопустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt) +
                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text() + '\n');
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkWritingError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
            return;
        }
        pulsesValue1ByteArray.clear();
        pulsesValue2ByteArray.clear();
        pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt>>8));
        pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt));

        pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt>>8));
        pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt));
        //

        bool isWritingCorrect = false;

        paramsVectorToWrite.clear();

        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
//                QMessageBox::information(this, "", "Не удалось открыть порт УСО-2. Рабочее место: " +
//                                         QString::number(workPlaceNumber + 1) );
                ui->label_StatusBar->setText("Не удалось открыть порт УСО-2. Рабочее место: " +
                                             QString::number(workPlaceNumber + 1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkWritingError(currentIndicatorNumber);
                workPlaceOff(currentIndicatorNumber);
                return;
            }
        }


        //
        //Set Password Default 5a 00 07 42 23 17
        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x07;
           packetToRead.append(byte);
           byte = 0x42;
           packetToRead.append(byte);
           byte = 0x23;
           packetToRead.append(byte);
           byte = 0x17;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
//                   QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка установки пароля по умолчанию") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIsErrorOccured[workPlaceNumber] = true;
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc2;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);



                  //
                  //



                  break;
               }
               else {
                        if(i==9) {
//                            QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию") +
//                                                     "Рабочее место: " + QString::number(workPlaceNumber+1));
                            ui->label_StatusBar->setText(tr("Ошибка установки пароля по умолчанию") +
                                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            ui->label_writeParams->setVisible(true);
                            vectorIsErrorOccured[workPlaceNumber] = true;
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkWritingError(currentIndicatorNumber);
                            workPlaceOff(currentIndicatorNumber);

                            return;
                        }

               }



           }


        }

        //
        //Set Password Default 5a 00 07 42 23 17/


        //
        //Открыть парольную сессию 5a 00 08 40 01 04 57
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x08;
           packetToRead.append(byte);
           byte = 0x40;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);
           byte = 0x04;
           packetToRead.append(byte);
           byte = 0x57;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(110);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc0;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);


                  //
                  //



                  break;
               }
               else {
                        if(i==2) {
//                            QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                                     "Рабочее место: " + QString::number(workPlaceNumber+1));
                            ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            ui->label_writeParams->setVisible(true);
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkWritingError(currentIndicatorNumber);
                            workPlaceOff(currentIndicatorNumber);

                            return;
                        }

               }



           }


        }

        //
        //Открыть парольную сессию 5a 00 08 40 01 04 57/


        //
        //Write Hardware Configuration 5a 00 15 29 serial(4) manCode(2) devType(1) DN(1)
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x15;
           packetToRead.append(byte);
           byte = 0x29;
           packetToRead.append(byte);
           
           //
           switch (workPlaceNumber) {
           case 0:
                byte = serialNumber[0];
                packetToRead.append(byte);
                byte = serialNumber[1];
                packetToRead.append(byte);
                byte = serialNumber[2];
                packetToRead.append(byte);
                byte = serialNumber[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber);
                mapwrite["serialNumber"] = serialNumber;
               break;
           case 1:
                byte = serialNumber2[0];
                packetToRead.append(byte);
                byte = serialNumber2[1];
                packetToRead.append(byte);
                byte = serialNumber2[2];
                packetToRead.append(byte);
                byte = serialNumber2[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber2);
                mapwrite["serialNumber2"] = serialNumber2;
               break;
           case 2:
                byte = serialNumber3[0];
                packetToRead.append(byte);
                byte = serialNumber3[1];
                packetToRead.append(byte);
                byte = serialNumber3[2];
                packetToRead.append(byte);
                byte = serialNumber3[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber3);
                mapwrite["serialNumber3"] = serialNumber3;
               break;
           case 3:
                byte = serialNumber4[0];
                packetToRead.append(byte);
                byte = serialNumber4[1];
                packetToRead.append(byte);
                byte = serialNumber4[2];
                packetToRead.append(byte);
                byte = serialNumber4[3];
                packetToRead.append(byte);
                paramsVectorToWrite.append(serialNumber4);
                mapwrite["serialNumber4"] = serialNumber4;
               break;
           default:
               break;
           }
           //
             

           byte = manCode[0];
           packetToRead.append(byte);
           byte = manCode[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(manCode);
           mapwrite["manCode"] = manCode;


           byte = devType[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(devType);
           mapwrite["devType"] = devType;


           byte = DN[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DN);
           mapwrite["DN"] = DN;


           //
           switch (workPlaceNumber) {
           case 0:
               byte = PCB_SN_ByteArray[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray);
               mapwrite["PCB_SN_ByteArray"] = PCB_SN_ByteArray;
              break;
           case 1:
               byte = PCB_SN_ByteArray2[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray2[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray2);
               mapwrite["PCB_SN_ByteArray2"] = PCB_SN_ByteArray2;
              break;
           case 2:
               byte = PCB_SN_ByteArray3[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray3[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray3);
               mapwrite["PCB_SN_ByteArray3"] = PCB_SN_ByteArray3;
              break;
           case 3:
               byte = PCB_SN_ByteArray4[0];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[1];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[2];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[3];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[4];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[5];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[6];
               packetToRead.append(byte);
               byte = PCB_SN_ByteArray4[7];
               packetToRead.append(byte);
               paramsVectorToWrite.append(PCB_SN_ByteArray4);
               mapwrite["PCB_SN_ByteArray4"] = PCB_SN_ByteArray4;
              break;
           default:
              break;
           }          


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);

               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Hardware Configuration") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Hardware Configuration ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);

                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa9;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                         if(i==2) {
//                             QMessageBox::information(this, "", tr("Ошибка записи данных : Hardware Configuration ") +
//                                                      "Рабочее место: " + QString::number(workPlaceNumber+1));
                             ui->label_StatusBar->setText(tr("Ошибка записи данных : Hardware Configuration ") +
                                                          ". Рабочее место: " + QString::number(workPlaceNumber+1));
                             errorString.append(ui->label_StatusBar->text() + '\n');
                             ui->label_writeParams->setVisible(true);
                             vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                             checkWritingError(currentIndicatorNumber);
                             workPlaceOff(currentIndicatorNumber);
                             return;
                         }

               }



           }


        }

        //
        //Write Software Configuration 5a 00 16 20
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x16;
           packetToRead.append(byte);
           byte = 0x20;
           packetToRead.append(byte);

           byte = flowMinByteArray[0];
           packetToRead.append(byte);
           byte = flowMinByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMinByteArray);
           mapwrite["flowMinByteArray"] = flowMinByteArray;


           byte = flowMaxByteArray[0];
           packetToRead.append(byte);
           byte = flowMaxByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMaxByteArray);
           mapwrite["flowMaxByteArray"] = flowMaxByteArray;


           byte = tinMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMinByteArray);
           mapwrite["tinMinByteArray"] = tinMinByteArray;


           byte = tinMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMaxByteArray);
           mapwrite["tinMaxByteArray"] = tinMaxByteArray;


           byte = toutMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMinByteArray);
           mapwrite["toutMinByteArray"] = toutMinByteArray;


           byte = toutMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMaxByteArray);
           mapwrite["toutMaxByteArray"] = toutMaxByteArray;


           byte = reportDataByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(reportDataByteArray);
           mapwrite["reportDataByteArray"] = reportDataByteArray;


           byte = averageTByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(averageTByteArray);
           mapwrite["averageTByteArray"] = averageTByteArray;


           byte = pulsesMode1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode1ByteArray);
           mapwrite["pulsesMode1ByteArray"] = pulsesMode1ByteArray;


           byte = pulsesMode2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode2ByteArray);
           mapwrite["pulsesMode2ByteArray"] = pulsesMode2ByteArray;


    //       quint16 pulseV1Int = (quint8)pulsesValue1ByteArray[0];
    //       pulseV1Int = pulseV1Int | (quint8)pulsesValue1ByteArray[1];
    //       if(pulseV1Int == 0) {
    //           QMessageBox::information(this, "", tr("Недопустимое для записи значение: pulsesValue1 ") + QString::number(pulseV1Int));
    //           return;
    //       }
           byte = pulsesValue1ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue1ByteArray);
           mapwrite["pulsesValue1ByteArray"] = pulsesValue1ByteArray;


    //       quint16 pulseV2Int = (quint8)pulsesValue2ByteArray[0];
    //       pulseV2Int = pulseV2Int | (quint8)pulsesValue2ByteArray[1];
    //       if(pulseV2Int == 0) {
    //           QMessageBox::information(this, "", tr("Недопустимое для записи значение: pulsesValue2 ") + QString::number(pulseV2Int));
    //           return;
    //       }
           byte = pulsesValue2ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue2ByteArray);
           mapwrite["pulsesValue2ByteArray"] = pulsesValue2ByteArray;

           byte = devType[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(devType);
           mapwrite["devType"] = devType;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"porTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);;//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Software Configuration ") +
//                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Software Configuration ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa0;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Software Configuration ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Software Configuration ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Sensor Parameters 5a 00 18 2d
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x18;
           packetToRead.append(byte);
           byte = 0x2d;
           packetToRead.append(byte);

           byte = flowRateByteArray[0];
           packetToRead.append(byte);
           byte = flowRateByteArray[1];
           packetToRead.append(byte);
           byte = flowRateByteArray[2];
           packetToRead.append(byte);
           byte = flowRateByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowRateByteArray);
           mapwrite["flowRateByteArray"] = flowRateByteArray;


           byte = pressureByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pressureByteArray);
           mapwrite["pressureByteArray"] = pressureByteArray;


           byte = RTD_TypeByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RTD_TypeByteArray);
           mapwrite["RTD_TypeByteArray"] = RTD_TypeByteArray;


           byte = R_RTDByteArray[0];
           packetToRead.append(byte);
           byte = R_RTDByteArray[1];
           packetToRead.append(byte);
           byte = R_RTDByteArray[2];
           packetToRead.append(byte);
           byte = R_RTDByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(R_RTDByteArray);

           quint32 r_rtdInt = (quint8)R_RTDByteArray[0];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[1];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[2];
           r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[3];

           r_rtdInt = r_rtdInt/1000;

           QByteArray r_rtd_NotMultiplicationByteArray;
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>24));
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>16));
           r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>8));
           r_rtd_NotMultiplicationByteArray.append((quint8)r_rtdInt);
           mapwrite["R_RTDByteArray"] = r_rtd_NotMultiplicationByteArray; //проверять нужно неумноженное значение


           byte = RWire1ByteArray[0];
           packetToRead.append(byte);
           byte = RWire1ByteArray[1];
           packetToRead.append(byte);
           byte = RWire1ByteArray[2];
           packetToRead.append(byte);
           byte = RWire1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RWire1ByteArray);
           mapwrite["RWire1ByteArray"] = RWire1ByteArray;


           byte = RWire2ByteArray[0];
           packetToRead.append(byte);
           byte = RWire2ByteArray[1];
           packetToRead.append(byte);
           byte = RWire2ByteArray[2];
           packetToRead.append(byte);
           byte = RWire2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(RWire2ByteArray);
           mapwrite["RWire2ByteArray"] = RWire2ByteArray;


           byte = flowNomByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowNomByteArray);
           mapwrite["flowNomByteArray"] = flowNomByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Sensor Parameters ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Sensor Parameters ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xad;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Sensor Parameters ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Sensor Parameters ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Flow Coefficient 5a 00 1d 3d
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x1d;
           packetToRead.append(byte);
           byte = 0x3d;
           packetToRead.append(byte);

           byte = flowCoef0ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef0ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef0ByteArray);
           mapwrite["flowCoef0ByteArray"] = flowCoef0ByteArray;


           byte = flowCoef1ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef1ByteArray);
           mapwrite["flowCoef1ByteArray"] = flowCoef1ByteArray;


           byte = flowCoef2ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef2ByteArray);
           mapwrite["flowCoef2ByteArray"] = flowCoef2ByteArray;


           byte = flowCoef3ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef3ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef3ByteArray);
           mapwrite["flowCoef3ByteArray"] = flowCoef3ByteArray;


           byte = flowCoef4ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef4ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef4ByteArray);
           mapwrite["flowCoef4ByteArray"] = flowCoef4ByteArray;


           byte = flowCoef5ByteArray[0];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[1];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[2];
           packetToRead.append(byte);
           byte = flowCoef5ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowCoef5ByteArray);
           mapwrite["flowCoef5ByteArray"] = flowCoef5ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Flow Coefficient") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Flow Coefficient ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbd;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Flow Coefficient ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Flow Coefficient ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Differential Threshold 5a 00 07 3e
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x07;
           packetToRead.append(byte);
           byte = 0x3e;
           packetToRead.append(byte);

           byte = FS_DiffThrsByteArray[0];
           packetToRead.append(byte);
           byte = FS_DiffThrsByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(FS_DiffThrsByteArray);
           mapwrite["FS_DiffThrsByteArray"] = FS_DiffThrsByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Differential Threshold ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Differential Threshold ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbe;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Differential Threshold ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Differential Threshold ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Real Clock 5a 00 0d 22
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x0d;
           packetToRead.append(byte);
           byte = 0x22;
           packetToRead.append(byte);

           byte = hourByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(hourByteArray);
           mapwrite["hourByteArray"] = hourByteArray;


           byte = minuteByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(minuteByteArray);
           mapwrite["minuteByteArray"] = minuteByteArray;


           byte = secondByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(secondByteArray);
           mapwrite["secondByteArray"] = secondByteArray;

           byte = dayByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(dayByteArray);
           mapwrite["dayByteArray"] = dayByteArray;


           byte = monthByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(monthByteArray);
           mapwrite["monthByteArray"] = monthByteArray;


           byte = yearByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(yearByteArray);
           mapwrite["yearByteArray"] = yearByteArray;


           byte = DOWByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DOWByteArray);
           mapwrite["DOWByteArray"] = DOWByteArray;


           byte = ASW_flagByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ASW_flagByteArray);
           mapwrite["ASW_flagByteArray"] = ASW_flagByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Real Clock ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Real Clock ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa2;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Real Clock ") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Real Clock ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write Temperature Calibration Coefficient 5a 00 11 36
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x11;
           packetToRead.append(byte);
           byte = 0x36;
           packetToRead.append(byte);

           byte = shift_T1ByteArray[0];
           packetToRead.append(byte);
           byte = shift_T1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(shift_T1ByteArray);
           mapwrite["shift_T1ByteArray"] = shift_T1ByteArray;


           byte = shift_T2ByteArray[0];
           packetToRead.append(byte);
           byte = shift_T2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(shift_T2ByteArray);
           mapwrite["shift_T2ByteArray"] = shift_T2ByteArray;


           byte = scale_T1ByteArray[0];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[1];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[2];
           packetToRead.append(byte);
           byte = scale_T1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(scale_T1ByteArray);
           mapwrite["scale_T1ByteArray"] = scale_T1ByteArray;


           byte = scale_T2ByteArray[0];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[1];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[2];
           packetToRead.append(byte);
           byte = scale_T2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(scale_T2ByteArray);
           mapwrite["scale_T2ByteArray"] = scale_T2ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Temperature Calibration Coefficient ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Temperature Calibration Coefficient ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xb6;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных: Temperature Calibration Coefficient") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных: Temperature Calibration Coefficient ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write External Interface Settings 5a 00 0e 2b
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x0e;
           packetToRead.append(byte);
           byte = 0x2b;
           packetToRead.append(byte);

           byte = addrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(addrByteArray);
           mapwrite["addrByteArray"] = addrByteArray;


           byte = baudRateByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(baudRateByteArray);
           mapwrite["baudRateByteArray"] = baudRateByteArray;


           byte = HMP_TransByteArray[0];
           packetToRead.append(byte);
           byte = HMP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(HMP_TransByteArray);
           mapwrite["HMP_TransByteArray"] = HMP_TransByteArray;


           byte = EPP_TransByteArray[0];
           packetToRead.append(byte);
           byte = EPP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(EPP_TransByteArray);
           mapwrite["EPP_TransByteArray"] = EPP_TransByteArray;


           byte = P1PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P1PrimAddrByteArray);
           mapwrite["P1PrimAddrByteArray"] = P1PrimAddrByteArray;


           byte = P2PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P2PrimAddrByteArray);
           mapwrite["P2PrimAddrByteArray"] = P2PrimAddrByteArray;


           byte = ProtTypeByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ProtTypeByteArray);
           mapwrite["ProtTypeByteArray"] = ProtTypeByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Interface Settings ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : External Interface Settings ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xab;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                       QMessageBox::information(this, "", tr("Ошибка записи данных : External Interface Settings ") +
//                                                "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : External Interface Settings ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //Write External Device Settings  5a 00 25 3c
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x25;
           packetToRead.append(byte);
           byte = 0x3c;
           packetToRead.append(byte);

           byte = Serial_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Serial_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Serial_P1ByteArray);
           mapwrite["Serial_P1ByteArray"] = Serial_P1ByteArray;


           byte = ManCode_P1ByteArray[0];
           packetToRead.append(byte);
           byte = ManCode_P1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ManCode_P1ByteArray);
           mapwrite["ManCode_P1ByteArray"] = ManCode_P1ByteArray;


           byte = DevType_P1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DevType_P1ByteArray);
           mapwrite["DevType_P1ByteArray"] = DevType_P1ByteArray;


           byte = Version_P1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Version_P1ByteArray);
           mapwrite["Version_P1ByteArray"] = Version_P1ByteArray;


           byte = Initial_value_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Initial_value_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Initial_value_P1ByteArray);
           mapwrite["Initial_value_P1ByteArray"] = Initial_value_P1ByteArray;


           byte = Service_P1ByteArray[0];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[1];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[2];
           packetToRead.append(byte);
           byte = Service_P1ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Service_P1ByteArray);
           mapwrite["Service_P1ByteArray"] = Service_P1ByteArray;


           byte = Serial_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Serial_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Serial_P2ByteArray);
           mapwrite["Serial_P2ByteArray"] = Serial_P2ByteArray;


           byte = ManCode_P2ByteArray[0];
           packetToRead.append(byte);
           byte = ManCode_P2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ManCode_P2ByteArray);
           mapwrite["ManCode_P2ByteArray"] = ManCode_P2ByteArray;


           byte = DevType_P2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(DevType_P2ByteArray);
           mapwrite["DevType_P2ByteArray"] = DevType_P2ByteArray;


           byte = Version_P2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Version_P2ByteArray);
           mapwrite["Version_P2ByteArray"] = Version_P2ByteArray;


           byte = Initial_value_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Initial_value_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Initial_value_P2ByteArray);
           mapwrite["Initial_value_P2ByteArray"] = Initial_value_P2ByteArray;


           byte = Service_P2ByteArray[0];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[1];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[2];
           packetToRead.append(byte);
           byte = Service_P2ByteArray[3];
           packetToRead.append(byte);
           paramsVectorToWrite.append(Service_P2ByteArray);
           mapwrite["Service_P2ByteArray"] = Service_P2ByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Device Settings ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : External Device Settings ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xbc;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : External Device Settings") +
//                                               "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : External Device Settings ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkWritingError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }



        //
        //
        //проверка записанного. из списка проверяемых параметров удаляем те серийный номера и PCB_SN, которые не являются текущим для рабочего места

//        on_toolButton_readParams_clicked();

        readParams(workPlaceNumber);



        allParamsNameList.removeOne("minuteByteArray");
        allParamsNameList.removeOne("secondByteArray");
        allParamsNameList.removeOne("hourByteArray");

        switch (workPlaceNumber) {
        case 0:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 1:
           mapwrite["serialNumber"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 2:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber"] = "";
           mapwrite["serialNumber4"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber"] = "";
           mapRead["serialNumber4"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray"] = "";
           mapwrite["PCB_SN_ByteArray4"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray4"] = "";
            break;
        case 3:
           mapwrite["serialNumber2"] = "";
           mapwrite["serialNumber3"] = "";
           mapwrite["serialNumber"] = "";
           mapRead["serialNumber2"] = "";
           mapRead["serialNumber3"] = "";
           mapRead["serialNumber"] = "";

           mapwrite["PCB_SN_ByteArray2"] = "";
           mapwrite["PCB_SN_ByteArray3"] = "";
           mapwrite["PCB_SN_ByteArray"] = "";
           mapRead["PCB_SN_ByteArray2"] = "";
           mapRead["PCB_SN_ByteArray3"] = "";
           mapRead["PCB_SN_ByteArray"] = "";
            break;
        default:
            break;
        }



        for(int i=0; i<allParamsNameList.size(); i++) {
            qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
            qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();

            if((allParamsNameList[i] != "pulsesValue1ByteArray") && (allParamsNameList[i] != "pulsesValue2ByteArray")) {
               if(mapwrite[allParamsNameList[i]] != mapRead[allParamsNameList[i]]) {
//                   QMessageBox::information(this, "", "Параметр записан некорректно : " +
//                                            allParamsNameList[i] + " " + mapRead[allParamsNameList[i]].toHex());
                   ui->label_StatusBar->setText(tr("Параметр записан некорректно : ") + allParamsNameList[i] + " " +
                                                mapRead[allParamsNameList[i]].toHex() +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWritingError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
//                   ui->label_StatusBar->setText("Запись : Неудачно");
//                   ui->label_writeParams->setVisible(true);
                   return;
               }
            }

            //pulsesValue1
            if(allParamsNameList[i] == "pulsesValue1ByteArray") {
                quint16 pulsesValue1IntRead = mapRead["pulsesValue1ByteArray"].at(0);
                pulsesValue1IntRead = pulsesValue1IntRead<<8 | mapRead["pulsesValue1ByteArray"].at(1);

                quint16 pulsesValue1IntWrite = mapwrite["pulsesValue1ByteArray"].at(0);
                pulsesValue1IntWrite = pulsesValue1IntWrite<<8 | mapwrite["pulsesValue1ByteArray"].at(1);

                if((pulsesValue1IntRead <= (pulsesValue1IntWrite + 1)) && (pulsesValue1IntRead >= (pulsesValue1IntWrite - 1))) {

                }
                else {
//                    QMessageBox::information(this, "", "Параметр записан некорректно : pulsesValue1 " +
//                                             QString::number(pulsesValue1IntRead));
                    ui->label_StatusBar->setText(tr("Параметр записан некорректно : pulsesValue1 ") +
                                                 QString::number(pulsesValue1IntRead) +
                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
                    errorString.append(ui->label_StatusBar->text() + '\n');
                    vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                    checkWritingError(currentIndicatorNumber);
                    workPlaceOff(currentIndicatorNumber);
//                    ui->label_StatusBar->setText("Запись : Неудачно");
//                    ui->label_writeParams->setVisible(true);
                    return;
                }
            }

            //pulsesValue2
            if(allParamsNameList[i] == "pulsesValue2ByteArray") {
                quint16 pulsesValue2IntRead = mapRead["pulsesValue2ByteArray"].at(0);
                pulsesValue2IntRead = pulsesValue2IntRead<<8 | mapRead["pulsesValue2ByteArray"].at(1);

                quint16 pulsesValue2IntWrite = mapwrite["pulsesValue2ByteArray"].at(0);
                pulsesValue2IntWrite = pulsesValue2IntWrite<<8 | mapwrite["pulsesValue2ByteArray"].at(1);

                if((pulsesValue2IntRead <= (pulsesValue2IntWrite + 1)) && (pulsesValue2IntRead >= (pulsesValue2IntWrite - 1))) {

                }
                else {
//                    QMessageBox::information(this, "", "Параметр записан некорректно : pulsesValue2 " +
//                                             QString::number(pulsesValue2IntRead));
                    ui->label_StatusBar->setText(tr("Параметр записан некорректно : pulsesValue2 ") +
                                                 QString::number(pulsesValue2IntRead) +
                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
                    errorString.append(ui->label_StatusBar->text() + '\n');
                    vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                    checkWritingError(currentIndicatorNumber);
                    workPlaceOff(currentIndicatorNumber);
//                    ui->label_StatusBar->setText("Запись : Неудачно");
//                    ui->label_writeParams->setVisible(true);
                    return;
                }
            }

        }

  //      ui->label_StatusBar->setText("Запись : Успешно ");

        ui->label_writeParams->setStyleSheet(QString("color: green").arg(color.name()));
        ui->label_writeParams->setText("V");
  //      ui->label_writeParams->setVisible(true);



//        vectorIsErrorOccured[workPlaceNumber] = true;



//        isNeedPaintEvent = true;
//        switch (currentIndicatorNumber) {
//        case 0:
//            isWritingFinished1 = true;
//            break;
//        case 1:
//            isWritingFinished2 = true;
//            break;
//        case 2:
//            isWritingFinished3 = true;
//            break;
//        case 3:
//            isWritingFinished4 = true;
//            break;
//        default:
//            break;
//        }
//        repaint();
//        isNeedPaintEvent = false;

        checkWritingError(currentIndicatorNumber);



}
/**********************************************************/
void MainWindow::on_toolButton_writeParams_clicked()
{
    timerWriteParams.start(10000);

    bool ok;
    ProtTypeByteArray.clear();
    quint8 byteProtType = 0xff;
    ProtTypeByteArray.append(byteProtType);

    ui->label_writeParams->setVisible(false);
    ui->label_Calibration->setVisible(false);
    ui->label_pulsesOutputHeat->setVisible(false);
    ui->label_pulsesInputVolume->setVisible(false);
    ui->label_pulsesOutputOff->setVisible(false);
    ui->label_MBusOn->setVisible(false);
    ui->label_MBusOff->setVisible(false);
    ui->label_CheckMbus->setVisible(false);
    ui->label_digitalWireInterfaceChecking->setVisible(false);
    ui->label_RMV_ErrorFlags_tick->setVisible(false);
    ui->label_calibrationModeOff->setVisible(false);
    ui->label_realClockCalibration->setVisible(false);

    ui->lineEdit_RMV_ErrorFlags->setText("");

    QColor color(255, 127, 50);
    ui->label_writeParams->setStyleSheet(QString("color: red").arg(color.name()));
    ui->label_writeParams->setText("X");
    ui->label_writeParams->setVisible(false);

    ui->label_StatusBar->setText("");

    //
    pulsesMode1ByteArray.clear();
    pulsesMode2ByteArray.clear();

    pulsesMode1ByteArray.append(pulsesMode1PrimalInt); //append(byte);
    pulsesMode2ByteArray.append(pulsesMode2PrimalInt); //append(byte);
    //
    //
    if(pulsesValue1PrimeInt == 0) {
        QMessageBox::information(this, "", tr("Недоустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt));
        return;
    }
    if(pulsesValue2PrimeInt == 0) {
        QMessageBox::information(this, "", tr("Недоустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt));
        return;
    }
    pulsesValue1ByteArray.clear();
    pulsesValue2ByteArray.clear();
    pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt>>8));
    pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt));

    pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt>>8));
    pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt));
    //

    bool isWritingCorrect = false;

    paramsVectorToWrite.clear();

    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
            return;
        }
    }


    //
    //Set Password Default 5a 00 07 42 23 17
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x07;
       packetToRead.append(byte);
       byte = 0x42;
       packetToRead.append(byte);
       byte = 0x23;
       packetToRead.append(byte);
       byte = 0x17;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию"));
               ui->label_writeParams->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xc2;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);



              //
              //



              break;
           }
           else {
                    if(i==2) {
                        QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию"));
                        ui->label_writeParams->setVisible(true);
                        return;
                    }

           }



       }


    }

    //
    //Открыть парольную сессию 5a 00 08 40 01 04 57
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x08;
       packetToRead.append(byte);
       byte = 0x40;
       packetToRead.append(byte);
       byte = 0x01;
       packetToRead.append(byte);
       byte = 0x04;
       packetToRead.append(byte);
       byte = 0x57;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
               ui->label_writeParams->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xc0;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);


              //
              //



              break;
           }
           else {
                    if(i==2) {
                        QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
                        ui->label_writeParams->setVisible(true);
                        return;
                    }

           }



       }


    }


    //
    //Write Hardware Configuration 5a 00 15 29 serial(4) manCode(2) devType(1) DN(1)
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x15;
       packetToRead.append(byte);
       byte = 0x29;
       packetToRead.append(byte);

       byte = serialNumber[0];
       packetToRead.append(byte);
       byte = serialNumber[1];
       packetToRead.append(byte);
       byte = serialNumber[2];
       packetToRead.append(byte);
       byte = serialNumber[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(serialNumber);
       mapwrite["serialNumber"] = serialNumber;


       byte = manCode[0];
       packetToRead.append(byte);
       byte = manCode[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(manCode);
       mapwrite["manCode"] = manCode;


       byte = devType[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(devType);
       mapwrite["devType"] = devType;


       byte = DN[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(DN);
       mapwrite["DN"] = DN;


       byte = PCB_SN_ByteArray[0];
       packetToRead.append(byte);
       byte = PCB_SN_ByteArray[1];
       packetToRead.append(byte);
       byte = PCB_SN_ByteArray[2];
       packetToRead.append(byte);
       byte = PCB_SN_ByteArray[3];
       packetToRead.append(byte);
       byte = PCB_SN_ByteArray[4];
       packetToRead.append(byte);
       byte = PCB_SN_ByteArray[5];
       packetToRead.append(byte);
       byte = PCB_SN_ByteArray[6];
       packetToRead.append(byte);
       byte = PCB_SN_ByteArray[7];
       packetToRead.append(byte);
       paramsVectorToWrite.append(PCB_SN_ByteArray);
       mapwrite["PCB_SN_ByteArray"] = PCB_SN_ByteArray;


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : Hardware Configuration"));
               ui->label_writeParams->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xa9;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
                     if(i==2) {
                         QMessageBox::information(this, "", tr("Ошибка записи данных : Hardware Configuration"));
                         ui->label_writeParams->setVisible(true);
                         return;
                     }

           }



       }


    }

    //
    //Write Software Configuration 5a 00 16 20
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x16;
       packetToRead.append(byte);
       byte = 0x20;
       packetToRead.append(byte);

       byte = flowMinByteArray[0];
       packetToRead.append(byte);
       byte = flowMinByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowMinByteArray);
       mapwrite["flowMinByteArray"] = flowMinByteArray;


       byte = flowMaxByteArray[0];
       packetToRead.append(byte);
       byte = flowMaxByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowMaxByteArray);
       mapwrite["flowMaxByteArray"] = flowMaxByteArray;


       byte = tinMinByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(tinMinByteArray);
       mapwrite["tinMinByteArray"] = tinMinByteArray;


       byte = tinMaxByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(tinMaxByteArray);
       mapwrite["tinMaxByteArray"] = tinMaxByteArray;


       byte = toutMinByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(toutMinByteArray);
       mapwrite["toutMinByteArray"] = toutMinByteArray;


       byte = toutMaxByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(toutMaxByteArray);
       mapwrite["toutMaxByteArray"] = toutMaxByteArray;


       byte = reportDataByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(reportDataByteArray);
       mapwrite["reportDataByteArray"] = reportDataByteArray;


       byte = averageTByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(averageTByteArray);
       mapwrite["averageTByteArray"] = averageTByteArray;


       byte = pulsesMode1ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesMode1ByteArray);
       mapwrite["pulsesMode1ByteArray"] = pulsesMode1ByteArray;


       byte = pulsesMode2ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesMode2ByteArray);
       mapwrite["pulsesMode2ByteArray"] = pulsesMode2ByteArray;


//       quint16 pulseV1Int = (quint8)pulsesValue1ByteArray[0];
//       pulseV1Int = pulseV1Int | (quint8)pulsesValue1ByteArray[1];
//       if(pulseV1Int == 0) {
//           QMessageBox::information(this, "", tr("Недопустимое для записи значение: pulsesValue1 ") + QString::number(pulseV1Int));
//           return;
//       }
       byte = pulsesValue1ByteArray[0];
       packetToRead.append(byte);
       byte = pulsesValue1ByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesValue1ByteArray);
       mapwrite["pulsesValue1ByteArray"] = pulsesValue1ByteArray;


//       quint16 pulseV2Int = (quint8)pulsesValue2ByteArray[0];
//       pulseV2Int = pulseV2Int | (quint8)pulsesValue2ByteArray[1];
//       if(pulseV2Int == 0) {
//           QMessageBox::information(this, "", tr("Недопустимое для записи значение: pulsesValue2 ") + QString::number(pulseV2Int));
//           return;
//       }
       byte = pulsesValue2ByteArray[0];
       packetToRead.append(byte);
       byte = pulsesValue2ByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesValue2ByteArray);
       mapwrite["pulsesValue2ByteArray"] = pulsesValue2ByteArray;

       byte = devType[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(devType);
       mapwrite["devType"] = devType;


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : Software Configuration"));
               ui->label_writeParams->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xa0;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных : Software Configuration"));
                  ui->label_writeParams->setVisible(true);
                  return;
               }
           }



       }


    }

    //
    //
    //Write Sensor Parameters 5a 00 18 2d
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x18;
       packetToRead.append(byte);
       byte = 0x2d;
       packetToRead.append(byte);

       byte = flowRateByteArray[0];
       packetToRead.append(byte);
       byte = flowRateByteArray[1];
       packetToRead.append(byte);
       byte = flowRateByteArray[2];
       packetToRead.append(byte);
       byte = flowRateByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowRateByteArray);
       mapwrite["flowRateByteArray"] = flowRateByteArray;


       byte = pressureByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pressureByteArray);
       mapwrite["pressureByteArray"] = pressureByteArray;


       byte = RTD_TypeByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(RTD_TypeByteArray);
       mapwrite["RTD_TypeByteArray"] = RTD_TypeByteArray;


       byte = R_RTDByteArray[0];
       packetToRead.append(byte);
       byte = R_RTDByteArray[1];
       packetToRead.append(byte);
       byte = R_RTDByteArray[2];
       packetToRead.append(byte);
       byte = R_RTDByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(R_RTDByteArray);

       quint32 r_rtdInt = (quint8)R_RTDByteArray[0];
       r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[1];
       r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[2];
       r_rtdInt = r_rtdInt<<8 | (quint8)R_RTDByteArray[3];

       r_rtdInt = r_rtdInt/1000;

       QByteArray r_rtd_NotMultiplicationByteArray;
       r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>24));
       r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>16));
       r_rtd_NotMultiplicationByteArray.append((quint8)(r_rtdInt>>8));
       r_rtd_NotMultiplicationByteArray.append((quint8)r_rtdInt);
       mapwrite["R_RTDByteArray"] = r_rtd_NotMultiplicationByteArray; //проверять нужно неумноженное значение


       byte = RWire1ByteArray[0];
       packetToRead.append(byte);
       byte = RWire1ByteArray[1];
       packetToRead.append(byte);
       byte = RWire1ByteArray[2];
       packetToRead.append(byte);
       byte = RWire1ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(RWire1ByteArray);
       mapwrite["RWire1ByteArray"] = RWire1ByteArray;


       byte = RWire2ByteArray[0];
       packetToRead.append(byte);
       byte = RWire2ByteArray[1];
       packetToRead.append(byte);
       byte = RWire2ByteArray[2];
       packetToRead.append(byte);
       byte = RWire2ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(RWire2ByteArray);
       mapwrite["RWire2ByteArray"] = RWire2ByteArray;


       byte = flowNomByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowNomByteArray);
       mapwrite["flowNomByteArray"] = flowNomByteArray;


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : Sensor Parameters"));
               ui->label_writeParams->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xad;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных : Sensor Parameters"));
                  ui->label_writeParams->setVisible(true);
                  return;
               }
           }



       }


    }

    //
    //
    //Write Flow Coefficient 5a 00 1d 3d
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x1d;
       packetToRead.append(byte);
       byte = 0x3d;
       packetToRead.append(byte);

       byte = flowCoef0ByteArray[0];
       packetToRead.append(byte);
       byte = flowCoef0ByteArray[1];
       packetToRead.append(byte);
       byte = flowCoef0ByteArray[2];
       packetToRead.append(byte);
       byte = flowCoef0ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowCoef0ByteArray);
       mapwrite["flowCoef0ByteArray"] = flowCoef0ByteArray;


       byte = flowCoef1ByteArray[0];
       packetToRead.append(byte);
       byte = flowCoef1ByteArray[1];
       packetToRead.append(byte);
       byte = flowCoef1ByteArray[2];
       packetToRead.append(byte);
       byte = flowCoef1ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowCoef1ByteArray);
       mapwrite["flowCoef1ByteArray"] = flowCoef1ByteArray;


       byte = flowCoef2ByteArray[0];
       packetToRead.append(byte);
       byte = flowCoef2ByteArray[1];
       packetToRead.append(byte);
       byte = flowCoef2ByteArray[2];
       packetToRead.append(byte);
       byte = flowCoef2ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowCoef2ByteArray);
       mapwrite["flowCoef2ByteArray"] = flowCoef2ByteArray;


       byte = flowCoef3ByteArray[0];
       packetToRead.append(byte);
       byte = flowCoef3ByteArray[1];
       packetToRead.append(byte);
       byte = flowCoef3ByteArray[2];
       packetToRead.append(byte);
       byte = flowCoef3ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowCoef3ByteArray);
       mapwrite["flowCoef3ByteArray"] = flowCoef3ByteArray;


       byte = flowCoef4ByteArray[0];
       packetToRead.append(byte);
       byte = flowCoef4ByteArray[1];
       packetToRead.append(byte);
       byte = flowCoef4ByteArray[2];
       packetToRead.append(byte);
       byte = flowCoef4ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowCoef4ByteArray);
       mapwrite["flowCoef4ByteArray"] = flowCoef4ByteArray;


       byte = flowCoef5ByteArray[0];
       packetToRead.append(byte);
       byte = flowCoef5ByteArray[1];
       packetToRead.append(byte);
       byte = flowCoef5ByteArray[2];
       packetToRead.append(byte);
       byte = flowCoef5ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowCoef5ByteArray);
       mapwrite["flowCoef5ByteArray"] = flowCoef5ByteArray;


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : Flow Coefficient"));
               ui->label_writeParams->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xbd;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных : Flow Coefficient"));
                  ui->label_writeParams->setVisible(true);
                  return;
               }
           }



       }


    }

    //
    //
    //Write Differential Threshold 5a 00 07 3e
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x07;
       packetToRead.append(byte);
       byte = 0x3e;
       packetToRead.append(byte);

       byte = FS_DiffThrsByteArray[0];
       packetToRead.append(byte);
       byte = FS_DiffThrsByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(FS_DiffThrsByteArray);
       mapwrite["FS_DiffThrsByteArray"] = FS_DiffThrsByteArray;


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : Differential Threshold"));
               ui->label_writeParams->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xbe;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных : Differential Threshold"));
                  ui->label_writeParams->setVisible(true);
                  return;
               }
           }



       }


    }

    //
    //
    //Write Real Clock 5a 00 0d 22
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x0d;
       packetToRead.append(byte);
       byte = 0x22;
       packetToRead.append(byte);

       byte = hourByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(hourByteArray);
       mapwrite["hourByteArray"] = hourByteArray;


       byte = minuteByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(minuteByteArray);
       mapwrite["minuteByteArray"] = minuteByteArray;


       byte = secondByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(secondByteArray);
       mapwrite["secondByteArray"] = secondByteArray;

       byte = dayByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(dayByteArray);
       mapwrite["dayByteArray"] = dayByteArray;


       byte = monthByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(monthByteArray);
       mapwrite["monthByteArray"] = monthByteArray;


       byte = yearByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(yearByteArray);
       mapwrite["yearByteArray"] = yearByteArray;


       byte = DOWByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(DOWByteArray);
       mapwrite["DOWByteArray"] = DOWByteArray;


       byte = ASW_flagByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(ASW_flagByteArray);
       mapwrite["ASW_flagByteArray"] = ASW_flagByteArray;


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : Real Clock"));
               ui->label_writeParams->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xa2;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных : Real Clock"));
                  ui->label_writeParams->setVisible(true);
                  return;
               }
           }



       }


    }

    //
    //
    //Write Temperature Calibration Coefficient 5a 00 11 36
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x11;
       packetToRead.append(byte);
       byte = 0x36;
       packetToRead.append(byte);

       byte = shift_T1ByteArray[0];
       packetToRead.append(byte);
       byte = shift_T1ByteArray[1];             
       packetToRead.append(byte);
       paramsVectorToWrite.append(shift_T1ByteArray);
       mapwrite["shift_T1ByteArray"] = shift_T1ByteArray;


       byte = shift_T2ByteArray[0];
       packetToRead.append(byte);
       byte = shift_T2ByteArray[1];      
       packetToRead.append(byte);
       paramsVectorToWrite.append(shift_T2ByteArray);
       mapwrite["shift_T2ByteArray"] = shift_T2ByteArray;


       byte = scale_T1ByteArray[0];
       packetToRead.append(byte);
       byte = scale_T1ByteArray[1];
       packetToRead.append(byte);       
       byte = scale_T1ByteArray[2];
       packetToRead.append(byte);
       byte = scale_T1ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(scale_T1ByteArray);
       mapwrite["scale_T1ByteArray"] = scale_T1ByteArray;


       byte = scale_T2ByteArray[0];
       packetToRead.append(byte);
       byte = scale_T2ByteArray[1];
       packetToRead.append(byte);
       byte = scale_T2ByteArray[2];
       packetToRead.append(byte);
       byte = scale_T2ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(scale_T2ByteArray);
       mapwrite["scale_T2ByteArray"] = scale_T2ByteArray;


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : Temperature Calibration Coefficient"));
               ui->label_writeParams->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xb6;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных: Temperature Calibration Coefficient"));
                  ui->label_writeParams->setVisible(true);
                  return;
               }
           }



       }


    }

    //
    //
    //Write External Interface Settings 5a 00 0e 2b
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x0e;
       packetToRead.append(byte);
       byte = 0x2b;
       packetToRead.append(byte);

       byte = addrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(addrByteArray);
       mapwrite["addrByteArray"] = addrByteArray;


       byte = baudRateByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(baudRateByteArray);
       mapwrite["baudRateByteArray"] = baudRateByteArray;


       byte = HMP_TransByteArray[0];
       packetToRead.append(byte);
       byte = HMP_TransByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(HMP_TransByteArray);
       mapwrite["HMP_TransByteArray"] = HMP_TransByteArray;


       byte = EPP_TransByteArray[0];
       packetToRead.append(byte);
       byte = EPP_TransByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(EPP_TransByteArray);
       mapwrite["EPP_TransByteArray"] = EPP_TransByteArray;


       byte = P1PrimAddrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(P1PrimAddrByteArray);
       mapwrite["P1PrimAddrByteArray"] = P1PrimAddrByteArray;


       byte = P2PrimAddrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(P2PrimAddrByteArray);
       mapwrite["P2PrimAddrByteArray"] = P2PrimAddrByteArray;


       byte = ProtTypeByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(ProtTypeByteArray);
       mapwrite["ProtTypeByteArray"] = ProtTypeByteArray;


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : External Interface Settings"));
               ui->label_writeParams->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xab;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных : External Interface Settings"));
                  ui->label_writeParams->setVisible(true);
                  return;
               }
           }



       }


    }

    //
    //
    //Write External Device Settings  5a 00 25 3c
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x25;
       packetToRead.append(byte);
       byte = 0x3c;
       packetToRead.append(byte);

       byte = Serial_P1ByteArray[0];
       packetToRead.append(byte);
       byte = Serial_P1ByteArray[1];
       packetToRead.append(byte);
       byte = Serial_P1ByteArray[2];
       packetToRead.append(byte);
       byte = Serial_P1ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(Serial_P1ByteArray);
       mapwrite["Serial_P1ByteArray"] = Serial_P1ByteArray;


       byte = ManCode_P1ByteArray[0];
       packetToRead.append(byte);
       byte = ManCode_P1ByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(ManCode_P1ByteArray);
       mapwrite["ManCode_P1ByteArray"] = ManCode_P1ByteArray;


       byte = DevType_P1ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(DevType_P1ByteArray);
       mapwrite["DevType_P1ByteArray"] = DevType_P1ByteArray;


       byte = Version_P1ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(Version_P1ByteArray);
       mapwrite["Version_P1ByteArray"] = Version_P1ByteArray;


       byte = Initial_value_P1ByteArray[0];
       packetToRead.append(byte);
       byte = Initial_value_P1ByteArray[1];
       packetToRead.append(byte);
       byte = Initial_value_P1ByteArray[2];
       packetToRead.append(byte);
       byte = Initial_value_P1ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(Initial_value_P1ByteArray);
       mapwrite["Initial_value_P1ByteArray"] = Initial_value_P1ByteArray;


       byte = Service_P1ByteArray[0];
       packetToRead.append(byte);
       byte = Service_P1ByteArray[1];
       packetToRead.append(byte);
       byte = Service_P1ByteArray[2];
       packetToRead.append(byte);
       byte = Service_P1ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(Service_P1ByteArray);
       mapwrite["Service_P1ByteArray"] = Service_P1ByteArray;


       byte = Serial_P2ByteArray[0];
       packetToRead.append(byte);
       byte = Serial_P2ByteArray[1];
       packetToRead.append(byte);
       byte = Serial_P2ByteArray[2];
       packetToRead.append(byte);
       byte = Serial_P2ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(Serial_P2ByteArray);
       mapwrite["Serial_P2ByteArray"] = Serial_P2ByteArray;


       byte = ManCode_P2ByteArray[0];
       packetToRead.append(byte);
       byte = ManCode_P2ByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(ManCode_P2ByteArray);
       mapwrite["ManCode_P2ByteArray"] = ManCode_P2ByteArray;


       byte = DevType_P2ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(DevType_P2ByteArray);
       mapwrite["DevType_P2ByteArray"] = DevType_P2ByteArray;


       byte = Version_P2ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(Version_P2ByteArray);
       mapwrite["Version_P2ByteArray"] = Version_P2ByteArray;


       byte = Initial_value_P2ByteArray[0];
       packetToRead.append(byte);
       byte = Initial_value_P2ByteArray[1];
       packetToRead.append(byte);
       byte = Initial_value_P2ByteArray[2];
       packetToRead.append(byte);
       byte = Initial_value_P2ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(Initial_value_P2ByteArray);
       mapwrite["Initial_value_P2ByteArray"] = Initial_value_P2ByteArray;


       byte = Service_P2ByteArray[0];
       packetToRead.append(byte);
       byte = Service_P2ByteArray[1];
       packetToRead.append(byte);
       byte = Service_P2ByteArray[2];
       packetToRead.append(byte);
       byte = Service_P2ByteArray[3];
       packetToRead.append(byte);
       paramsVectorToWrite.append(Service_P2ByteArray);
       mapwrite["Service_P2ByteArray"] = Service_P2ByteArray;


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : External Device Settings"));
               ui->label_writeParams->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xbc;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных : External Device Settings"));
                  ui->label_writeParams->setVisible(true);
                  return;
               }
           }



       }


    }



    on_toolButton_readParams_clicked();


//    if(paramsVector == paramsVectorToWrite) {
//        ui->label_StatusBar->setText("Запись : успешно ");
//    }
//    else {
//        QMessageBox::information(this, "", "Запись прошла некорректно");
//        qDebug()<<"paramsVector.size() "<<paramsVector.size()
//                <<"paramsVectorToWrite.size()"<<paramsVectorToWrite.size();
//        qDebug()<<"paramsVectorToWrite "<<paramsVectorToWrite.toList();
//        qDebug()<<"paramsVector "<<paramsVector.toList();

//        if(paramsVector.size() == paramsVectorToWrite.size()) {
//            for(int i=0; i<paramsVector.size(); i++) {
//                if(paramsVector[i] != paramsVectorToWrite[i]) {
//                    qDebug()<<"i= "<<i;
//                    qDebug()<<"paramsVector[i]"<<paramsVector[i].toHex()
//                            <<"paramsVectorToWrite[i]"<<paramsVectorToWrite[i].toHex();
//                }
//            }
//        }


//    }

    allParamsNameList.removeOne("minuteByteArray");
    allParamsNameList.removeOne("secondByteArray");

    for(int i=0; i<allParamsNameList.size(); i++) {
        qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
        qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();

        if((allParamsNameList[i] != "pulsesValue1ByteArray") && (allParamsNameList[i] != "pulsesValue2ByteArray")) {
           if(mapwrite[allParamsNameList[i]] != mapRead[allParamsNameList[i]]) {
               QMessageBox::information(this, "", "Параметр записан некорректно : " +
                                        allParamsNameList[i] + mapRead[allParamsNameList[i]].toHex());
               ui->label_StatusBar->setText("Запись : Неудачно");
               ui->label_writeParams->setVisible(true);
               return;
           }
        }

        //pulsesValue1
        if(allParamsNameList[i] == "pulsesValue1ByteArray") {
            quint16 pulsesValue1IntRead = mapRead["pulsesValue1ByteArray"].at(0);
            pulsesValue1IntRead = pulsesValue1IntRead<<8 | mapRead["pulsesValue1ByteArray"].at(1);

            quint16 pulsesValue1IntWrite = mapwrite["pulsesValue1ByteArray"].at(0);
            pulsesValue1IntWrite = pulsesValue1IntWrite<<8 | mapwrite["pulsesValue1ByteArray"].at(1);

            if((pulsesValue1IntRead <= (pulsesValue1IntWrite + 1)) && (pulsesValue1IntRead >= (pulsesValue1IntWrite - 1))) {

            }
            else {
                QMessageBox::information(this, "", "Параметр записан некорректно : pulsesValue1 " +
                                         QString::number(pulsesValue1IntRead));
                ui->label_StatusBar->setText("Запись : Неудачно");
                ui->label_writeParams->setVisible(true);
                return;
            }
        }

        //pulsesValue2
        if(allParamsNameList[i] == "pulsesValue2ByteArray") {
            quint16 pulsesValue2IntRead = mapRead["pulsesValue2ByteArray"].at(0);
            pulsesValue2IntRead = pulsesValue2IntRead<<8 | mapRead["pulsesValue2ByteArray"].at(1);

            quint16 pulsesValue2IntWrite = mapwrite["pulsesValue2ByteArray"].at(0);
            pulsesValue2IntWrite = pulsesValue2IntWrite<<8 | mapwrite["pulsesValue2ByteArray"].at(1);

            if((pulsesValue2IntRead <= (pulsesValue2IntWrite + 1)) && (pulsesValue2IntRead >= (pulsesValue2IntWrite - 1))) {

            }
            else {
                QMessageBox::information(this, "", "Параметр записан некорректно : pulsesValue1 " +
                                         QString::number(pulsesValue2IntRead));
                ui->label_StatusBar->setText("Запись : Неудачно");
                ui->label_writeParams->setVisible(true);
                return;
            }
        }

    }

    ui->label_StatusBar->setText("Запись : Успешно ");
    ui->label_writeParams->setStyleSheet(QString("color: green").arg(color.name()));
    ui->label_writeParams->setText("V");
    ui->label_writeParams->setVisible(true);

}
/**********************************************************/
void MainWindow::readPassword()
{
    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
            return;
        }
    }

    //
    //Read Password 5a 00 07 4f 23 17
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x07;
       packetToRead.append(byte);
       byte = 0x4f;
       packetToRead.append(byte);
       byte = 0x23;
       packetToRead.append(byte);
       byte = 0x17;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x07;
           bytesForChecking.append(byte);
           byte = 0xcf;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               QMessageBox::information(this, "", tr("Ошибка данных"));
               return;
           }



       }


    }



}
/*****************************************************************/
void MainWindow::on_toolButton_readPassword_clicked()
{
    readPassword();
}
/*****************************************************************/
void MainWindow::on_spinBox_serial_valueChanged(const QString &arg1)
{
//    emit signalSendSerial(arg1);

//    QString argStr = arg1; //= arg1.left(ui->spinBox_numberZavod->cursorPosition());

//    manufacturerNumberResult = arg1;

//            if(argStr.length()>5) {
//                argStr = argStr.left(5);  // ui->lineEdit_numberZavod->setText(argStr.left(5));
//     //           return;
//            }

//    if(argStr.length()<8) {
//        //добавляем нули до 5 цифр
//        int len = argStr.length();

//        for(int p=0; p<(8-len); p++) {
//            argStr.insert(0, '0');
//        }
//    }

//    qDebug()<<"argStr "<<argStr;
}
/*****************************************************************/
void MainWindow::on_lineEdit_serial_textChanged(const QString &arg1)
{
    //проверка позиции курсора при вводе или удаление всех символов после него
    QString argStr = arg1;// = arg1.left(ui->lineEdit_serial->cursorPosition());

 //   ui->lineEdit_serial->setText(argStr);

    //
    emit signalSendSerial(argStr + ui->spinBox_serial_->text());

 //   manufacturerNumberResult = arg1;

 //   qDebug()<<"manufacturerNumberResult "<<manufacturerNumberResult;

}
/*****************************************************************/
void MainWindow::on_comboBox_ManCode_currentIndexChanged(const QString &arg1)
{
//    manCode.clear();

//    QString str = arg1.toUpper();

// //  QByteArray manufacturerFromLineEdit = arg1.toLocal8Bit();
//   QByteArray manufacturerFromLineEdit = str.toLocal8Bit();
// //   manufacturerFromLineEdit = manufacturerFromLineEdit.toInt();
//   quint16 manufacturerSum = (static_cast<quint8>(manufacturerFromLineEdit[0])-64)*32*32 +
//                              (static_cast<quint8>(manufacturerFromLineEdit[1])-64)*32 +
//                               (static_cast<quint8>(manufacturerFromLineEdit[2])-64);
//   quint8 byte = (quint8)(manufacturerSum>>8);
//   manCode.append(byte);
//   byte = (quint8)manufacturerSum;
//   manCode.append(byte);
// //   quint8 x = manufacturerFromLineEdit[0];//byteArray[0];
// //   quint8 y = manufacturerFromLineEdit[1];//byteArray[1];
// //   quint8 z = manufacturerFromLineEdit[2];//byteArray[2];
//   quint8 symbol1, symbol2, symbol3;
//   symbol1 = ((manufacturerSum/(32*32))&0x1F) + 64;
//   symbol2 = ((manufacturerSum/32)&0x1F) + 64;
//   symbol3 = (manufacturerSum&0x1F) + 64;
//   QByteArray manufacturerString;
//   manufacturerString[0] = symbol1;
//   manufacturerString[1] = symbol2;
//   manufacturerString[2] = symbol3;
//   qDebug()<<"symbol1 "<<QString::number(symbol1)<<" symbol2 "<<QString::number(symbol2)<<" symbol3 "<<QString::number(symbol3);
//   qDebug()<<"manufacturerFromLineEdit"<<manufacturerFromLineEdit;
//   qDebug()<<"manufacturerFromLineEditHex"<<manufacturerFromLineEdit.toHex();
//   qDebug()<<"manufacturerSum"<<manufacturerSum;
}
/*****************************************************************/
void MainWindow::on_comboBox_DevType_currentIndexChanged(const QString &arg1)
{
//    devType.clear();
//    bool ok;
//    devType.append((quint8)arg1.toInt(&ok, 16));
}
/*****************************************************************/
void MainWindow::on_comboBox_DN_currentIndexChanged(const QString &arg1)
{
//    DN.clear();
//    bool ok;
//    DN.append((quint8)arg1.toInt(&ok, 10));
}
/*****************************************************************/
void MainWindow::on_lineEdit_Flow_min_textChanged(const QString &arg1)
{
//    flowMinByteArray.clear();
//    bool ok;
//    QString str = arg1;
//       if(str.contains(",")) {
//             str.replace(",", ".");
//       }
// //       qDebug()<<"str"<<str;
// //       qDebug()<<"str.toFloat() "<<str.toFloat(&ok);

//    float flowMinFloat = str.toFloat(&ok);
//    if(ok == false) {
//        QMessageBox::information(this, "", "Не удалось преобразовать flowMin в тип float");
//        return;
//    }

// //    if(flowMinFloat<0.008) {
// //        ui->lineEdit_Flow_min->setText("0.008");
// //    }
// //    if(flowMinFloat>0.2) {
// //        ui->lineEdit_Flow_min->setText("0.2");
// //    }

//    flowMinFloat = flowMinFloat*1000;

//    quint16 flowMinInt = (quint16)flowMinFloat;
// //    qDebug()<<"flowMinInt "<<flowMinInt;

//    flowMinByteArray.append((quint8)(flowMinInt>>8));
//    flowMinByteArray.append((quint8)flowMinInt);

// //    qDebug()<<"flowMinByteArray.toHex() "<<flowMinByteArray.toHex();


}
/*****************************************************************/
void MainWindow::on_lineEdit_Flow_max_textChanged(const QString &arg1)
{
//    flowMaxByteArray.clear();

//    bool ok;
//    QString str = arg1;
//       if(str.contains(",")) {
//             str.replace(",", ".");
//       }
// //       qDebug()<<"str"<<str;
// //       qDebug()<<"str.toFloat() "<<str.toFloat(&ok);

//    float flowMaxFloat = str.toFloat(&ok);
//    if(ok == false) {
//        QMessageBox::information(this, "", "Не удалось преобразовать flowMax в тип float");
//        return;
//    }

//    flowMaxFloat = flowMaxFloat*1000;

//    quint16 flowMaxInt = (quint16)flowMaxFloat;
// //    qDebug()<<"flowMaxInt "<<flowMaxInt;

//    flowMaxByteArray.append((quint8)(flowMaxInt>>8));
//    flowMaxByteArray.append((quint8)flowMaxInt);

// //    qDebug()<<"flowMaxByteArray.toHex() "<<flowMaxByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_spinBox_Tin_min_valueChanged(int arg1)
{
//    tinMinByteArray.clear();
//    tinMinByteArray.append((quint8)arg1);

//    qDebug()<<"tinMinByteArray.toHex()"<<tinMinByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_spinBox_Tin_max_valueChanged(int arg1)
{
//    tinMaxByteArray.clear();
//    tinMaxByteArray.append((quint8)arg1);

//    qDebug()<<"tinMaxByteArray.toHex()"<<tinMaxByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_spinBox_Tout_min_valueChanged(int arg1)
{
//    toutMinByteArray.clear();
//    toutMinByteArray.append((quint8)arg1);

//    qDebug()<<"toutMinByteArray.toHex()"<<toutMinByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_spinBox_Tout_max_valueChanged(int arg1)
{
//    toutMaxByteArray.clear();
//    toutMaxByteArray.append((quint8)arg1);

//    qDebug()<<"toutMaxByteArray.toHex()"<<toutMaxByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_spinBox_ReportData_valueChanged(int arg1)
{
//    reportDataByteArray.clear();
//    reportDataByteArray.append((quint8)arg1);

//    qDebug()<<"reportDataByteArray.toHex()"<<reportDataByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_comboBox_Average_T_currentIndexChanged(const QString &arg1)
{
//    averageTByteArray.clear();
//    bool ok;
//    averageTByteArray.append((quint8)(arg1.toInt(&ok, 10)));

//    qDebug()<<"averageTByteArray.toHex().toHex()"<<averageTByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_comboBox_PulsesMode1_currentIndexChanged(const QString &arg1)
{
//    pulsesMode1ByteArray.clear();
//    bool ok;
//    pulsesMode1ByteArray.append((quint8)(arg1.toInt(&ok, 10)));

//    qDebug()<<"pulsesMode1ByteArray.toHex().toHex()"<<pulsesMode1ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_comboBox_PulsesMode2_currentIndexChanged(const QString &arg1)
{
//    pulsesMode2ByteArray.clear();
//    bool ok;
//    pulsesMode2ByteArray.append((quint8)(arg1.toInt(&ok, 10)));

//    qDebug()<<"pulsesMode2ByteArray.toHex().toHex()"<<pulsesMode2ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_comboBox_FlowRate_currentIndexChanged(const QString &arg1)
{
//    flowRateByteArray.clear();
//    float flowRateFloat = arg1.toFloat();
//    quint32 flowRateInt = (quint32)(flowRateFloat*1000);

//    flowRateByteArray.append((quint8)(flowRateInt>>24));
//    flowRateByteArray.append((quint8)(flowRateInt>>16));
//    flowRateByteArray.append((quint8)(flowRateInt>>8));
//    flowRateByteArray.append((quint8)flowRateInt);

//    qDebug()<<"flowRateByteArray.toHex() "<<flowRateByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Pressure_textChanged(const QString &arg1)
{
//    pressureByteArray.clear();
//    bool ok;
//    pressureByteArray.append((quint8)arg1.toInt(&ok, 10));

//    qDebug()<<"pressureByteArray.toHex() "<<pressureByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_comboBox_RTD_Type_currentIndexChanged(const QString &arg1)
{
//    RTD_TypeByteArray.clear();
//    bool ok;
//    RTD_TypeByteArray.append((quint8)arg1.toInt(&ok, 10));

//    qDebug()<<"RTD_TypeByteArray.toHex() "<<RTD_TypeByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_R_RTD_textChanged(const QString &arg1)
{
//    R_RTDByteArray.clear();
//    bool ok;
//    quint32 R_RTDInt = arg1.toInt(&ok, 10)*1000;
//    R_RTDByteArray.append((quint8)(R_RTDInt>>24));
//    R_RTDByteArray.append((quint8)(R_RTDInt>>16));
//    R_RTDByteArray.append((quint8)(R_RTDInt>>8));
//    R_RTDByteArray.append((quint8)R_RTDInt);

//    qDebug()<<"R_RTDByteArray.toHex() "<<R_RTDByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_RWire1_textChanged(const QString &arg1)
{
//    RWire1ByteArray.clear();
//    bool ok;
//    quint32 RWire1Int = arg1.toInt(&ok, 10);
//    RWire1ByteArray.append((quint8)(RWire1Int>>24));
//    RWire1ByteArray.append((quint8)(RWire1Int>>16));
//    RWire1ByteArray.append((quint8)(RWire1Int>>8));
//    RWire1ByteArray.append((quint8)RWire1Int);

//    qDebug()<<"RWire1ByteArray.toHex() "<<RWire1ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_RWire2_textChanged(const QString &arg1)
{
//    RWire2ByteArray.clear();
//    bool ok;
//    quint32 RWire2Int = arg1.toInt(&ok, 10);
//    RWire2ByteArray.append((quint8)(RWire2Int>>24));
//    RWire2ByteArray.append((quint8)(RWire2Int>>16));
//    RWire2ByteArray.append((quint8)(RWire2Int>>8));
//    RWire2ByteArray.append((quint8)RWire2Int);

//    qDebug()<<"RWire2ByteArray.toHex() "<<RWire2ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_comboBox_FlowNom_currentIndexChanged(const QString &arg1)
{
//    flowNomByteArray.clear();
//    float flowNomFloat = arg1.toFloat();
//    quint8 flowNomInt = (quint8)(flowNomFloat*10);

//    flowNomByteArray.append(flowNomInt);

//    qDebug()<<"flowNomByteArray.toHex() "<<flowNomByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_coef0_textChanged(const QString &arg1)
{
//    flowCoef0ByteArray.clear();
//    float flowCoef0Float = arg1.toFloat();
//    quint32 flowCoef0Int = (quint32)(flowCoef0Float*1000000);

//    flowCoef0ByteArray.append((quint8)(flowCoef0Int>>24));
//    flowCoef0ByteArray.append((quint8)(flowCoef0Int>>16));
//    flowCoef0ByteArray.append((quint8)(flowCoef0Int>>8));
//    flowCoef0ByteArray.append((quint8)flowCoef0Int);

}
/*****************************************************************/
void MainWindow::on_lineEdit_coef1_textChanged(const QString &arg1)
{
//    flowCoef1ByteArray.clear();
//    float flowCoef1Float = arg1.toFloat();
//    quint32 flowCoef1Int = (quint32)(flowCoef1Float*1000000);

//    flowCoef1ByteArray.append((quint8)(flowCoef1Int>>24));
//    flowCoef1ByteArray.append((quint8)(flowCoef1Int>>16));
//    flowCoef1ByteArray.append((quint8)(flowCoef1Int>>8));
//    flowCoef1ByteArray.append((quint8)flowCoef1Int);
}
/*****************************************************************/
void MainWindow::on_lineEdit_coef2_textChanged(const QString &arg1)
{
//    flowCoef2ByteArray.clear();
//    float flowCoef2Float = arg1.toFloat();
//    quint32 flowCoef2Int = (quint32)(flowCoef2Float*1000000);

//    flowCoef2ByteArray.append((quint8)(flowCoef2Int>>24));
//    flowCoef2ByteArray.append((quint8)(flowCoef2Int>>16));
//    flowCoef2ByteArray.append((quint8)(flowCoef2Int>>8));
//    flowCoef2ByteArray.append((quint8)flowCoef2Int);

//    qDebug()<<"flowCoef2ByteArray.toHex() "<<flowCoef2ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_coef3_textChanged(const QString &arg1)
{
//    flowCoef3ByteArray.clear();
//    float flowCoef3Float = arg1.toFloat();
//    quint32 flowCoef3Int = (quint32)(flowCoef3Float*1000000);

//    flowCoef3ByteArray.append((quint8)(flowCoef3Int>>24));
//    flowCoef3ByteArray.append((quint8)(flowCoef3Int>>16));
//    flowCoef3ByteArray.append((quint8)(flowCoef3Int>>8));
//    flowCoef3ByteArray.append((quint8)flowCoef3Int);

//    qDebug()<<"flowCoef3ByteArray.toHex() "<<flowCoef3ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_coef4_textChanged(const QString &arg1)
{
//    flowCoef4ByteArray.clear();
//    float flowCoef4Float = arg1.toFloat();
//    quint32 flowCoef4Int = (quint32)(flowCoef4Float*1000000);

//    flowCoef4ByteArray.append((quint8)(flowCoef4Int>>24));
//    flowCoef4ByteArray.append((quint8)(flowCoef4Int>>16));
//    flowCoef4ByteArray.append((quint8)(flowCoef4Int>>8));
//    flowCoef4ByteArray.append((quint8)flowCoef4Int);

//    qDebug()<<"flowCoef4ByteArray.toHex() "<<flowCoef4ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_coef5_textChanged(const QString &arg1)
{
//    flowCoef5ByteArray.clear();
//    float flowCoef5Float = arg1.toFloat();
//    quint32 flowCoef5Int = (quint32)(flowCoef5Float*1000000);

//    flowCoef5ByteArray.append((quint8)(flowCoef5Int>>24));
//    flowCoef5ByteArray.append((quint8)(flowCoef5Int>>16));
//    flowCoef5ByteArray.append((quint8)(flowCoef5Int>>8));
//    flowCoef5ByteArray.append((quint8)flowCoef5Int);

//    qDebug()<<"flowCoef5ByteArray.toHex() "<<flowCoef5ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_FS_DiffThrs_textChanged(const QString &arg1)
{
//    FS_DiffThrsByteArray.clear();
//    bool ok;
//    quint16 FS_DiffThrsInt = arg1.toInt(&ok, 10);
//    FS_DiffThrsByteArray.append((quint8)FS_DiffThrsInt>>8);
//    FS_DiffThrsByteArray.append((quint8)FS_DiffThrsInt);

//    qDebug()<<"FS_DiffThrsByteArray.toHex() "<<FS_DiffThrsByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_dateTimeEdit_realClock_dateTimeChanged(const QDateTime &dateTime)
{
//   hourByteArray.clear();
//   minuteByteArray.clear();
//   secondByteArray.clear();
//   dayByteArray.clear();
//   monthByteArray.clear();
//   yearByteArray.clear();
//   DOWByteArray.clear();
//   ASW_flagByteArray.clear();

//   QDate date = dateTime.date();
//   QTime time = dateTime.time();

//   hourByteArray.append((quint8)time.hour());
//   minuteByteArray.append((quint8)time.minute());
//   secondByteArray.append((quint8)time.second());
//   dayByteArray.append((quint8)date.day());
//   monthByteArray.append((quint8)date.month());
//   int year = date.year() - 2000;
//   yearByteArray.append((quint8)year);
//   DOWByteArray.append((quint8)date.dayOfWeek());

//   qDebug()<<"dateTime.toString() "<<dateTime.toString();

}
/*****************************************************************/
void MainWindow::on_comboBox_ASW_flag_currentIndexChanged(const QString &arg1)
{
//   ASW_flagByteArray.clear();
//   bool ok;
//   ASW_flagByteArray.append((quint8)arg1.toInt(&ok, 10));

//   qDebug()<<"ASW_flagByteArray.toHex() "<<ASW_flagByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Shift_T1_textChanged(const QString &arg1)
{
//    shift_T1ByteArray.clear();
//    float shift_T1Float = arg1.toFloat();
//    quint32 shift_T1Int = (quint32)(shift_T1Float*1000000);

//    shift_T1ByteArray.append((quint8)(shift_T1Int>>8));
//    shift_T1ByteArray.append((quint8)shift_T1Int);

//    qDebug()<<"shift_T1ByteArray.toHex() "<<shift_T1ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Shift_T2_textChanged(const QString &arg1)
{
//    shift_T2ByteArray.clear();
//    float shift_T2Float = arg1.toFloat();
//    quint32 shift_T2Int = (quint32)(shift_T2Float*1000000);

//    shift_T2ByteArray.append((quint8)(shift_T2Int>>8));
//    shift_T2ByteArray.append((quint8)shift_T2Int);

//    qDebug()<<"shift_T2ByteArray.toHex() "<<shift_T2ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Scale_T1_textChanged(const QString &arg1)
{
//    scale_T1ByteArray.clear();
//    float scale_T1Float = arg1.toFloat();
//    quint32 scale_T1Int = (quint32)(scale_T1Float*1000000);

//    scale_T1ByteArray.append((quint8)(scale_T1Int>>24));
//    scale_T1ByteArray.append((quint8)(scale_T1Int>>16));
//    scale_T1ByteArray.append((quint8)(scale_T1Int>>8));
//    scale_T1ByteArray.append((quint8)scale_T1Int);

//    qDebug()<<"scale_T1ByteArray.toHex() "<<scale_T1ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Scale_T2_textChanged(const QString &arg1)
{
//    scale_T2ByteArray.clear();
//    float scale_T2Float = arg1.toFloat();
//    quint32 scale_T2Int = (quint32)(scale_T2Float*1000000);

//    scale_T2ByteArray.append((quint8)(scale_T2Int>>24));
//    scale_T2ByteArray.append((quint8)(scale_T2Int>>16));
//    scale_T2ByteArray.append((quint8)(scale_T2Int>>8));
//    scale_T2ByteArray.append((quint8)scale_T2Int);

//    qDebug()<<"scale_T2ByteArray.toHex() "<<scale_T2ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_spinBox_Addr_valueChanged(int arg1)
{
//    addrByteArray.clear();
//    bool ok;
//    addrByteArray.append((quint8)arg1);

//    qDebug()<<"addrByteArray.toHex() "<<addrByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_comboBox_BaudRate_currentIndexChanged(const QString &arg1)
{
//    baudRateByteArray.clear();
//    bool ok;
//    baudRateByteArray.append((quint8)arg1.toInt(&ok, 16));

//    qDebug()<<"baudRateByteArray.toHex() "<<baudRateByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_HMP_Trans_textChanged(const QString &arg1)
{
//    HMP_TransByteArray.clear();
//    bool ok;
//    quint16 argInt = arg1.toInt(&ok, 16);
//    HMP_TransByteArray.append((quint8)argInt>>8);
//    HMP_TransByteArray.append((quint8)argInt);

//    qDebug()<<"HMP_TransByteArray.toHex() "<<HMP_TransByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_EPP_Trans_textChanged(const QString &arg1)
{
//    EPP_TransByteArray.clear();
//    bool ok;
//    quint16 argInt = arg1.toInt(&ok, 16);
//    EPP_TransByteArray.append((quint8)argInt>>8);
//    EPP_TransByteArray.append((quint8)argInt);

//    qDebug()<<"EPP_TransByteArray.toHex() "<<EPP_TransByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_spinBox_P1PrimAddr_valueChanged(int arg1)
{
//    P1PrimAddrByteArray.clear();
//    P1PrimAddrByteArray.append((quint8)arg1);

//    qDebug()<<"P1PrimAddrByteArray.toHex()"<<P1PrimAddrByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_spinBox_P2PrimAddr_valueChanged(int arg1)
{
//    P2PrimAddrByteArray.clear();
//    P2PrimAddrByteArray.append((quint8)arg1);

//    qDebug()<<"P2PrimAddrByteArray.toHex()"<<P2PrimAddrByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_ProtType_textChanged(const QString &arg1)
{
//    ProtTypeByteArray.clear();
//    bool ok;
//    ProtTypeByteArray.append((quint8)arg1.toInt(&ok, 16));

//    qDebug()<<"ProtTypeByteArray.toHex()"<<ProtTypeByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Serial_P1_textChanged(const QString &arg1)
{
//    Serial_P1ByteArray.clear();
//    bool ok;
//    quint32 Serial_P1Int = arg1.toInt(&ok, 16);
//    Serial_P1ByteArray.append((quint8)(Serial_P1Int>>24));
//    Serial_P1ByteArray.append((quint8)(Serial_P1Int>>16));
//    Serial_P1ByteArray.append((quint8)(Serial_P1Int>>8));
//    Serial_P1ByteArray.append((quint8)Serial_P1Int);

//    qDebug()<<"Serial_P1ByteArray.toHex() "<<Serial_P1ByteArray.toHex();

}
/*****************************************************************/
void MainWindow::on_lineEdit_ManCode_P1_textChanged(const QString &arg1)
{
//    ManCode_P1ByteArray.clear();
//    bool ok;
//    quint16 ManCode_P1Int = arg1.toInt(&ok, 16);
//    ManCode_P1ByteArray.append((quint8)(ManCode_P1Int>>8));
//    ManCode_P1ByteArray.append((quint8)ManCode_P1Int);

//    qDebug()<<"ManCode_P1ByteArray.toHex() "<<ManCode_P1ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_DevType_P1_textChanged(const QString &arg1)
{
//    DevType_P1ByteArray.clear();
//    bool ok;
//    quint8 DevType_P1Int = arg1.toInt(&ok, 16);
//    DevType_P1ByteArray.append((quint8)DevType_P1Int);

//    qDebug()<<"DevType_P1ByteArray.toHex() "<<DevType_P1ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Version_P1_textChanged(const QString &arg1)
{
//    Version_P1ByteArray.clear();
//    bool ok;
//    quint8 Version_P1Int = arg1.toInt(&ok, 10);
//    Version_P1ByteArray.append((quint8)Version_P1Int);

//    qDebug()<<"Version_P1ByteArray.toHex() "<<Version_P1ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Initial_value_P1_textChanged(const QString &arg1)
{
//    Initial_value_P1ByteArray.clear();
//    bool ok;
//    quint32 Initial_value_P1Int = arg1.toInt(&ok, 10);
//    Initial_value_P1ByteArray.append((quint8)(Initial_value_P1Int>>24));
//    Initial_value_P1ByteArray.append((quint8)(Initial_value_P1Int>>16));
//    Initial_value_P1ByteArray.append((quint8)(Initial_value_P1Int>>8));
//    Initial_value_P1ByteArray.append((quint8)Initial_value_P1Int);

//    qDebug()<<"Initial_value_P1ByteArray.toHex() "<<Initial_value_P1ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Service_P1_textChanged(const QString &arg1)
{
//    Service_P1ByteArray.clear();
//    bool ok;
//    quint32 Service_P1Int = arg1.toInt(&ok, 16);
//    Service_P1ByteArray.append((quint8)(Service_P1Int>>24));
//    Service_P1ByteArray.append((quint8)(Service_P1Int>>16));
//    Service_P1ByteArray.append((quint8)(Service_P1Int>>8));
//    Service_P1ByteArray.append((quint8)Service_P1Int);

//    qDebug()<<"Service_P1ByteArray.toHex() "<<Service_P1ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Serial_P2_textChanged(const QString &arg1)
{
//    Serial_P2ByteArray.clear();
//    bool ok;
//    quint32 Serial_P2Int = arg1.toInt(&ok, 16);
//    Serial_P2ByteArray.append((quint8)(Serial_P2Int>>24));
//    Serial_P2ByteArray.append((quint8)(Serial_P2Int>>16));
//    Serial_P2ByteArray.append((quint8)(Serial_P2Int>>8));
//    Serial_P2ByteArray.append((quint8)Serial_P2Int);

//    qDebug()<<"Serial_P2ByteArray.toHex() "<<Serial_P2ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_ManCode_P2_textChanged(const QString &arg1)
{
//    ManCode_P2ByteArray.clear();
//    bool ok;
//    quint16 ManCode_P2Int = arg1.toInt(&ok, 16);
//    ManCode_P2ByteArray.append((quint8)(ManCode_P2Int>>8));
//    ManCode_P2ByteArray.append((quint8)ManCode_P2Int);

//    qDebug()<<"ManCode_P2ByteArray.toHex() "<<ManCode_P2ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_DevType_P2_textChanged(const QString &arg1)
{
//    DevType_P2ByteArray.clear();
//    bool ok;
//    quint8 DevType_P2Int = arg1.toInt(&ok, 16);
//    DevType_P2ByteArray.append((quint8)DevType_P2Int);

//    qDebug()<<"DevType_P2ByteArray.toHex() "<<DevType_P2ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Version_P2_textChanged(const QString &arg1)
{
//    Version_P2ByteArray.clear();
//    bool ok;
//    quint8 Version_P2Int = arg1.toInt(&ok, 10);
//    Version_P2ByteArray.append((quint8)Version_P2Int);

//    qDebug()<<"Version_P2ByteArray.toHex() "<<Version_P2ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Initial_value_P2_textChanged(const QString &arg1)
{
//    Initial_value_P2ByteArray.clear();
//    bool ok;
//    quint32 Initial_value_P2Int = arg1.toInt(&ok, 10);
//    Initial_value_P2ByteArray.append((quint8)(Initial_value_P2Int>>24));
//    Initial_value_P2ByteArray.append((quint8)(Initial_value_P2Int>>16));
//    Initial_value_P2ByteArray.append((quint8)(Initial_value_P2Int>>8));
//    Initial_value_P2ByteArray.append((quint8)Initial_value_P2Int);

//    qDebug()<<"Initial_value_P2ByteArray.toHex() "<<Initial_value_P2ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_lineEdit_Service_P2_textChanged(const QString &arg1)
{
//    Service_P2ByteArray.clear();
//    bool ok;
//    quint32 Service_P2Int = arg1.toInt(&ok, 16);
//    Service_P2ByteArray.append((quint8)(Service_P2Int>>24));
//    Service_P2ByteArray.append((quint8)(Service_P2Int>>16));
//    Service_P2ByteArray.append((quint8)(Service_P2Int>>8));
//    Service_P2ByteArray.append((quint8)Service_P2Int);

//    qDebug()<<"Service_P2ByteArray.toHex() "<<Service_P2ByteArray.toHex();
}
/*****************************************************************/
void MainWindow::on_action_triggered()
{
    formParamsEdit->show();
}
/*****************************************************************/
void MainWindow::on_action_2_triggered()
{
    formCalibration->show();
}
/*****************************************************************/
void MainWindow::on_lineEdit_PCB_SN_textChanged(const QString &arg1)
{

}
/*****************************************************************/
void MainWindow::slotGetParamsMap(QMap<QString, QByteArray> paramsMap)
{
    qDebug()<<"MainWindow::slotGetParamsMap(QMap<QString, QByteArray> paramsMap)";

    //Read Software Configuration 5a000502
     serialNumber = paramsMap["serialNumber"];
     paramsMapToThreads["serialNumber"] = paramsMap["serialNumber"];

     serialNumber2 = paramsMap["serialNumber2"];
     paramsMapToThreads["serialNumber2"] = paramsMap["serialNumber2"];

     serialNumber3 = paramsMap["serialNumber3"];
     paramsMapToThreads["serialNumber3"] = paramsMap["serialNumber3"];

     serialNumber4 = paramsMap["serialNumber4"];
     paramsMapToThreads["serialNumber4"] = paramsMap["serialNumber4"];

     qDebug()<<"serialNumber.toHex() "<<serialNumber.toHex();
     qDebug()<<"serialNumber2.toHex() "<<serialNumber2.toHex();
     qDebug()<<"serialNumber3.toHex() "<<serialNumber3.toHex();
     qDebug()<<"serialNumber4.toHex() "<<serialNumber4.toHex();

     manCode = paramsMap["manCode"];
     paramsMapToThreads["manCode"] = paramsMap["manCode"];

     devType = paramsMap["devType"];
     paramsMapToThreads["devType"] = paramsMap["devType"];

     DN = paramsMap["DN"];
     paramsMapToThreads["DN"] = paramsMap["DN"];

     PCB_SN_ByteArray = paramsMap["PCB_SN_ByteArray"];
     paramsMapToThreads["PCB_SN_ByteArray"] = paramsMap["PCB_SN_ByteArray"];

     PCB_SN_ByteArray2 = paramsMap["PCB_SN_ByteArray2"];
     paramsMapToThreads["PCB_SN_ByteArray2"] = paramsMap["PCB_SN_ByteArray2"];

     PCB_SN_ByteArray3 = paramsMap["PCB_SN_ByteArray3"];
     paramsMapToThreads["PCB_SN_ByteArray3"] = paramsMap["PCB_SN_ByteArray3"];

     PCB_SN_ByteArray4 = paramsMap["PCB_SN_ByteArray4"];
     paramsMapToThreads["PCB_SN_ByteArray4"] = paramsMap["PCB_SN_ByteArray4"];


     flowMinByteArray = paramsMap["flowMinByteArray"];
     paramsMapToThreads["flowMinByteArray"] = paramsMap["flowMinByteArray"];

     flowMaxByteArray = paramsMap["flowMaxByteArray"];
     paramsMapToThreads["flowMaxByteArray"] = paramsMap["flowMaxByteArray"];

     tinMinByteArray = paramsMap["tinMinByteArray"];
     paramsMapToThreads["tinMinByteArray"] = paramsMap["tinMinByteArray"];

     tinMaxByteArray = paramsMap["tinMaxByteArray"];
     paramsMapToThreads["tinMaxByteArray"] = paramsMap["tinMaxByteArray"];

     toutMinByteArray = paramsMap["toutMinByteArray"];
     paramsMapToThreads["toutMinByteArray"] = paramsMap["toutMinByteArray"];

     toutMaxByteArray = paramsMap["toutMaxByteArray"];
     paramsMapToThreads["toutMaxByteArray"] = paramsMap["toutMaxByteArray"];

     reportDataByteArray = paramsMap["reportDataByteArray"];
     paramsMapToThreads["reportDataByteArray"] = paramsMap["reportDataByteArray"];

     averageTByteArray = paramsMap["averageTByteArray"];
     paramsMapToThreads["averageTByteArray"] = paramsMap["averageTByteArray"];

     pulsesMode1ByteArray = paramsMap["pulsesMode1ByteArray"];
     paramsMapToThreads["pulsesMode1ByteArray"] = paramsMap["pulsesMode1ByteArray"];

     pulsesMode2ByteArray = paramsMap["pulsesMode2ByteArray"];
     paramsMapToThreads["pulsesMode2ByteArray"] = paramsMap["pulsesMode2ByteArray"];

     pulsesValue1ByteArray = paramsMap["pulsesValue1ByteArray"];
     paramsMapToThreads["pulsesValue1ByteArray"] = paramsMap["pulsesValue1ByteArray"];

     pulsesValue2ByteArray = paramsMap["pulsesValue2ByteArray"];
     paramsMapToThreads["pulsesValue2ByteArray"] = paramsMap["pulsesValue2ByteArray"];

    //Read Sensor Parameters      5a00050b
     flowRateByteArray = paramsMap["flowRateByteArray"];
     paramsMapToThreads["flowRateByteArray"] = paramsMap["flowRateByteArray"];

     pressureByteArray = paramsMap["pressureByteArray"];
     paramsMapToThreads["pressureByteArray"] = paramsMap["pressureByteArray"];

     RTD_TypeByteArray = paramsMap["RTD_TypeByteArray"];
     paramsMapToThreads["RTD_TypeByteArray"] = paramsMap["RTD_TypeByteArray"];

     R_RTDByteArray = paramsMap["R_RTDByteArray"];
     paramsMapToThreads["R_RTDByteArray"] = paramsMap["R_RTDByteArray"];

     RWire1ByteArray = paramsMap["RWire1ByteArray"];
     paramsMapToThreads["RWire1ByteArray"] = paramsMap["RWire1ByteArray"];

     RWire2ByteArray = paramsMap["RWire2ByteArray"];
     paramsMapToThreads["RWire2ByteArray"] = paramsMap["RWire2ByteArray"];

     flowNomByteArray = paramsMap["flowNomByteArray"];
     paramsMapToThreads["flowNomByteArray"] = paramsMap["flowNomByteArray"];

    //Read Flow Coefficient  5a 00 05 1d
     flowCoef0ByteArray = paramsMap["flowCoef0ByteArray"];
     paramsMapToThreads["flowCoef0ByteArray"] = paramsMap["flowCoef0ByteArray"];

     flowCoef1ByteArray = paramsMap["flowCoef1ByteArray"];
     paramsMapToThreads["flowCoef1ByteArray"] = paramsMap["flowCoef1ByteArray"];

     flowCoef2ByteArray = paramsMap["flowCoef2ByteArray"];
     paramsMapToThreads["flowCoef2ByteArray"] = paramsMap["flowCoef2ByteArray"];

     flowCoef3ByteArray = paramsMap["flowCoef3ByteArray"];
     paramsMapToThreads["flowCoef3ByteArray"] = paramsMap["flowCoef3ByteArray"];

     flowCoef4ByteArray = paramsMap["flowCoef4ByteArray"];
     paramsMapToThreads["flowCoef4ByteArray"] = paramsMap["flowCoef4ByteArray"];

     flowCoef5ByteArray = paramsMap["flowCoef5ByteArray"];
     paramsMapToThreads["flowCoef5ByteArray"] = paramsMap["flowCoef5ByteArray"];

    //Read Calibration Factor 5a 00 05 06
     FS_DiffThrsByteArray = paramsMap["FS_DiffThrsByteArray"];
     paramsMapToThreads["FS_DiffThrsByteArray"] = paramsMap["FS_DiffThrsByteArray"];

    //Read Real Clock 5a 00 05 05
     hourByteArray = paramsMap["hourByteArray"];
     paramsMapToThreads["hourByteArray"] = paramsMap["hourByteArray"];

     minuteByteArray = paramsMap["minuteByteArray"];
     paramsMapToThreads["minuteByteArray"] = paramsMap["minuteByteArray"];

     secondByteArray = paramsMap["secondByteArray"];
     paramsMapToThreads["secondByteArray"] = paramsMap["secondByteArray"];

     dayByteArray = paramsMap["dayByteArray"];
     paramsMapToThreads["dayByteArray"] = paramsMap["dayByteArray"];

     monthByteArray = paramsMap["monthByteArray"];
     paramsMapToThreads["monthByteArray"] = paramsMap["monthByteArray"];

     yearByteArray = paramsMap["yearByteArray"];
     paramsMapToThreads["yearByteArray"] = paramsMap["yearByteArray"];

     DOWByteArray = paramsMap["DOWByteArray"];
     paramsMapToThreads["DOWByteArray"] = paramsMap["DOWByteArray"];

     ASW_flagByteArray = paramsMap["ASW_flagByteArray"];
     paramsMapToThreads["ASW_flagByteArray"] = paramsMap["ASW_flagByteArray"];

    //Read Calibration Factor
     shift_T1ByteArray = paramsMap["shift_T1ByteArray"];
     paramsMapToThreads["shift_T1ByteArray"] = paramsMap["shift_T1ByteArray"];

     shift_T2ByteArray = paramsMap["shift_T2ByteArray"];
     paramsMapToThreads["shift_T2ByteArray"] = paramsMap["shift_T2ByteArray"];

     scale_T1ByteArray = paramsMap["scale_T1ByteArray"];
     paramsMapToThreads["scale_T1ByteArray"] = paramsMap["scale_T1ByteArray"];

     scale_T2ByteArray = paramsMap["scale_T2ByteArray"];
     paramsMapToThreads["scale_T2ByteArray"] = paramsMap["scale_T2ByteArray"];

    //Read External Interface Settings
     addrByteArray = paramsMap["addrByteArray"];
     paramsMapToThreads["addrByteArray"] = paramsMap["addrByteArray"];

     baudRateByteArray = paramsMap["baudRateByteArray"];
     paramsMapToThreads["baudRateByteArray"] = paramsMap["baudRateByteArray"];

     HMP_TransByteArray = paramsMap["HMP_TransByteArray"];
     paramsMapToThreads["HMP_TransByteArray"] = paramsMap["HMP_TransByteArray"];

     EPP_TransByteArray = paramsMap["EPP_TransByteArray"];
     paramsMapToThreads["EPP_TransByteArray"] = paramsMap["EPP_TransByteArray"];

     P1PrimAddrByteArray = paramsMap["P1PrimAddrByteArray"];
     paramsMapToThreads["P1PrimAddrByteArray"] = paramsMap["P1PrimAddrByteArray"];

     P2PrimAddrByteArray = paramsMap["P2PrimAddrByteArray"];
     paramsMapToThreads["P2PrimAddrByteArray"] = paramsMap["P2PrimAddrByteArray"];

     ProtTypeByteArray = paramsMap["ProtTypeByteArray"];
     paramsMapToThreads["ProtTypeByteArray"] = paramsMap["ProtTypeByteArray"];

    //External Device Settings
     Serial_P1ByteArray = paramsMap["Serial_P1ByteArray"];
     paramsMapToThreads["Serial_P1ByteArray"] = paramsMap["Serial_P1ByteArray"];

     ManCode_P1ByteArray = paramsMap["ManCode_P1ByteArray"];
     paramsMapToThreads["ManCode_P1ByteArray"] = paramsMap["ManCode_P1ByteArray"];

     DevType_P1ByteArray = paramsMap["DevType_P1ByteArray"];
     paramsMapToThreads["DevType_P1ByteArray"] = paramsMap["DevType_P1ByteArray"];

     Version_P1ByteArray = paramsMap["Version_P1ByteArray"];
     paramsMapToThreads["Version_P1ByteArray"] = paramsMap["Version_P1ByteArray"];

     Initial_value_P1ByteArray = paramsMap["Initial_value_P1ByteArray"];
     paramsMapToThreads["Initial_value_P1ByteArray"] = paramsMap["Initial_value_P1ByteArray"];

     Service_P1ByteArray = paramsMap["Service_P1ByteArray"];
     paramsMapToThreads["Service_P1ByteArray"] = paramsMap["Service_P1ByteArray"];

     Serial_P2ByteArray = paramsMap["Serial_P2ByteArray"];
     paramsMapToThreads["Serial_P2ByteArray"] = paramsMap["Serial_P2ByteArray"];

     ManCode_P2ByteArray = paramsMap["ManCode_P2ByteArray"];
     paramsMapToThreads["ManCode_P2ByteArray"] = paramsMap["ManCode_P2ByteArray"];

     DevType_P2ByteArray = paramsMap["DevType_P2ByteArray"];
     paramsMapToThreads["DevType_P2ByteArray"] = paramsMap["DevType_P2ByteArray"];

     Version_P2ByteArray = paramsMap["Version_P2ByteArray"];
     paramsMapToThreads["Version_P2ByteArray"] = paramsMap["Version_P2ByteArray"];

     Initial_value_P2ByteArray = paramsMap["Initial_value_P2ByteArray"];
     paramsMapToThreads["Initial_value_P2ByteArray"] = paramsMap["Initial_value_P2ByteArray"];

     Service_P2ByteArray = paramsMap["Service_P2ByteArray"];
     paramsMapToThreads["Service_P2ByteArray"] = paramsMap["Service_P2ByteArray"];


    qDebug()<<"slotGetParamsMap(QMap<QString, QByteArray>)";
}

/*****************************************************************/
void MainWindow::calibration(int workPlaceNumber)
{

        QSerialPort *portTmp;

        isNeedPaintEvent = true;//false;

        switch (workPlaceNumber) {
        case 0:
            portTmp = portOptical;
            currentIndicatorNumber = 0;
            break;
        case 1:
            portTmp = portOptical2;
            currentIndicatorNumber = 1;
            break;
        case 2:
            portTmp = portOptical3;
            currentIndicatorNumber = 2;
            break;
        case 3:
            portTmp = portOptical4;
            currentIndicatorNumber = 3;
            break;

        default:
            break;
        }


        currentBoxNumber = 1;


        QColor color(255, 127, 50);
        ui->label_Calibration->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_Calibration->setText("X");
        ui->label_Calibration->setVisible(false);

        ui->label_StatusBar->setText("");

        ui->lineEdit_RMV_ErrorFlags->setText("");
        ui->label_RMV_ErrorFlags_tick->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_RMV_ErrorFlags_tick->setText("X");
        ui->label_RMV_ErrorFlags_tick->setVisible(false);


        bool isCalibrationCorrect = false;
        bool isR_Ref1_Correct = false;
        bool isR_Ref2_Correct = false;
        bool isTMeasDirCorrect  = false;
        bool isTMeasRevCorrect = false;

        bool isCalibrationCorrect2 = false;
        bool isR_Ref1_Correct2 = false;
        bool isR_Ref2_Correct2 = false;
        bool isTMeasDirCorrect2  = false;
        bool isTMeasRevCorrect2 = false;

        bool isCalibrationCorrect3 = false;
        bool isR_Ref1_Correct3 = false;
        bool isR_Ref2_Correct3 = false;
        bool isTMeasDirCorrect3  = false;
        bool isTMeasRevCorrect3 = false;

        bool isCalibrationCorrect4 = false;
        bool isR_Ref1_Correct4 = false;
        bool isR_Ref2_Correct4 = false;
        bool isTMeasDirCorrect4  = false;
        bool isTMeasRevCorrect4 = false;

        qDebug()<<"MainWindow::slotStartCalibration(QMap<QString, QByteArray> calibrationMap)";

        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
//                QMessageBox::information(this, "", "Не удалось открыть порт УСО-2. Рабочее место: " +
//                                         QString::number(workPlaceNumber + 1));
                ui->label_StatusBar->setText("Не удалось открыть порт УСО-2. Рабочее место: " +
                                             QString::number(workPlaceNumber + 1));
                errorString.append(ui->label_StatusBar->text());
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkCalibrationError(currentIndicatorNumber);
                workPlaceOff(currentIndicatorNumber);
                return;
            }
        }


    //    R_Real1ByteArray = calibrationMap["R_Real1ByteArray"];
    //    R_Real2ByteArray = calibrationMap["R_Real2ByteArray"];
    //    qDebug()<<"R_Real1ByteArray.toHex()"<<R_Real1ByteArray.toHex()
    //            <<"R_Real2ByteArray.toHex()"<<R_Real2ByteArray.toHex();
    //    temperature1ByteArray = calibrationMap["temperature1ByteArray"];
    //    temperature2ByteArray = calibrationMap["temperature2ByteArray"];

        //
        //Temperature Channel Calibration 5a 00 0d 37 R_Real1(4bytes) R_Real2(4bytes)
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x0d;
           packetToRead.append(byte);
           byte = 0x37;
           packetToRead.append(byte);

           byte = R_Real1ByteArray[0];
           packetToRead.append(byte);
           byte = R_Real1ByteArray[1];
           packetToRead.append(byte);
           byte = R_Real1ByteArray[2];
           packetToRead.append(byte);
           byte = R_Real1ByteArray[3];
           packetToRead.append(byte);

           byte = R_Real2ByteArray[0];
           packetToRead.append(byte);
           byte = R_Real2ByteArray[1];
           packetToRead.append(byte);
           byte = R_Real2ByteArray[2];
           packetToRead.append(byte);
           byte = R_Real2ByteArray[3];
           packetToRead.append(byte);

           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 " Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text());
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkCalibrationError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(4100);//(5000);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные") +
//                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные") +
                                                " Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text());
                   ui->label_Calibration->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkCalibrationError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xb7;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка данных") +
//                                               " Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   " Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text());
                      ui->label_Calibration->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkCalibrationError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   } else{}
               }



           }


        }

        //
        //
        //RCF   5a 00 05 06

        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x06;
           packetToRead.append(byte);

           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 " Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text());
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkCalibrationError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось прочитать данные") +
//                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                " Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text());
                   ui->label_Calibration->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkCalibrationError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x23;
               bytesForChecking.append(byte);
               byte = 0x86;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                 //------------------------------------------

                 if(workPlaceNumber == 0) {

                  //
                  //
                  //R_Ref1 (10-13)
                  quint32 R_Ref1Int = (quint8)buffer[10];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[11];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[12];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[13];

                  float R_Ref1Float = (float)R_Ref1Int/1000000;

                  qDebug()<<"R_Ref1Float "<<R_Ref1Float;

                  r_ref1Result = QString::number(R_Ref1Float);

                  if( R_Ref1Float>=(Acceptable_R_Ref1Float - Acceptable_R_Ref1Float/100) &&
                          R_Ref1Float<=(Acceptable_R_Ref1Float + Acceptable_R_Ref1Float/100) ) { //если выходит за допустимые пределы

                      isR_Ref1_Correct = true;
                  }
                  else {
//                         QMessageBox::information(this, "", "Недопустимое значение R_Ref1. Рабочее место: "
//                                                  + QString::number(workPlaceNumber+1));
                         ui->label_StatusBar->setText("Недопустимое значение R_Ref1. Рабочее место: "
                                                      + QString::number(workPlaceNumber+1));
                         errorString.append(ui->label_StatusBar->text());
                         ui->label_Calibration->setVisible(true);
                         vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                         checkCalibrationError(currentIndicatorNumber);
                         workPlaceOff(currentIndicatorNumber);
                         return;
                  }


                  //
                  //R_Ref2 (14-17)
                  quint32 R_Ref2Int = (quint8)buffer[14];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[15];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[16];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[17];

                  float R_Ref2Float = (float)R_Ref2Int/1000000;

                  qDebug()<<"R_Ref2Float "<<R_Ref2Float;

                  r_ref2Result = QString::number(R_Ref2Float);

                  if( R_Ref2Float>=(Acceptable_R_Ref2Float - Acceptable_R_Ref2Float/100) &&
                          R_Ref2Float<=(Acceptable_R_Ref2Float + Acceptable_R_Ref2Float/100) ) { //если выходит за допустимые пределы

                      isR_Ref2_Correct = true;

                  }
                  else {

//                      QMessageBox::information(this, "", "Недопустимое значение R_Ref2. Рабочее место: "
//                                               + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText("Недопустимое значение R_Ref2. Рабочее место: "
                                                   + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text());
                      ui->label_Calibration->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkCalibrationError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                  }

                  //
                  //
                  //R_Ref2 (14-17) /

                 }

                 //----------------------------------------------

                 if(workPlaceNumber == 1) {

                  //
                  //
                  //R_Ref1 (10-13)
                  quint32 R_Ref1Int = (quint8)buffer[10];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[11];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[12];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[13];

                  float R_Ref1Float = (float)R_Ref1Int/1000000;

                  qDebug()<<"R_Ref1Float "<<R_Ref1Float;

                  r_ref1Result2 = QString::number(R_Ref1Float);

                  if( R_Ref1Float>=(Acceptable_R_Ref1Float2 - Acceptable_R_Ref1Float2/100) &&
                          R_Ref1Float<=(Acceptable_R_Ref1Float2 + Acceptable_R_Ref1Float2/100) ) { //если выходит за допустимые пределы

                      isR_Ref1_Correct2 = true;
                  }
                  else {
//                         QMessageBox::information(this, "", "Недопустимое значение R_Ref1. Рабочее место: "
//                                                  + QString::number(workPlaceNumber+1));
                         ui->label_StatusBar->setText("Недопустимое значение R_Ref1. Рабочее место: "
                                                      + QString::number(workPlaceNumber+1));
                         errorString.append(ui->label_StatusBar->text());
    //                     ui->label_Calibration->setVisible(true);
                         vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                         checkCalibrationError(currentIndicatorNumber);
                         workPlaceOff(currentIndicatorNumber);
                         return;
                  }


                  //
                  //R_Ref2 (14-17)
                  quint32 R_Ref2Int = (quint8)buffer[14];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[15];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[16];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[17];

                  float R_Ref2Float = (float)R_Ref2Int/1000000;

                  qDebug()<<"R_Ref2Float "<<R_Ref2Float;

                  r_ref2Result2 = QString::number(R_Ref2Float);

                  if( R_Ref2Float>=(Acceptable_R_Ref2Float2 - Acceptable_R_Ref2Float2/100) &&
                          R_Ref2Float<=(Acceptable_R_Ref2Float2 + Acceptable_R_Ref2Float2/100) ) { //если выходит за допустимые пределы

                      isR_Ref2_Correct2 = true;

                  }
                  else {

//                      QMessageBox::information(this, "", "Недопустимое значение R_Ref2. Рабочее место: "
//                                               + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText("Недопустимое значение R_Ref2. Рабочее место: "
                                                   + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text());
  //                    ui->label_Calibration->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkCalibrationError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                  }

                  //
                  //
                  //R_Ref2 (14-17) /

                 }

                 //---------------------------------------------------------

                 if(workPlaceNumber == 2) {

                  //
                  //
                  //R_Ref1 (10-13)
                  quint32 R_Ref1Int = (quint8)buffer[10];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[11];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[12];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[13];

                  float R_Ref1Float = (float)R_Ref1Int/1000000;

                  qDebug()<<"R_Ref1Float "<<R_Ref1Float;

                  r_ref1Result3 = QString::number(R_Ref1Float);

                  if( R_Ref1Float>=(Acceptable_R_Ref1Float3 - Acceptable_R_Ref1Float3/100) &&
                          R_Ref1Float<=(Acceptable_R_Ref1Float3 + Acceptable_R_Ref1Float3/100) ) { //если выходит за допустимые пределы

                      isR_Ref1_Correct3 = true;
                  }
                  else {
//                         QMessageBox::information(this, "", "Недопустимое значение R_Ref1. Рабочее место: "
//                                                  + QString::number(workPlaceNumber+1));
                         ui->label_StatusBar->setText("Недопустимое значение R_Ref1. Рабочее место: "
                                                      + QString::number(workPlaceNumber+1));
                         errorString.append(ui->label_StatusBar->text());
   //                      ui->label_Calibration->setVisible(true);
                         vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                         checkCalibrationError(currentIndicatorNumber);
                         workPlaceOff(currentIndicatorNumber);
                         return;
                  }


                  //
                  //R_Ref2 (14-17)
                  quint32 R_Ref2Int = (quint8)buffer[14];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[15];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[16];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[17];

                  float R_Ref2Float = (float)R_Ref2Int/1000000;

                  qDebug()<<"R_Ref2Float "<<R_Ref2Float;

                  r_ref2Result3 = QString::number(R_Ref2Float);

                  if( R_Ref2Float>=(Acceptable_R_Ref2Float3 - Acceptable_R_Ref2Float3/100) &&
                          R_Ref2Float<=(Acceptable_R_Ref2Float3 + Acceptable_R_Ref2Float3/100) ) { //если выходит за допустимые пределы

                      isR_Ref2_Correct3 = true;

                  }
                  else {

//                      QMessageBox::information(this, "", "Недопустимое значение R_Ref2. Рабочее место: "
//                                               + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText("Недопустимое значение R_Ref2. Рабочее место: "
                                                   + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text());
  //                    ui->label_Calibration->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkCalibrationError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                  }

                  //
                  //
                  //R_Ref2 (14-17) /

                 }

                 //---------------------------------------------------------

                 if(workPlaceNumber == 3) {

                  //
                  //
                  //R_Ref1 (10-13)
                  quint32 R_Ref1Int = (quint8)buffer[10];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[11];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[12];
                  R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[13];

                  float R_Ref1Float = (float)R_Ref1Int/1000000;

                  qDebug()<<"R_Ref1Float "<<R_Ref1Float;

                  r_ref1Result4 = QString::number(R_Ref1Float);

                  if( R_Ref1Float>=(Acceptable_R_Ref1Float4 - Acceptable_R_Ref1Float4/100) &&
                          R_Ref1Float<=(Acceptable_R_Ref1Float4 + Acceptable_R_Ref1Float4/100) ) { //если выходит за допустимые пределы

                      isR_Ref1_Correct4 = true;
                  }
                  else {
//                         QMessageBox::information(this, "", "Недопустимое значение R_Ref1. Рабочее место: "
//                                                  + QString::number(workPlaceNumber+1));
                         ui->label_StatusBar->setText("Недопустимое значение R_Ref1. Рабочее место: "
                                                      + QString::number(workPlaceNumber+1));
                         errorString.append(ui->label_StatusBar->text());
   //                      ui->label_Calibration->setVisible(true);
                         vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                         checkCalibrationError(currentIndicatorNumber);
                         workPlaceOff(currentIndicatorNumber);
                         return;
                  }


                  //
                  //R_Ref2 (14-17)
                  quint32 R_Ref2Int = (quint8)buffer[14];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[15];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[16];
                  R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[17];

                  float R_Ref2Float = (float)R_Ref2Int/1000000;

                  qDebug()<<"R_Ref2Float "<<R_Ref2Float;

                  r_ref2Result4 = QString::number(R_Ref2Float);

                  if( R_Ref2Float>=(Acceptable_R_Ref2Float4 - Acceptable_R_Ref2Float4/100) &&
                          R_Ref2Float<=(Acceptable_R_Ref2Float4 + Acceptable_R_Ref2Float4/100) ) { //если выходит за допустимые пределы

                      isR_Ref2_Correct4 = true;

                  }
                  else {

//                      QMessageBox::information(this, "", "Недопустимое значение R_Ref2. Рабочее место: "
//                                               + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText("Недопустимое значение R_Ref2. Рабочее место: "
                                                   + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text());
   //                   ui->label_Calibration->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkCalibrationError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                  }

                  //
                  //
                  //R_Ref2 (14-17) /

                 }

                 //---------------------------------------------------------


                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка данных") +
//                                               " Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   " Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text());
  //                    ui->label_Calibration->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkCalibrationError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   } else{}
               }



           }


        }

        //
        //
        //RMV 5a 00 05 04
        int j=0; //счётчик удачных попыток прочтения
        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x04;
           packetToRead.append(byte);

           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 " Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text());
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkCalibrationError(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(600);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()      " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
//                   QMessageBox::information(this, "", tr("Не удалось прочитать данные") +
//                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                " Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text());
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkCalibrationError(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x20;
               bytesForChecking.append(byte);
               byte = 0x84;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  j=j+1;
                  ui->textBrowser->append("j = " + QString::number(j));

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                 if(j==3) {

                  QByteArray errorFlags;
                  errorFlags.clear();
                  errorFlags.append((quint8)buffer[22]);
                  errorFlags.append((quint8)buffer[23]);
                  errorFlags.append((quint8)buffer[24]);
                  ui->textBrowser->append("RMV_ErrorFlags " + errorFlags.toHex());

                  quint8 errorFlagsQuint8 = (quint8)buffer[24];
                  errorFlagsQuint8 = errorFlagsQuint8 & 0x0f;
                  qDebug()<<"QString::number(errorFlagsQuint8) "<<QString::number(errorFlagsQuint8);

                 //--------------------------------------------------------
                 if(workPlaceNumber == 0) {

                  if((errorFlagsQuint8 == 1) || (errorFlagsQuint8 == 3)) {
                      ui->lineEdit_RMV_ErrorFlags->setText("Магнит сейчас");
                      ui->label_RMV_ErrorFlags_tick->setStyleSheet(QString("color: green").arg(color.name()));
                      ui->label_RMV_ErrorFlags_tick->setText("V");
                      ui->label_RMV_ErrorFlags_tick->setVisible(true);
                  }
                  if((errorFlagsQuint8 == 2) || (errorFlagsQuint8 == 0)) {
                      ui->lineEdit_RMV_ErrorFlags->setText("Магнит был");
                      ui->label_RMV_ErrorFlags_tick->setVisible(true);

                  }

     //             ui->lineEdit_RMV_ErrorFlags->setText(errorFlags.toHex());

                  //
                  //TMeasDir (18, 19)
                  quint16 TMeasDirInt = (quint8)buffer[18];
                  TMeasDirInt = TMeasDirInt<<8 | (quint8)buffer[19];

                  float TMeasDirFloat = (float)TMeasDirInt/100;

                  qDebug()<<"TMeasDirFloat "<<TMeasDirFloat;

                  if(TMeasDirFloat>=(temperature1Float - (temperature1Float/1000)*2) &&  //если выходит за допустимые пределы
                       TMeasDirFloat<=(temperature1Float + (temperature1Float/1000)*2)) {

                      isTMeasDirCorrect = true;

                  }
                  else {
//                      QMessageBox::information(this, "", "Недопустимое значение TMeasDi. Рабочее место: "
//                                               + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText("Недопустимое значение TMeasDi. Рабочее место: "
                                                   + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text());
      //                ui->label_Calibration->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkCalibrationError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;

                  }


                  //
                  //TMeasRev (20, 21)
                  quint16 TMeasRevInt = (quint8)buffer[20];
                  TMeasRevInt = TMeasRevInt<<8 | (quint8)buffer[21];

                  float TMeasRevFloat = (float)TMeasRevInt/100;

                  qDebug()<<"TMeasRevFloat "<<TMeasRevFloat;

                  if(TMeasRevFloat>=(temperature2Float - (temperature2Float/1000)*2) &&  //если выходит за допустимые пределы
                       TMeasRevFloat<=(temperature2Float + (temperature2Float/1000)*2)) {

                      isTMeasRevCorrect = true;

                  }
                  else {
//                         QMessageBox::information(this, "", "Недопустимое значение TMeasRev. Рабочее место: "
//                                                  + QString::number(workPlaceNumber+1));
                         ui->label_StatusBar->setText("Недопустимое значение TMeasRev. Рабочее место: "
                                                      + QString::number(workPlaceNumber+1));
                         errorString.append(ui->label_StatusBar->text());
      //                   ui->label_Calibration->setVisible(true);
                         vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                         checkCalibrationError(currentIndicatorNumber);
                         workPlaceOff(currentIndicatorNumber);
                         return;

                  }

                 }
                 //----------------------------------------------------
                 if(workPlaceNumber == 1) {

                  if((errorFlagsQuint8 == 1) || (errorFlagsQuint8 == 3)) {
                      ui->lineEdit_RMV_ErrorFlags_2->setText("Магнит сейчас");
                      ui->label_RMV_ErrorFlags_tick_2->setStyleSheet(QString("color: green").arg(color.name()));
                      ui->label_RMV_ErrorFlags_tick_2->setText("V");
                      ui->label_RMV_ErrorFlags_tick_2->setVisible(true);
                  }
                  if((errorFlagsQuint8 == 2) || (errorFlagsQuint8 == 0)) {
                      ui->lineEdit_RMV_ErrorFlags_2->setText("Магнит был");
                      ui->label_RMV_ErrorFlags_tick_2->setVisible(true);

                  }

     //             ui->lineEdit_RMV_ErrorFlags->setText(errorFlags.toHex());

                  //
                  //TMeasDir (18, 19)
                  quint16 TMeasDirInt = (quint8)buffer[18];
                  TMeasDirInt = TMeasDirInt<<8 | (quint8)buffer[19];

                  float TMeasDirFloat = (float)TMeasDirInt/100;

                  qDebug()<<"TMeasDirFloat "<<TMeasDirFloat;

                  if(TMeasDirFloat>=(temperature1Float2 - (temperature1Float2/1000)*2) &&  //если выходит за допустимые пределы
                       TMeasDirFloat<=(temperature1Float2 + (temperature1Float2/1000)*2)) {

                      isTMeasDirCorrect2 = true;

                  }
                  else {
//                      QMessageBox::information(this, "", "Недопустимое значение TMeasDi. Рабочее место: "
//                                               + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText("Недопустимое значение TMeasDi. Рабочее место: "
                                                   + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text());
    //                  ui->label_Calibration->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkCalibrationError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;

                  }


                  //
                  //TMeasRev (20, 21)
                  quint16 TMeasRevInt = (quint8)buffer[20];
                  TMeasRevInt = TMeasRevInt<<8 | (quint8)buffer[21];

                  float TMeasRevFloat = (float)TMeasRevInt/100;

                  qDebug()<<"TMeasRevFloat "<<TMeasRevFloat;

                  if(TMeasRevFloat>=(temperature2Float2 - (temperature2Float2/1000)*2) &&  //если выходит за допустимые пределы
                       TMeasRevFloat<=(temperature2Float2 + (temperature2Float2/1000)*2)) {

                      isTMeasRevCorrect2 = true;

                  }
                  else {
//                         QMessageBox::information(this, "", "Недопустимое значение TMeasRev. Рабочее место: "
//                                                  + QString::number(workPlaceNumber+1));
                         ui->label_StatusBar->setText("Недопустимое значение TMeasRev. Рабочее место: "
                                                      + QString::number(workPlaceNumber+1));
                         errorString.append(ui->label_StatusBar->text());
   //                      ui->label_Calibration->setVisible(true);
                         vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                         checkCalibrationError(currentIndicatorNumber);
                         workPlaceOff(currentIndicatorNumber);
                         return;

                  }

                 }


                 //----------------------------------------------------
                 if(workPlaceNumber == 2) {

                  if((errorFlagsQuint8 == 1) || (errorFlagsQuint8 == 3)) {
                      ui->lineEdit_RMV_ErrorFlags_3->setText("Магнит сейчас");
                      ui->label_RMV_ErrorFlags_tick_3->setStyleSheet(QString("color: green").arg(color.name()));
                      ui->label_RMV_ErrorFlags_tick_3->setText("V");
                      ui->label_RMV_ErrorFlags_tick_3->setVisible(true);
                  }
                  if((errorFlagsQuint8 == 2) || (errorFlagsQuint8 == 0)) {
                      ui->lineEdit_RMV_ErrorFlags_3->setText("Магнит был");
                      ui->label_RMV_ErrorFlags_tick_3->setVisible(true);

                  }

     //             ui->lineEdit_RMV_ErrorFlags->setText(errorFlags.toHex());

                  //
                  //TMeasDir (18, 19)
                  quint16 TMeasDirInt = (quint8)buffer[18];
                  TMeasDirInt = TMeasDirInt<<8 | (quint8)buffer[19];

                  float TMeasDirFloat = (float)TMeasDirInt/100;

                  qDebug()<<"TMeasDirFloat "<<TMeasDirFloat;

                  if(TMeasDirFloat>=(temperature1Float3 - (temperature1Float3/1000)*2) &&  //если выходит за допустимые пределы
                       TMeasDirFloat<=(temperature1Float3 + (temperature1Float3/1000)*2)) {

                      isTMeasDirCorrect3 = true;

                  }
                  else {
//                      QMessageBox::information(this, "", "Недопустимое значение TMeasDi. Рабочее место: "
//                                               + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText("Недопустимое значение TMeasDi. Рабочее место: "
                                                   + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text());
     //                 ui->label_Calibration->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkCalibrationError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;

                  }


                  //
                  //TMeasRev (20, 21)
                  quint16 TMeasRevInt = (quint8)buffer[20];
                  TMeasRevInt = TMeasRevInt<<8 | (quint8)buffer[21];

                  float TMeasRevFloat = (float)TMeasRevInt/100;

                  qDebug()<<"TMeasRevFloat "<<TMeasRevFloat;

                  if(TMeasRevFloat>=(temperature2Float3 - (temperature2Float3/1000)*2) &&  //если выходит за допустимые пределы
                       TMeasRevFloat<=(temperature2Float3 + (temperature2Float3/1000)*2)) {

                      isTMeasRevCorrect3 = true;

                  }
                  else {
//                         QMessageBox::information(this, "", "Недопустимое значение TMeasRev. Рабочее место: "
//                                                  + QString::number(workPlaceNumber+1));
                         ui->label_StatusBar->setText("Недопустимое значение TMeasRev. Рабочее место: "
                                                      + QString::number(workPlaceNumber+1));
                         errorString.append(ui->label_StatusBar->text());
   //                      ui->label_Calibration->setVisible(true);
                         vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                         checkCalibrationError(currentIndicatorNumber);
                         workPlaceOff(currentIndicatorNumber);
                         return;

                  }

                 }


                 //----------------------------------------------------
                 if(workPlaceNumber == 3) {

                  if((errorFlagsQuint8 == 1) || (errorFlagsQuint8 == 3)) {
                      ui->lineEdit_RMV_ErrorFlags_4->setText("Магнит сейчас");
                      ui->label_RMV_ErrorFlags_tick_4->setStyleSheet(QString("color: green").arg(color.name()));
                      ui->label_RMV_ErrorFlags_tick_4->setText("V");
                      ui->label_RMV_ErrorFlags_tick_4->setVisible(true);
                  }
                  if((errorFlagsQuint8 == 2) || (errorFlagsQuint8 == 0)) {
                      ui->lineEdit_RMV_ErrorFlags_4->setText("Магнит был");
                      ui->label_RMV_ErrorFlags_tick_4->setVisible(true);

                  }

     //             ui->lineEdit_RMV_ErrorFlags->setText(errorFlags.toHex());

                  //
                  //TMeasDir (18, 19)
                  quint16 TMeasDirInt = (quint8)buffer[18];
                  TMeasDirInt = TMeasDirInt<<8 | (quint8)buffer[19];

                  float TMeasDirFloat = (float)TMeasDirInt/100;

                  qDebug()<<"TMeasDirFloat "<<TMeasDirFloat;

                  if(TMeasDirFloat>=(temperature1Float4 - (temperature1Float4/1000)*2) &&  //если выходит за допустимые пределы
                       TMeasDirFloat<=(temperature1Float4 + (temperature1Float4/1000)*2)) {

                      isTMeasDirCorrect4 = true;

                  }
                  else {
//                      QMessageBox::information(this, "", "Недопустимое значение TMeasDi. Рабочее место: "
//                                               + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText("Недопустимое значение TMeasDi. Рабочее место: "
                                                   + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text());
   //                   ui->label_Calibration->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkCalibrationError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;

                  }


                  //
                  //TMeasRev (20, 21)
                  quint16 TMeasRevInt = (quint8)buffer[20];
                  TMeasRevInt = TMeasRevInt<<8 | (quint8)buffer[21];

                  float TMeasRevFloat = (float)TMeasRevInt/100;

                  qDebug()<<"TMeasRevFloat "<<TMeasRevFloat;

                  if(TMeasRevFloat>=(temperature2Float4 - (temperature2Float4/1000)*2) &&  //если выходит за допустимые пределы
                       TMeasRevFloat<=(temperature2Float4 + (temperature2Float4/1000)*2)) {

                      isTMeasRevCorrect4 = true;

                  }
                  else {
//                         QMessageBox::information(this, "", "Недопустимое значение TMeasRev. Рабочее место: "
//                                                  + QString::number(workPlaceNumber+1));
                         ui->label_StatusBar->setText("Недопустимое значение TMeasRev. Рабочее место: "
                                                      + QString::number(workPlaceNumber+1));
                         errorString.append(ui->label_StatusBar->text());
      //                   ui->label_Calibration->setVisible(true);
                         vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                         checkCalibrationError(currentIndicatorNumber);
                         workPlaceOff(currentIndicatorNumber);
                         return;

                  }

                 }


                  //----------------------------------------------------






                  break;


                }//ifend


     //             break;
               }
               else {
                   if(i==9) {
//                      QMessageBox::information(this, "", tr("Ошибка данных") +
//                                               " Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   " Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text());
     //                 ui->label_Calibration->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkCalibrationError(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }


        //-----------------------Проверка результата калибровки-----------------------
      if(workPlaceNumber == 0) {

        if((isR_Ref1_Correct == true) && (isR_Ref2_Correct == true) && (isTMeasDirCorrect == true) && (isTMeasRevCorrect == true)) {
            isCalibrationCorrect = true;
//            ui->label_StatusBar->setText("Калибровка : успешно. Рабочее место: "
//                                         + QString::number(workPlaceNumber+1));
//            errorString.append(ui->label_StatusBar->text());
   //         ui->label_Calibration->setStyleSheet(QString("color: green").arg(color.name()));
   //         ui->label_Calibration->setText("V");
  //          ui->label_Calibration->setVisible(true);
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = false;
            checkCalibrationError(currentIndicatorNumber);
        }
        else {
            ui->label_StatusBar->setText("Калибровка : неудачно. Рабочее место: "
                                         + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text());
   //         ui->label_Calibration->setVisible(true);
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkCalibrationError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
        }

      }

        //
        //

      if(workPlaceNumber == 1) {

        if((isR_Ref1_Correct2 == true) && (isR_Ref2_Correct2 == true) && (isTMeasDirCorrect2 == true) && (isTMeasRevCorrect2 == true)) {
            isCalibrationCorrect2 = true;
//            ui->label_StatusBar->setText("Калибровка : успешно. Рабочее место: "
//                                         + QString::number(workPlaceNumber+1));
//            errorString.append(ui->label_StatusBar->text());
            ui->label_Calibration->setStyleSheet(QString("color: green").arg(color.name()));
            ui->label_Calibration->setText("V");
 //           ui->label_Calibration->setVisible(true);
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = false;
            checkCalibrationError(currentIndicatorNumber);
        }
        else {
            ui->label_StatusBar->setText("Калибровка : неудачно. Рабочее место: "
                                         + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text());
   //         ui->label_Calibration->setVisible(true);
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkCalibrationError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
        }

      }

        //
        //

      if(workPlaceNumber == 2) {

        if((isR_Ref1_Correct3 == true) && (isR_Ref2_Correct3 == true) && (isTMeasDirCorrect3 == true) && (isTMeasRevCorrect3 == true)) {
            isCalibrationCorrect3 = true;
//            ui->label_StatusBar->setText("Калибровка : успешно. Рабочее место: "
//                                         + QString::number(workPlaceNumber+1));
//            errorString.append(ui->label_StatusBar->text());
            ui->label_Calibration->setStyleSheet(QString("color: green").arg(color.name()));
            ui->label_Calibration->setText("V");
//            ui->label_Calibration->setVisible(true);
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = false;
            checkCalibrationError(currentIndicatorNumber);
        }
        else {
            ui->label_StatusBar->setText("Калибровка : неудачно. Рабочее место: "
                                         + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text());
 //           ui->label_Calibration->setVisible(true);
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkCalibrationError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
        }

      }

        //
        //

      if(workPlaceNumber == 3) {

        if((isR_Ref1_Correct4 == true) && (isR_Ref2_Correct4 == true) && (isTMeasDirCorrect4 == true) && (isTMeasRevCorrect4 == true)) {
            isCalibrationCorrect4 = true;
//            ui->label_StatusBar->setText("Калибровка : успешно. Рабочее место: "
//                                         + QString::number(workPlaceNumber+1));
//            errorString.append(ui->label_StatusBar->text());
            ui->label_Calibration->setStyleSheet(QString("color: green").arg(color.name()));
            ui->label_Calibration->setText("V");
   //         ui->label_Calibration->setVisible(true);
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = false;
            checkCalibrationError(currentIndicatorNumber);
        }
        else {
            ui->label_StatusBar->setText("Калибровка : неудачно. Рабочее место: "
                                         + QString::number(workPlaceNumber+1));
            errorString.append(ui->label_StatusBar->text());
   //         ui->label_Calibration->setVisible(true);
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkCalibrationError(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
        }

      }


}
/*****************************************************************/
void MainWindow::slotStartCalibration(QMap<QString, QByteArray> calibrationMap, QMap<QString, float> calibrationFloatMap)
{
    QColor color(255, 127, 50);
    ui->label_Calibration->setStyleSheet(QString("color: red").arg(color.name()));
    ui->label_Calibration->setText("X");
    ui->label_Calibration->setVisible(false);

    ui->label_StatusBar->setText("");

    ui->lineEdit_RMV_ErrorFlags->setText("");
    ui->label_RMV_ErrorFlags_tick->setStyleSheet(QString("color: red").arg(color.name()));
    ui->label_RMV_ErrorFlags_tick->setText("X");
    ui->label_RMV_ErrorFlags_tick->setVisible(false);


    bool isCalibrationCorrect = false;
    bool isR_Ref1_Correct = false;
    bool isR_Ref2_Correct = false;
    bool isTMeasDirCorrect  = false;
    bool isTMeasRevCorrect = false;

    qDebug()<<"MainWindow::slotStartCalibration(QMap<QString, QByteArray> calibrationMap)";

    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
            return;
        }
    }


//    R_Real1ByteArray = calibrationMap["R_Real1ByteArray"];
//    R_Real2ByteArray = calibrationMap["R_Real2ByteArray"];
//    qDebug()<<"R_Real1ByteArray.toHex()"<<R_Real1ByteArray.toHex()
//            <<"R_Real2ByteArray.toHex()"<<R_Real2ByteArray.toHex();
//    temperature1ByteArray = calibrationMap["temperature1ByteArray"];
//    temperature2ByteArray = calibrationMap["temperature2ByteArray"];

    //
    //Temperature Channel Calibration 5a 00 0d 37 R_Real1(4bytes) R_Real2(4bytes)
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x0d;
       packetToRead.append(byte);
       byte = 0x37;
       packetToRead.append(byte);

       byte = R_Real1ByteArray[0];
       packetToRead.append(byte);
       byte = R_Real1ByteArray[1];
       packetToRead.append(byte);
       byte = R_Real1ByteArray[2];
       packetToRead.append(byte);
       byte = R_Real1ByteArray[3];
       packetToRead.append(byte);

       byte = R_Real2ByteArray[0];
       packetToRead.append(byte);
       byte = R_Real2ByteArray[1];
       packetToRead.append(byte);
       byte = R_Real2ByteArray[2];
       packetToRead.append(byte);
       byte = R_Real2ByteArray[3];
       packetToRead.append(byte);

       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(5000);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные"));
                   ui->label_Calibration->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xb7;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                      ui->label_Calibration->setVisible(true);
                  return;
               } else{}
           }



       }


    }

    //
    //
    //RCF   5a 00 05 06

    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x06;
       packetToRead.append(byte);

       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               ui->label_Calibration->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x23;
           bytesForChecking.append(byte);
           byte = 0x86;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //
              //R_Ref1 (10-13)
              quint32 R_Ref1Int = (quint8)buffer[10];
              R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[11];
              R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[12];
              R_Ref1Int = R_Ref1Int<<8 | (quint8)buffer[13];             

              float R_Ref1Float = (float)R_Ref1Int/1000000;

              qDebug()<<"R_Ref1Float "<<R_Ref1Float;

              r_ref1Result = QString::number(R_Ref1Float);

              if( R_Ref1Float>=(Acceptable_R_Ref1Float - Acceptable_R_Ref1Float/100) &&
                      R_Ref1Float<=(Acceptable_R_Ref1Float + Acceptable_R_Ref1Float/100) ) { //если выходит за допустимые пределы

                  isR_Ref1_Correct = true;
              }
              else {
                     QMessageBox::information(this, "", "Недопустимое значение R_Ref1");
                     ui->label_Calibration->setVisible(true);
                     return;
              }


              //
              //R_Ref2 (14-17)
              quint32 R_Ref2Int = (quint8)buffer[14];
              R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[15];
              R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[16];
              R_Ref2Int = R_Ref2Int<<8 | (quint8)buffer[17];              

              float R_Ref2Float = (float)R_Ref2Int/1000000;

              qDebug()<<"R_Ref2Float "<<R_Ref2Float;

              r_ref2Result = QString::number(R_Ref2Float);

              if( R_Ref2Float>=(Acceptable_R_Ref2Float - Acceptable_R_Ref2Float/100) &&
                      R_Ref2Float<=(Acceptable_R_Ref2Float + Acceptable_R_Ref2Float/100) ) { //если выходит за допустимые пределы

                  isR_Ref2_Correct = true;

              }
              else {

                  QMessageBox::information(this, "", "Недопустимое значение R_Ref2");
                  ui->label_Calibration->setVisible(true);
                  return;
              }




              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  ui->label_Calibration->setVisible(true);
                  return;
               } else{}
           }



       }


    }

    //
    //
    //RMV 5a 00 05 04
    int j=0; //счётчик удачных попыток прочтения
    for(int i=0; i<10;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x04;
       packetToRead.append(byte);

       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(600);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()      " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==9) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x20;
           bytesForChecking.append(byte);
           byte = 0x84;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              j=j+1;
              ui->textBrowser->append("j = " + QString::number(j));

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

             if(j==3) {

              QByteArray errorFlags;
              errorFlags.clear();
              errorFlags.append((quint8)buffer[22]);
              errorFlags.append((quint8)buffer[23]);
              errorFlags.append((quint8)buffer[24]);
              ui->textBrowser->append("RMV_ErrorFlags " + errorFlags.toHex());

              quint8 errorFlagsQuint8 = (quint8)buffer[24];
              errorFlagsQuint8 = errorFlagsQuint8 & 0x0f;
              qDebug()<<"QString::number(errorFlagsQuint8) "<<QString::number(errorFlagsQuint8);

              if((errorFlagsQuint8 == 1) || (errorFlagsQuint8 == 3)) {
                  ui->lineEdit_RMV_ErrorFlags->setText("Магнит сейчас");
                  ui->label_RMV_ErrorFlags_tick->setStyleSheet(QString("color: green").arg(color.name()));
                  ui->label_RMV_ErrorFlags_tick->setText("V");
                  ui->label_RMV_ErrorFlags_tick->setVisible(true);
              }
              if((errorFlagsQuint8 == 2) || (errorFlagsQuint8 == 0)) {
                  ui->lineEdit_RMV_ErrorFlags->setText("Магнит был");
                  ui->label_RMV_ErrorFlags_tick->setVisible(true);

              }


 //             ui->lineEdit_RMV_ErrorFlags->setText(errorFlags.toHex());

              //
              //TMeasDir (18, 19)
              quint16 TMeasDirInt = (quint8)buffer[18];
              TMeasDirInt = TMeasDirInt<<8 | (quint8)buffer[19];             

              float TMeasDirFloat = (float)TMeasDirInt/100;

              qDebug()<<"TMeasDirFloat "<<TMeasDirFloat;

              if(TMeasDirFloat>=(temperature1Float - (temperature1Float/1000)*2) &&  //если выходит за допустимые пределы
                   TMeasDirFloat<=(temperature1Float + (temperature1Float/1000)*2)) {

                  isTMeasDirCorrect = true;

              }
              else {
                  QMessageBox::information(this, "", "Недопустимое значение TMeasDir");
                  ui->label_Calibration->setVisible(true);
                  return;

              }


              //
              //TMeasRev (20, 21)
              quint16 TMeasRevInt = (quint8)buffer[20];
              TMeasRevInt = TMeasRevInt<<8 | (quint8)buffer[21];              

              float TMeasRevFloat = (float)TMeasRevInt/100;

              qDebug()<<"TMeasRevFloat "<<TMeasRevFloat;

              if(TMeasRevFloat>=(temperature2Float - (temperature2Float/1000)*2) &&  //если выходит за допустимые пределы
                   TMeasRevFloat<=(temperature2Float + (temperature2Float/1000)*2)) {

                  isTMeasRevCorrect = true;

              }
              else {
                     QMessageBox::information(this, "", "Недопустимое значение TMeasRev");
                     ui->label_Calibration->setVisible(true);
                     return;

              }

              break;


            }//ifend


 //             break;
           }
           else {
               if(i==9) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  ui->label_Calibration->setVisible(true);
                  return;
               }
           }



       }


    }

    if((isR_Ref1_Correct == true) && (isR_Ref2_Correct == true) && (isTMeasDirCorrect == true) && (isTMeasRevCorrect == true)) {
        isCalibrationCorrect = true;
        ui->label_StatusBar->setText("Калибровка : успешно");
        ui->label_Calibration->setStyleSheet(QString("color: green").arg(color.name()));
        ui->label_Calibration->setText("V");
        ui->label_Calibration->setVisible(true);
    }
    else {
        ui->label_StatusBar->setText("Калибровка : неудачно");
        ui->label_Calibration->setVisible(true);
    }


}
/*****************************************************************/
void MainWindow::realClockCalibration()  //командой WCC, параметр RTC_Offset (значение параметра RTC_Tcomp всегда 0)
{

}
/*****************************************************************/
void MainWindow::slotStartRealClockCalibation(quint16 correctionCoefResult) //командой WCC, параметр RTC_Offset (значение параметра RTC_Tcomp всегда 0)
{

    ui->label_StatusBar->setText("");

    QColor color(255, 127, 50);
    ui->label_realClockCalibration->setStyleSheet(QString("color: red").arg(color.name()));
    ui->label_realClockCalibration->setText("X");
    ui->label_realClockCalibration->setVisible(false);

    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
            return;
        }
    }

    //
    //WCC  5a 00 09 26

  bool isWritingCorrect = false;

  for(int j=0; j<3; j++) {


    QByteArray buffer;

    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x09;
       packetToRead.append(byte);
       byte = 0x26;
       packetToRead.append(byte);

       byte = (quint8)(correctionCoefResult>>8);//старший байт
       packetToRead.append(byte);
       byte = (quint8)correctionCoefResult;//младший байт
       packetToRead.append(byte);

       byte = 0;
       packetToRead.append(byte);
       byte = 0;
       packetToRead.append(byte);

       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Ошибка калибровки генератора часов реального времени"));
               ui->label_realClockCalibration->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xa6;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              if(!(buffer[4] == 0)) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных"));
                  return;
              }






              break;
           }
           else {
               QMessageBox::information(this, "", tr("Ошибка калибровки генератора часов реального времени"));
               ui->label_realClockCalibration->setVisible(true);
               return;
           }



       }


    }



    //
    //RCC  5a 00 05 06

    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x06;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Ошибка калибровки генератора часов реального времени"));
               ui->label_realClockCalibration->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x23;
           bytesForChecking.append(byte);
           byte = 0x86;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);


             quint16  RTC_Offset = (quint8)buffer[4];
             RTC_Offset = RTC_Offset<<8 | (quint8)buffer[5];

             qDebug()<<"RTC_Offset "<<QString::number(RTC_Offset);

             quint16 RTC_Tcomp = (quint8)buffer[6];
             RTC_Tcomp = RTC_Tcomp<<8 | (quint8)buffer[7];

             qDebug()<<""<<QString::number(RTC_Tcomp);

             if(RTC_Offset == correctionCoefResult && RTC_Tcomp == 0) {
                 j = 3; // прекращаем самый внешний цикл 3-х кратной записи

                 qDebug()<<"Коэффициенты коррекции записаны успешно";

                 isWritingCorrect = true;

                 rtc_OffsetResult = QString::number(RTC_Offset);
                 rtc_TcompResult = QString::number(RTC_Tcomp);
             }






              break;
           }
           else {
               QMessageBox::information(this, "", tr("Ошибка калибровки генератора часов реального времени"));
               ui->label_realClockCalibration->setVisible(true);
               return;
           }



       }


    }


  }


  if(isWritingCorrect == false) { // проверка корректности записи калибровочных коээффициентов
      QMessageBox::information(this, "", "Не удалось корректно записать калибровочные коэффициенты");
      ui->label_realClockCalibration->setVisible(true);
  }
  else {
      ui->label_StatusBar->setText("Калибровка генератора часов: успешно");
      ui->label_realClockCalibration->setStyleSheet(QString("color: green").arg(color.name()));
      ui->label_realClockCalibration->setText("V");
      ui->label_realClockCalibration->setVisible(true);
  }
}

void MainWindow::setPrimeAddress(int workPlaceNumber)
{

    QSerialPort *portTmp;
    QByteArray buffer;
    //
    //
    //Write External Interface Settings 5a 00 0e 2b
    for(int i=0; i<3;i++) {

       portTmp->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x0e;
       packetToRead.append(byte);
       byte = 0x2b;
       packetToRead.append(byte);

       byte = addrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(addrByteArray);
       mapwrite["addrByteArray"] = addrByteArray;


       byte = baudRateByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(baudRateByteArray);
       mapwrite["baudRateByteArray"] = baudRateByteArray;


       byte = HMP_TransByteArray[0];
       packetToRead.append(byte);
       byte = HMP_TransByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(HMP_TransByteArray);
       mapwrite["HMP_TransByteArray"] = HMP_TransByteArray;


       byte = EPP_TransByteArray[0];
       packetToRead.append(byte);
       byte = EPP_TransByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(EPP_TransByteArray);
       mapwrite["EPP_TransByteArray"] = EPP_TransByteArray;


       byte = P1PrimAddrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(P1PrimAddrByteArray);
       mapwrite["P1PrimAddrByteArray"] = P1PrimAddrByteArray;


       byte = P2PrimAddrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(P2PrimAddrByteArray);
       mapwrite["P2PrimAddrByteArray"] = P2PrimAddrByteArray;


       byte = ProtTypeByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(ProtTypeByteArray);
       mapwrite["ProtTypeByteArray"] = ProtTypeByteArray;


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portTmp->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());
       signalLog(">> " + portTmp->portName() + " " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portTmp->portName() "<<portTmp->portName();

       if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
           ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                        ". Рабочее место: " + QString::number(workPlaceNumber+1));
           errorString.append(ui->label_StatusBar->text() + '\n');
           slotError(ui->label_StatusBar->text() + '\n');
           vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
           checkWritingError(currentIndicatorNumber);
           return;
       }

       global::pause(250);

       buffer = portTmp->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());
       if(!buffer.isEmpty()) emit signalLog("<< " + portTmp->portName() + " " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Interface Settings ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Не удалось записать данные : External Interface Settings ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               slotError(ui->label_StatusBar->text() + '\n');
               ui->label_writeParams->setVisible(true);
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkWritingError(currentIndicatorNumber);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xab;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
//                       QMessageBox::information(this, "", tr("Ошибка записи данных : External Interface Settings ") +
//                                                "Рабочее место: " + QString::number(workPlaceNumber+1));
                  ui->label_StatusBar->setText(tr("Ошибка записи данных : External Interface Settings ") +
                                               ". Рабочее место: " + QString::number(workPlaceNumber+1));
                  errorString.append(ui->label_StatusBar->text() + '\n');
                  slotError(ui->label_StatusBar->text() + '\n');
                  ui->label_writeParams->setVisible(true);
                  vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                  checkWritingError(currentIndicatorNumber);
                  return;
               }
           }



       }


    }

}

void MainWindow::setPrimeAddressDefault(int workPlaceNumber)
{
    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }


    currentBoxNumber = 8;
    vectorIsErrorOccured[workPlaceNumber] = false;

 //   ui->label_StatusBar->setText("");

    QByteArray buffer;

    //
    //----------------- Установка адресов все 1 -----------------

    //
    //
    //Write External Interface Settings 5a 00 0e 2b
    for(int i=0; i<3;i++) {

       portTmp->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x0e;
       packetToRead.append(byte);
       byte = 0x2b;
       packetToRead.append(byte);

       byte = 0x01;//(quint8)(workPlaceNumber + 1); //addrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(addrByteArray);
       mapwrite["addrByteArray"] = addrByteArray;


       byte = baudRateByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(baudRateByteArray);
       mapwrite["baudRateByteArray"] = baudRateByteArray;


       byte = HMP_TransByteArray[0];
       packetToRead.append(byte);
       byte = HMP_TransByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(HMP_TransByteArray);
       mapwrite["HMP_TransByteArray"] = HMP_TransByteArray;


       byte = EPP_TransByteArray[0];
       packetToRead.append(byte);
       byte = EPP_TransByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(EPP_TransByteArray);
       mapwrite["EPP_TransByteArray"] = EPP_TransByteArray;


       byte = P1PrimAddrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(P1PrimAddrByteArray);
       mapwrite["P1PrimAddrByteArray"] = P1PrimAddrByteArray;


       byte = P2PrimAddrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(P2PrimAddrByteArray);
       mapwrite["P2PrimAddrByteArray"] = P2PrimAddrByteArray;


       byte = ProtTypeByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(ProtTypeByteArray);
       mapwrite["ProtTypeByteArray"] = ProtTypeByteArray;


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portTmp->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());
       signalLog(QTime::currentTime().toString("hh:mm:ss") + " >> " + portTmp->portName() + " " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portTmp->portName() "<<portTmp->portName();

       if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
//                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
           ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                        ". Рабочее место: " + QString::number(workPlaceNumber+1));
           errorString.append(ui->label_StatusBar->text() + '\n');
           vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
           workPlaceOff(currentIndicatorNumber);
           checkWireInterfaceChecking(currentIndicatorNumber);
           return;
       }

       global::pause(250);

       buffer = portTmp->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());
       if(!buffer.isEmpty()) emit signalLog(QTime::currentTime().toString("hh:mm:ss") + " << " + portTmp->portName() + " " + buffer.toHex());


       if(buffer.isEmpty()) {
           if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Interface Settings ") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Не удалось установить исходный адрес : External Interface Settings ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
      //         ui->label_writeParams->setVisible(true);
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               workPlaceOff(currentIndicatorNumber);
               checkWireInterfaceChecking(currentIndicatorNumber);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xab;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] /*&&
                                       bytesForChecking[2] == buffer[2]*/ && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
//                       QMessageBox::information(this, "", tr("Ошибка записи данных : External Interface Settings ") +
//                                                "Рабочее место: " + QString::number(workPlaceNumber+1));
                  ui->label_StatusBar->setText(tr("Не удалось установить исходный адрес : External Interface Settings ") +
                                               ". Рабочее место: " + QString::number(workPlaceNumber+1));
                  errorString.append(ui->label_StatusBar->text() + '\n');
    //              ui->label_writeParams->setVisible(true);
                  vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                  workPlaceOff(currentIndicatorNumber);
                  checkWireInterfaceChecking(currentIndicatorNumber);
                  return;
               }
           }



       }


    }


    //
    //----------------- Установка адресов от 1 до 4 -----------------/
}

void MainWindow::wireInterfaceCheckModified(int workPlaceNumber)
{

        QSerialPort *portTmp;

        isNeedPaintEvent = true;//false;

        switch (workPlaceNumber) {
        case 0:
            portTmp = portOptical;
            currentIndicatorNumber = 0;
            break;
        case 1:
            portTmp = portOptical2;
            currentIndicatorNumber = 1;
            break;
        case 2:
            portTmp = portOptical3;
            currentIndicatorNumber = 2;
            break;
        case 3:
            portTmp = portOptical4;
            currentIndicatorNumber = 3;
            break;

        default:
            break;
        }


        currentBoxNumber = 8;
        vectorIsErrorOccured[workPlaceNumber] = false;

            ui->label_StatusBar->setText("");

            QColor color(255, 127, 50);
            ui->label_digitalWireInterfaceChecking->setStyleSheet(QString("color: red").arg(color.name()));
            ui->label_digitalWireInterfaceChecking->setText("X");
            ui->label_digitalWireInterfaceChecking->setVisible(false);

            QByteArray buffer;

            if(!portDigitalInterfaceChecking->isOpen()) {
                if(!portDigitalInterfaceChecking->open(QIODevice::ReadWrite)) {
                    QMessageBox::information(this, "", "Не удалось открыть порт: Проводные интерфейсы");
                    return;
                }
            }

            if(!portTmp->isOpen()) {
                if(!portTmp->open(QIODevice::ReadWrite)) {
                    QMessageBox::information(this, "", tr("Не удалось открыть порт: ИК") +
                                             ". Рабочее место: " + QString::number(workPlaceNumber+1));
                    return;
                }
            }


            //Открыть парольную сессию 5a 00 08 40 01 04 57
            for(int i=0; i<10;i++) {

               portTmp->clear();
               packetToRead.clear();
               buffer.clear();
               quint8 byte = 0x5a;
               packetToRead.append(byte);
               byte = 0x00;
               packetToRead.append(byte);
               byte = 0x08;
               packetToRead.append(byte);
               byte = 0x40;
               packetToRead.append(byte);
               byte = 0x01;
               packetToRead.append(byte);
               byte = 0x04;
               packetToRead.append(byte);
               byte = 0x57;
               packetToRead.append(byte);
               quint8 crc = makeCRC(packetToRead);
               packetToRead.append(crc);

               quint64 cnt = portTmp->write(packetToRead);
               ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

               qDebug()<<"cnt "<<cnt
                       <<"packetToRead.toHex() "<<packetToRead.toHex()
                       <<"portTmp->portName() "<<portTmp->portName();

               if(cnt == 0) {
    //               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
    //                                                 " Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWireInterfaceChecking(currentIndicatorNumber);
                   return;
               }

               global::pause(300);

               buffer = portTmp->readAll();
               qDebug()<<"buffer.toHex()"<<buffer.toHex();
               ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

               if(buffer.isEmpty()) {
                   if(i==9) {
    //                   QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
    //                                                         " Рабочее место: " + QString::number(workPlaceNumber+1));
                       ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                    ". Рабочее место: " + QString::number(workPlaceNumber+1));
                       errorString.append(ui->label_StatusBar->text() + '\n');
                       vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                       checkWireInterfaceChecking(currentIndicatorNumber);
                       ui->label_pulsesOutputHeat->setVisible(true);
                       return;
                   } else{}

               }
               else {
                   //проверяем crc и первые четыре байта ответного пакета
                   QByteArray bytesForChecking;
                   quint8 byte = 0x5a;
                   bytesForChecking.append(byte);
                   byte = 0x00;
                   bytesForChecking.append(byte);
                   byte = 0x06;
                   bytesForChecking.append(byte);
                   byte = 0xc0;
                   bytesForChecking.append(byte);

                   if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                               bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                      qDebug()<<"buffer.toHex() "<<buffer.toHex()
                           <<"checkCRC(buffer) "<<checkCRC(buffer);


                      //
                      //



                      break;
                   }
                   else {
                            if(i==9) {
    //                            QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
    //                                                     " Рабочее место: " + QString::number(workPlaceNumber+1));
                                ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                             ". Рабочее место: " + QString::number(workPlaceNumber+1));
                                errorString.append(ui->label_StatusBar->text() + '\n');
                                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                                checkWireInterfaceChecking(currentIndicatorNumber);
                                ui->label_pulsesOutputHeat->setVisible(true);
                                return;
                            }

                   }



               }


            }

            //Открыть парольную сессию 5a 00 08 40 01 04 57 /


            //
            //----------------- Установка адресов от 1 до 4 -----------------

            //
            //
            //Write External Interface Settings 5a 00 0e 2b
            for(int i=0; i<3;i++) {

               portTmp->clear();
               packetToRead.clear();
               buffer.clear();
               quint8 byte = 0x5a;
               packetToRead.append(byte);
               byte = 0x00;
               packetToRead.append(byte);
               byte = 0x0e;
               packetToRead.append(byte);
               byte = 0x2b;
               packetToRead.append(byte);

               byte = (quint8)(workPlaceNumber + 1); //addrByteArray[0];
               packetToRead.append(byte);
               paramsVectorToWrite.append(addrByteArray);
               mapwrite["addrByteArray"] = addrByteArray;


               byte = baudRateByteArray[0];
               packetToRead.append(byte);
               paramsVectorToWrite.append(baudRateByteArray);
               mapwrite["baudRateByteArray"] = baudRateByteArray;


               byte = HMP_TransByteArray[0];
               packetToRead.append(byte);
               byte = HMP_TransByteArray[1];
               packetToRead.append(byte);
               paramsVectorToWrite.append(HMP_TransByteArray);
               mapwrite["HMP_TransByteArray"] = HMP_TransByteArray;


               byte = EPP_TransByteArray[0];
               packetToRead.append(byte);
               byte = EPP_TransByteArray[1];
               packetToRead.append(byte);
               paramsVectorToWrite.append(EPP_TransByteArray);
               mapwrite["EPP_TransByteArray"] = EPP_TransByteArray;


               byte = P1PrimAddrByteArray[0];
               packetToRead.append(byte);
               paramsVectorToWrite.append(P1PrimAddrByteArray);
               mapwrite["P1PrimAddrByteArray"] = P1PrimAddrByteArray;


               byte = P2PrimAddrByteArray[0];
               packetToRead.append(byte);
               paramsVectorToWrite.append(P2PrimAddrByteArray);
               mapwrite["P2PrimAddrByteArray"] = P2PrimAddrByteArray;


               byte = ProtTypeByteArray[0];
               packetToRead.append(byte);
               paramsVectorToWrite.append(ProtTypeByteArray);
               mapwrite["ProtTypeByteArray"] = ProtTypeByteArray;


               quint8 crc = makeCRC(packetToRead);
               packetToRead.append(crc);

               quint64 cnt = portTmp->write(packetToRead);
               ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

               qDebug()<<"cnt "<<cnt
                       <<"packetToRead.toHex() "<<packetToRead.toHex()
                       <<"portTmp->portName() "<<portTmp->portName();

               if(cnt == 0) {
        //               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
        //                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWireInterfaceChecking(currentIndicatorNumber);
                   return;
               }

               global::pause(150);

               buffer = portTmp->readAll();
               qDebug()<<"buffer.toHex()"<<buffer.toHex();
               ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

               if(buffer.isEmpty()) {
                   if(i==2) {
        //                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Interface Settings ") +
        //                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                       ui->label_StatusBar->setText(tr("Не удалось установить адрес : External Interface Settings ") +
                                                    ". Рабочее место: " + QString::number(workPlaceNumber+1));
                       errorString.append(ui->label_StatusBar->text() + '\n');
                       ui->label_writeParams->setVisible(true);
                       vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                       checkWireInterfaceChecking(currentIndicatorNumber);
                       return;
                   } else{}

               }
               else {
                   //проверяем crc и первые четыре байта ответного пакета
                   QByteArray bytesForChecking;
                   quint8 byte = 0x5a;
                   bytesForChecking.append(byte);
                   byte = 0x00;
                   bytesForChecking.append(byte);
                   byte = 0x06;
                   bytesForChecking.append(byte);
                   byte = 0xab;
                   bytesForChecking.append(byte);

                   quint8 error = buffer[4];

                   if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                               bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                      qDebug()<<"buffer.toHex() "<<buffer.toHex()
                           <<"checkCRC(buffer) "<<checkCRC(buffer);

                      //


                      //
                      //



                      break;
                   }
                   else {
                       if(i==2) {
        //                       QMessageBox::information(this, "", tr("Ошибка записи данных : External Interface Settings ") +
        //                                                "Рабочее место: " + QString::number(workPlaceNumber+1));
                          ui->label_StatusBar->setText(tr("Не удалось установить адрес : External Interface Settings ") +
                                                       ". Рабочее место: " + QString::number(workPlaceNumber+1));
                          errorString.append(ui->label_StatusBar->text() + '\n');
                          ui->label_writeParams->setVisible(true);
                          vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                          checkWireInterfaceChecking(currentIndicatorNumber);
                          return;
                       }
                   }



               }


            }


            //
            //----------------- Установка адресов от 1 до 4 -----------------/


            //
            //
            //Проверка проводных интерфейсов 10 5B FE 59 16

            for(int i=0; i<3;i++) {

               portDigitalInterfaceChecking->clear();
               packetToRead.clear();
               buffer.clear();
               quint8 byte = 0x10;
               packetToRead.append(byte);
               byte = 0x5b;
               packetToRead.append(byte);
               byte = (quint8)(workPlaceNumber + 1);//0xfe;
               packetToRead.append(byte);
               byte = (quint8)(0x5b + workPlaceNumber + 1);//0x59;
               packetToRead.append(byte);
               byte = 0x16;
               packetToRead.append(byte);

               quint64 cnt = portDigitalInterfaceChecking->write(packetToRead);
               ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

               qDebug()<<"cnt "<<cnt
                       <<"packetToRead.toHex() "<<packetToRead.toHex()
                       <<"portDigitalInterfaceChecking->portName() "<<portDigitalInterfaceChecking->portName();

               if(cnt == 0) {
      //             QMessageBox::information(this, "", tr("Данные в порт не записаны"));
                   ui->label_StatusBar->setText(tr("Данные в порт не записаны. Ошибка проверки проводных интерфейсов") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkWireInterfaceChecking(currentIndicatorNumber);
                   setPrimeAddressDefault(workPlaceNumber);
                   return;
               }

               global::pause(2000);

               buffer = portDigitalInterfaceChecking->readAll();
               qDebug()<<"buffer.toHex()"<<buffer.toHex();
               ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

               if(buffer.isEmpty()) {
                   if(i==2) {
       //                QMessageBox::information(this, "", tr("Ошибка проверки проводных интерфейсов"));
                       ui->label_StatusBar->setText(tr("Ошибка проверки проводных интерфейсов") +
                                                    ". Рабочее место: " + QString::number(workPlaceNumber+1));
                       errorString.append(ui->label_StatusBar->text() + '\n');
                       ui->label_writeParams->setVisible(true);
                       vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                       checkWireInterfaceChecking(currentIndicatorNumber);
                       setPrimeAddressDefault(workPlaceNumber);
                       ui->label_digitalWireInterfaceChecking->setVisible(true);

                       usableResult = "Не годен";
        //               on_toolButton_result_clicked();

                       return;
                   } else{}

               }
               else {

                   int len =  (quint8)buffer[1];
                   quint8 crcBeyondEndOfLen = (quint8)buffer.at(4 + len);

                   quint64 sumBytes = 0;
                   for(int u=4; u<(4 + len)/*(buffer.size() - 2)*/; u++) {
                       sumBytes = sumBytes + (quint8)buffer[u];
                   }

                   quint8 crcMod256 = (quint8)sumBytes;

                   qDebug()<<"crcMod256 = "<<QString::number(crcMod256);

                   QByteArray firstFourBytesArray;
                   firstFourBytesArray.append((quint8)buffer.at(0));
                   firstFourBytesArray.append((quint8)buffer.at(1));
                   firstFourBytesArray.append((quint8)buffer.at(2));
                   firstFourBytesArray.append((quint8)buffer.at(3));

                   //
                   //проверяем первые 4 байта
                   if( (firstFourBytesArray.at(0) != 0x68) || (firstFourBytesArray.at(3) != 0x68) ||
                           (firstFourBytesArray.at(1) != firstFourBytesArray.at(2)) ||
                           (buffer.at(4) != 0x08) ||
                           (buffer.at(6) != 0x72) ||
                           (buffer.at(4 + len + 1) != 0x16) ) {

                       if(i==2) {
                           QMessageBox::information(this, "", tr("Ошибка проверки проводных интерфейсов"));
                           ui->label_StatusBar->setText(tr("Ошибка проверки проводных интерфейсов") +
                                                        ". Рабочее место: " + QString::number(workPlaceNumber+1));
                           errorString.append(ui->label_StatusBar->text() + '\n');
                           ui->label_writeParams->setVisible(true);
                           vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                           checkWireInterfaceChecking(currentIndicatorNumber);
                           setPrimeAddressDefault(workPlaceNumber);
                           ui->label_digitalWireInterfaceChecking->setVisible(true);

                           usableResult = "Не годен";
            //               on_toolButton_result_clicked();

                           return;
                       } else{}

                   }
                   //
                   //проверяем первые 4 байта/




        //           Answer
        //           68	Begin Sync
        //           52	Len
        //           52	Len
        //           68	Begin Sync
        //           08	C-field
        //           Adr	Primary address
        //           72	CI-field
        //           xx	Serial
        //           xx
        //           xx
        //           xx
        //           B4	Man ID - SET
        //           4C
        //           01	Ver
        //           04 / 0C	Type
        //           xx	Num
        //           xx	Stat
        //           00	Sign
        //           00
        //           04	DIF
        //           FB	VIF
        //           0D
        //           xx	Heat energy, 1 Mcal
        //           xx
        //           xx
        //           xx
        //           04	DIF
        //           13	VIF
        //           xx	Volume, 1 l
        //           xx
        //           xx
        //           xx
        //           04	DIF
        //           1B	VIF
        //           xx	Mass, 1 kg
        //           xx
        //           xx
        //           xx
        //           02	DIF
        //           59	VIF
        //           xx	Inlet temperature,      0,01 °CInlet temperature,      0,01 °C
        //           xx
        //           02	DIF
        //           5D	VIF
        //           xx	Oulet temperature,      0,01 °COulet temperature,      0,01 °C
        //           xx
        //           02	DIF
        //           61	VIF
        //           xx	temperature differential, 10 mK
        //           xx
        //           04	DIF
        //           FD	VIF
        //           17
        //           xx	Tin_Er && Tout_Er
        //           xx	dT_Er && Flow_Er
        //           xx	Magnet state
        //           xx	CRC
        //           16	End Sync


                   if(crcMod256 = crcBeyondEndOfLen/*buffer[buffer.size()-2]*/) {

                      qDebug()<<"buffer.toHex() "<<buffer.toHex()
                           <<"checkCRC(buffer) "<<checkCRC(buffer);

       //            ui->label_StatusBar->setText("Проверка проводных интерфейсов : Успешно");
                   ui->label_digitalWireInterfaceChecking->setStyleSheet(QString("color: green").arg(color.name()));
                   ui->label_digitalWireInterfaceChecking->setText("V");
       //            ui->label_digitalWireInterfaceChecking->setVisible(true);


        //              if(((ui->label_writeParams->text() == "V") && (ui->label_writeParams->isVisible() == true)) &&
        //                 ((ui->label_Calibration->text() == "V") && (ui->label_Calibration->isVisible() == true)) &&
        //                 ((ui->label_pulsesOutputHeat->text() == "V") && (ui->label_pulsesOutputHeat->isVisible() == true)) &&
        //                 ((ui->label_pulsesInputVolume->text() == "V") && (ui->label_pulsesInputVolume->isVisible() == true)) &&
        //                 ((ui->label_pulsesOutputOff->text() == "V") && (ui->label_pulsesOutputOff->isVisible() == true)) &&
        //                 ((ui->label_CheckMbus->text() == "V") && (ui->label_CheckMbus->isVisible() == true)) &&
        //                 ((ui->label_calibrationModeOff->text() == "V") && (ui->label_calibrationModeOff->isVisible() == true)) &&
        //                 ((ui->label_digitalWireInterfaceChecking->text() == "V") && (ui->label_digitalWireInterfaceChecking->isVisible() == true)) &&
        //                 ((ui->label_RMV_ErrorFlags_tick->text() == "V") && (ui->label_RMV_ErrorFlags_tick->isVisible() == true))     )   {


        //                  usableResult = "Годен";
        //  //                  on_toolButton_result_clicked();

        //              }
        //              else {
        //                  usableResult = "Не годен";
        //  //                  on_toolButton_result_clicked();
        //              }





                      break;
                   }
                   else {
                       if (i==2) {
                       QMessageBox::information(this, "", tr("Ошибка проверки проводных интерфейсов"));
                       ui->label_StatusBar->setText(tr("Ошибка проверки проводных интерфейсов") +
                                                    ". Рабочее место: " + QString::number(workPlaceNumber+1));
                       errorString.append(ui->label_StatusBar->text() + '\n');
                       ui->label_writeParams->setVisible(true);
                       vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                       checkWireInterfaceChecking(currentIndicatorNumber);
                       setPrimeAddressDefault(workPlaceNumber);
      //                 ui->label_StatusBar->setText("Проверка проводных интерфейсов : Неудачно");
                       ui->label_digitalWireInterfaceChecking->setVisible(true);

                       usableResult = "Не годен";
        //               on_toolButton_result_clicked();

                       return;
                       }
                   }



               }


            }


            //
            //
            //Проверка проводных интерфейсов 10 5B FE 59 16 /


            //установка исходного адреса

            setPrimeAddressDefault(workPlaceNumber);

            checkWireInterfaceChecking(workPlaceNumber);

}

void MainWindow::wireInterfaceChecking(int workPlaceNumber)
{

    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }


    currentBoxNumber = 7;
    vectorIsErrorOccured[workPlaceNumber] = false;

        ui->label_StatusBar->setText("");

        QColor color(255, 127, 50);
        ui->label_digitalWireInterfaceChecking->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_digitalWireInterfaceChecking->setText("X");
        ui->label_digitalWireInterfaceChecking->setVisible(false);

        QByteArray buffer;

        if(!portDigitalInterfaceChecking->isOpen()) {
            if(!portDigitalInterfaceChecking->open(QIODevice::ReadWrite)) {
 //               QMessageBox::information(this, "", "Не удалось открыть порт: Проводные интерфейсы");
                ui->label_StatusBar->setText(tr("Не удалось открыть порт: Проводные интерфейсы") +
                                             ". Рабочее место: " + QString::number(workPlaceNumber+1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                slotError(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                workPlaceOff(currentIndicatorNumber);
                checkWireInterfaceChecking(currentIndicatorNumber);
                return;
            }
        }

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
//                QMessageBox::information(this, "", tr("Не удалось открыть порт: ИК") +
//                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                ui->label_StatusBar->setText(tr("Не удалось открыть порт: ИК") +
                                             ". Рабочее место: " + QString::number(workPlaceNumber+1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                slotError(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                workPlaceOff(currentIndicatorNumber);
                checkWireInterfaceChecking(currentIndicatorNumber);
                return;
            }
        }


        //Открыть парольную сессию 5a 00 08 40 01 04 57
        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x08;
           packetToRead.append(byte);
           byte = 0x40;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);
           byte = 0x04;
           packetToRead.append(byte);
           byte = 0x57;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());
           signalLog(QTime::currentTime().toString("hh:mm:ss") + " >> " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 " Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               slotError(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               workPlaceOff(currentIndicatorNumber);
               checkWireInterfaceChecking(currentIndicatorNumber);
               return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());
          /* if(!buffer.isEmpty()) */ emit signalLog(QTime::currentTime().toString("hh:mm:ss") + " << " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
//                   QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                                         " Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   slotError(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   workPlaceOff(currentIndicatorNumber);
                   checkWireInterfaceChecking(currentIndicatorNumber);
       //            ui->label_pulsesOutputHeat->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc0;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] /*&&
                                           bytesForChecking[2] == buffer[2]*/ && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);


                  //
                  //



                  break;
               }
               else {
                        if(i==9) {
//                            QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                                     " Рабочее место: " + QString::number(workPlaceNumber+1));
                            ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            slotError(ui->label_StatusBar->text() + '\n');
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            workPlaceOff(currentIndicatorNumber);
                            checkWireInterfaceChecking(currentIndicatorNumber);
     //                       ui->label_pulsesOutputHeat->setVisible(true);
                            return;
                        }

               }



           }


        }

        //Открыть парольную сессию 5a 00 08 40 01 04 57 /


        //
        //----------------- Установка адресов от 1 до 4 -----------------

        //
        //
        //Write External Interface Settings 5a 00 0e 2b
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x0e;
           packetToRead.append(byte);
           byte = 0x2b;
           packetToRead.append(byte);

           byte = (quint8)(workPlaceNumber + 1); //addrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(addrByteArray);
           mapwrite["addrByteArray"] = addrByteArray;


           byte = baudRateByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(baudRateByteArray);
           mapwrite["baudRateByteArray"] = baudRateByteArray;


           byte = HMP_TransByteArray[0];
           packetToRead.append(byte);
           byte = HMP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(HMP_TransByteArray);
           mapwrite["HMP_TransByteArray"] = HMP_TransByteArray;


           byte = EPP_TransByteArray[0];
           packetToRead.append(byte);
           byte = EPP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(EPP_TransByteArray);
           mapwrite["EPP_TransByteArray"] = EPP_TransByteArray;


           byte = P1PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P1PrimAddrByteArray);
           mapwrite["P1PrimAddrByteArray"] = P1PrimAddrByteArray;


           byte = P2PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P2PrimAddrByteArray);
           mapwrite["P2PrimAddrByteArray"] = P2PrimAddrByteArray;


           byte = ProtTypeByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ProtTypeByteArray);
           mapwrite["ProtTypeByteArray"] = ProtTypeByteArray;


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());
           signalLog(QTime::currentTime().toString("hh:mm:ss") + " >> " + portTmp->portName() + " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
    //               QMessageBox::information(this, "", tr("Данные в порт не записаны ") +
    //                                                 "Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны ") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               slotError(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               workPlaceOff(currentIndicatorNumber);
               checkWireInterfaceChecking(currentIndicatorNumber);
               return;
           }

           global::pause(250);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());
           if(!buffer.isEmpty()) emit signalLog(QTime::currentTime().toString("hh:mm:ss") + " << " + portTmp->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
    //                   QMessageBox::information(this, "", tr("Не удалось записать данные : External Interface Settings ") +
    //                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось установить адрес : External Interface Settings ") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   slotError(ui->label_StatusBar->text() + '\n');
                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   workPlaceOff(currentIndicatorNumber);
                   checkWireInterfaceChecking(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xab;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] /*&&
                                           bytesForChecking[2] == buffer[2]*/ && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
    //                       QMessageBox::information(this, "", tr("Ошибка записи данных : External Interface Settings ") +
    //                                                "Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Не удалось установить адрес : External Interface Settings ") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      slotError(ui->label_StatusBar->text() + '\n');
      //                ui->label_writeParams->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      workPlaceOff(currentIndicatorNumber);
                      checkWireInterfaceChecking(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }


        //
        //----------------- Установка адресов от 1 до 4 -----------------/


        //
        //
        //Проверка проводных интерфейсов 10 5B FE 59 16

        for(int i=0; i<3;i++) {

           portDigitalInterfaceChecking->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x10;
           packetToRead.append(byte);
           byte = 0x5b;
           packetToRead.append(byte);
           byte = (quint8)(workPlaceNumber + 1);//0xfe;
           packetToRead.append(byte);
           byte = (quint8)(0x5b + workPlaceNumber + 1);//0x59;
           packetToRead.append(byte);
           byte = 0x16;
           packetToRead.append(byte);

           quint64 cnt = portDigitalInterfaceChecking->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           signalLog(QTime::currentTime().toString("hh:mm:ss") + " >> " + portDigitalInterfaceChecking->portName() +
                     " " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portDigitalInterfaceChecking->portName() "<<portDigitalInterfaceChecking->portName();

           if(cnt == 0) {
  //             QMessageBox::information(this, "", tr("Данные в порт не записаны"));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны. Ошибка проверки проводных интерфейсов") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               slotError(ui->label_StatusBar->text() + '\n');
    //           ui->label_writeParams->setVisible(true);
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               workPlaceOff(currentIndicatorNumber);
               checkWireInterfaceChecking(currentIndicatorNumber);
               setPrimeAddressDefault(workPlaceNumber);
               return;
           }

           global::pause(2000);//(2000);//экспериментируем

           buffer = portDigitalInterfaceChecking->readAll();

           //искусственно очищаем buffer после первой попытки
//          if(i=0) buffer.clear();
           //искусственно очищаем buffer после первой попытки/

           qDebug()<<"buffer.toHex()"<<buffer.toHex();

           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

         /*  if(!buffer.isEmpty()) */ emit signalLog(QTime::currentTime().toString("hh:mm:ss") + " << " +
                                                portDigitalInterfaceChecking->portName() + " " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
   //                QMessageBox::information(this, "", tr("Ошибка проверки проводных интерфейсов"));
                   ui->label_StatusBar->setText(tr("Ошибка проверки проводных интерфейсов") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   slotError(ui->label_StatusBar->text() + '\n');
    //               ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   workPlaceOff(currentIndicatorNumber);
                   checkWireInterfaceChecking(currentIndicatorNumber);
                   setPrimeAddressDefault(workPlaceNumber);
    //               ui->label_digitalWireInterfaceChecking->setVisible(true);

    //               usableResult = "Не годен";
    //               on_toolButton_result_clicked();

                   return;
               } else{}

           }
           else {

               int len =  (quint8)buffer[1];

               if( (len + 6) != buffer.size() ) {
                   slotError(tr("Неверная длина пакета") + ". Рабочее место: " + QString::number(workPlaceNumber+1) + '\n');

                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   workPlaceOff(currentIndicatorNumber);
                   checkWireInterfaceChecking(currentIndicatorNumber);
                   setPrimeAddressDefault(workPlaceNumber);
                   return;
               }

               quint8 crcBeyondEndOfLen = (quint8)buffer.at(4 + len);

               quint64 sumBytes = 0;
               for(int u=4; u<(4 + len)/*(buffer.size() - 2)*/; u++) {
                   sumBytes = sumBytes + (quint8)buffer[u];
               }

               quint8 crcMod256 = (quint8)sumBytes;

               qDebug()<<"crcMod256 = "<<QString::number(crcMod256);

               QByteArray firstFourBytesArray;
               firstFourBytesArray.append((quint8)buffer.at(0));
               firstFourBytesArray.append((quint8)buffer.at(1));
               firstFourBytesArray.append((quint8)buffer.at(2));
               firstFourBytesArray.append((quint8)buffer.at(3));

               //
               //проверяем первые 4 байта
               if( (firstFourBytesArray.at(0) != 0x68) || (firstFourBytesArray.at(3) != 0x68) ||
                       (firstFourBytesArray.at(1) != firstFourBytesArray.at(2)) ||
                       (buffer.at(4) != 0x08) ||
                       (buffer.at(6) != 0x72) ||
                       (buffer.at(4 + len + 1) != 0x16) ) {

                   if(i==2) {
                       QMessageBox::information(this, "", tr("Ошибка проверки проводных интерфейсов"));
                       ui->label_StatusBar->setText(tr("Ошибка проверки проводных интерфейсов") +
                                                    ". Рабочее место: " + QString::number(workPlaceNumber+1));
                       errorString.append(ui->label_StatusBar->text() + '\n');
                       slotError(ui->label_StatusBar->text() + '\n');
      //                 ui->label_writeParams->setVisible(true);
                       vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                       workPlaceOff(currentIndicatorNumber);
                       checkWireInterfaceChecking(currentIndicatorNumber);
                       setPrimeAddressDefault(workPlaceNumber);
      //                 ui->label_digitalWireInterfaceChecking->setVisible(true);

      //                 usableResult = "Не годен";
        //               on_toolButton_result_clicked();

                       return;
                   } else{}

               }
               //
               //проверяем первые 4 байта/




    //           Answer
    //           68	Begin Sync
    //           52	Len
    //           52	Len
    //           68	Begin Sync
    //           08	C-field
    //           Adr	Primary address
    //           72	CI-field
    //           xx	Serial
    //           xx
    //           xx
    //           xx
    //           B4	Man ID - SET
    //           4C
    //           01	Ver
    //           04 / 0C	Type
    //           xx	Num
    //           xx	Stat
    //           00	Sign
    //           00
    //           04	DIF
    //           FB	VIF
    //           0D
    //           xx	Heat energy, 1 Mcal
    //           xx
    //           xx
    //           xx
    //           04	DIF
    //           13	VIF
    //           xx	Volume, 1 l
    //           xx
    //           xx
    //           xx
    //           04	DIF
    //           1B	VIF
    //           xx	Mass, 1 kg
    //           xx
    //           xx
    //           xx
    //           02	DIF
    //           59	VIF
    //           xx	Inlet temperature,      0,01 °CInlet temperature,      0,01 °C
    //           xx
    //           02	DIF
    //           5D	VIF
    //           xx	Oulet temperature,      0,01 °COulet temperature,      0,01 °C
    //           xx
    //           02	DIF
    //           61	VIF
    //           xx	temperature differential, 10 mK
    //           xx
    //           04	DIF
    //           FD	VIF
    //           17
    //           xx	Tin_Er && Tout_Er
    //           xx	dT_Er && Flow_Er
    //           xx	Magnet state
    //           xx	CRC
    //           16	End Sync


               if(crcMod256 = crcBeyondEndOfLen/*buffer[buffer.size()-2]*/) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

   //            ui->label_StatusBar->setText("Проверка проводных интерфейсов : Успешно");
   //            ui->label_digitalWireInterfaceChecking->setStyleSheet(QString("color: green").arg(color.name()));
   //            ui->label_digitalWireInterfaceChecking->setText("V");
   //            ui->label_digitalWireInterfaceChecking->setVisible(true);


    //              if(((ui->label_writeParams->text() == "V") && (ui->label_writeParams->isVisible() == true)) &&
    //                 ((ui->label_Calibration->text() == "V") && (ui->label_Calibration->isVisible() == true)) &&
    //                 ((ui->label_pulsesOutputHeat->text() == "V") && (ui->label_pulsesOutputHeat->isVisible() == true)) &&
    //                 ((ui->label_pulsesInputVolume->text() == "V") && (ui->label_pulsesInputVolume->isVisible() == true)) &&
    //                 ((ui->label_pulsesOutputOff->text() == "V") && (ui->label_pulsesOutputOff->isVisible() == true)) &&
    //                 ((ui->label_CheckMbus->text() == "V") && (ui->label_CheckMbus->isVisible() == true)) &&
    //                 ((ui->label_calibrationModeOff->text() == "V") && (ui->label_calibrationModeOff->isVisible() == true)) &&
    //                 ((ui->label_digitalWireInterfaceChecking->text() == "V") && (ui->label_digitalWireInterfaceChecking->isVisible() == true)) &&
    //                 ((ui->label_RMV_ErrorFlags_tick->text() == "V") && (ui->label_RMV_ErrorFlags_tick->isVisible() == true))     )   {


    //                  usableResult = "Годен";
    //  //                  on_toolButton_result_clicked();

    //              }
    //              else {
    //                  usableResult = "Не годен";
    //  //                  on_toolButton_result_clicked();
    //              }





                  break;
               }
               else {
                   if (i==2) {
    //               QMessageBox::information(this, "", tr("Ошибка проверки проводных интерфейсов"));
                   ui->label_StatusBar->setText(tr("Ошибка проверки проводных интерфейсов") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   slotError(ui->label_StatusBar->text() + '\n');
  //                 ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   workPlaceOff(currentIndicatorNumber);
                   checkWireInterfaceChecking(currentIndicatorNumber);
                   setPrimeAddressDefault(workPlaceNumber);
  //                 ui->label_StatusBar->setText("Проверка проводных интерфейсов : Неудачно");
  //                 ui->label_digitalWireInterfaceChecking->setVisible(true);

  //                 usableResult = "Не годен";
    //               on_toolButton_result_clicked();

                   return;
                   }
               }



           }


        }


        //
        //
        //Проверка проводных интерфейсов 10 5B FE 59 16 /


        //установка исходного адреса

        setPrimeAddressDefault(workPlaceNumber);

        checkWireInterfaceChecking(workPlaceNumber);

}

/*****************************************************************/
void MainWindow::on_toolButton_digitalWireInterfaceChecking_clicked()
{
    ui->label_StatusBar->setText("");

    QColor color(255, 127, 50);
    ui->label_digitalWireInterfaceChecking->setStyleSheet(QString("color: red").arg(color.name()));
    ui->label_digitalWireInterfaceChecking->setText("X");
    ui->label_digitalWireInterfaceChecking->setVisible(false);

    QByteArray buffer;

    if(!portDigitalInterfaceChecking->isOpen()) {
        if(!portDigitalInterfaceChecking->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт");
            return;
        }
    }


    //
    //Проверка проводных интерфейсов 10 5B FE 59 16

    for(int i=0; i<3;i++) {

       portDigitalInterfaceChecking->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x10;
       packetToRead.append(byte);
       byte = 0x5b;
       packetToRead.append(byte);
       byte = 0xfe;
       packetToRead.append(byte);
       byte = 0x59;
       packetToRead.append(byte);
       byte = 0x16;
       packetToRead.append(byte);

       quint64 cnt = portDigitalInterfaceChecking->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portDigitalInterfaceChecking->portName() "<<portDigitalInterfaceChecking->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(2000);

       buffer = portDigitalInterfaceChecking->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Ошибка проверки проводных интерфейсов"));
               ui->label_digitalWireInterfaceChecking->setVisible(true);

               usableResult = "Не годен";
//               on_toolButton_result_clicked();

               return;
           } else{}

       }
       else {

           int len =  (quint8)buffer[1];
           quint8 crcBeyondEndOfLen = (quint8)buffer.at(4 + len);

           quint64 sumBytes = 0;
           for(int u=4; u<(4 + len)/*(buffer.size() - 2)*/; u++) {
               sumBytes = sumBytes + (quint8)buffer[u];
           }

           quint8 crcMod256 = (quint8)sumBytes;

           qDebug()<<"crcMod256 = "<<QString::number(crcMod256);

           QByteArray firstFourBytesArray;
           firstFourBytesArray.append((quint8)buffer.at(0));
           firstFourBytesArray.append((quint8)buffer.at(1));
           firstFourBytesArray.append((quint8)buffer.at(2));
           firstFourBytesArray.append((quint8)buffer.at(3));

           //
           //проверяем первые 4 байта
           if( (firstFourBytesArray.at(0) != 0x68) || (firstFourBytesArray.at(3) != 0x68) ||
                   (firstFourBytesArray.at(1) != firstFourBytesArray.at(2)) ||
                   (buffer.at(4) != 0x08) ||
                   (buffer.at(6) != 0x72) ||
                   (buffer.at(4 + len + 1) != 0x16) ) {

               if(i==2) {
                   QMessageBox::information(this, "", tr("Ошибка проверки проводных интерфейсов"));
                   ui->label_digitalWireInterfaceChecking->setVisible(true);

                   usableResult = "Не годен";
    //               on_toolButton_result_clicked();

                   return;
               } else{}

           }
           //
           //проверяем первые 4 байта/




//           Answer
//           68	Begin Sync           
//           52	Len
//           52	Len
//           68	Begin Sync
//           08	C-field
//           Adr	Primary address
//           72	CI-field
//           xx	Serial
//           xx
//           xx
//           xx
//           B4	Man ID - SET
//           4C
//           01	Ver
//           04 / 0C	Type
//           xx	Num
//           xx	Stat
//           00	Sign
//           00
//           04	DIF
//           FB	VIF
//           0D
//           xx	Heat energy, 1 Mcal
//           xx
//           xx
//           xx
//           04	DIF
//           13	VIF
//           xx	Volume, 1 l
//           xx
//           xx
//           xx
//           04	DIF
//           1B	VIF
//           xx	Mass, 1 kg
//           xx
//           xx
//           xx
//           02	DIF
//           59	VIF
//           xx	Inlet temperature,      0,01 °CInlet temperature,      0,01 °C
//           xx
//           02	DIF
//           5D	VIF
//           xx	Oulet temperature,      0,01 °COulet temperature,      0,01 °C
//           xx
//           02	DIF
//           61	VIF
//           xx	temperature differential, 10 mK
//           xx
//           04	DIF
//           FD	VIF
//           17
//           xx	Tin_Er && Tout_Er
//           xx	dT_Er && Flow_Er
//           xx	Magnet state
//           xx	CRC
//           16	End Sync


           if(crcMod256 = crcBeyondEndOfLen/*buffer[buffer.size()-2]*/) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

           ui->label_StatusBar->setText("Проверка проводных интерфейсов : Успешно");
           ui->label_digitalWireInterfaceChecking->setStyleSheet(QString("color: green").arg(color.name()));
           ui->label_digitalWireInterfaceChecking->setText("V");
           ui->label_digitalWireInterfaceChecking->setVisible(true);


//              if(((ui->label_writeParams->text() == "V") && (ui->label_writeParams->isVisible() == true)) &&
//                 ((ui->label_Calibration->text() == "V") && (ui->label_Calibration->isVisible() == true)) &&
//                 ((ui->label_pulsesOutputHeat->text() == "V") && (ui->label_pulsesOutputHeat->isVisible() == true)) &&
//                 ((ui->label_pulsesInputVolume->text() == "V") && (ui->label_pulsesInputVolume->isVisible() == true)) &&
//                 ((ui->label_pulsesOutputOff->text() == "V") && (ui->label_pulsesOutputOff->isVisible() == true)) &&
//                 ((ui->label_CheckMbus->text() == "V") && (ui->label_CheckMbus->isVisible() == true)) &&
//                 ((ui->label_calibrationModeOff->text() == "V") && (ui->label_calibrationModeOff->isVisible() == true)) &&
//                 ((ui->label_digitalWireInterfaceChecking->text() == "V") && (ui->label_digitalWireInterfaceChecking->isVisible() == true)) &&
//                 ((ui->label_RMV_ErrorFlags_tick->text() == "V") && (ui->label_RMV_ErrorFlags_tick->isVisible() == true))     )   {


//                  usableResult = "Годен";
//  //                  on_toolButton_result_clicked();

//              }
//              else {
//                  usableResult = "Не годен";
//  //                  on_toolButton_result_clicked();
//              }





              break;
           }
           else {
               if (i==2) {
               QMessageBox::information(this, "", tr("Ошибка проверки проводных интерфейсов"));
               ui->label_StatusBar->setText("Проверка проводных интерфейсов : Неудачно");
               ui->label_digitalWireInterfaceChecking->setVisible(true);

               usableResult = "Не годен";
//               on_toolButton_result_clicked();

               return;
               }
           }



       }


    }
}
/*****************************************************************/
void MainWindow::on_comboBox_RTD_Type_2_currentIndexChanged(const QString &arg1)
{
    RTD_TypeInt = arg1.toInt();
}

void MainWindow::on_toolButton_selectConfigFile_clicked()
{
    QMessageBox box;
    QFileDialog fileDialog;
    fileDialog.setFileMode(QFileDialog::Directory);
    QString fileName = fileDialog.getOpenFileName(this, tr("Open File"),
                                                  QDir::currentPath() + "/cfg",
                                                  tr("Текст (*.cfg)"));
    qDebug()<<"fileName"<<fileName;
    ui->lineEdit_selectConfigFile->setText(fileName);

    QFile loadTemplate(fileName);
    if(fileName.isEmpty()) {
        return;
    }
    if(!loadTemplate.open(QIODevice::ReadOnly | QIODevice::Text)) {
        box.setText("Не удалось открыть файл");
        box.exec();
        qDebug()<<"не удалось открыть файл";
 //       ui->toolButton_startCalibration->setEnabled(false);
        return;
    }
    //прочитываем файл в строку далее в лист
    QString fileToString = loadTemplate.readAll();
    qDebug()<<"fileToString"<<fileToString;
    QStringList fileToStringList;
    QString sym = "";
    for(int i=0; i<fileToString.size(); i++) {
        sym = sym + fileToString[i];
        if(fileToString[i+1] == "\n") {
 //           sym = sym + "\n";
            fileToStringList<<sym;
            sym = "";
 //           i=i+1;
        }
    }
    qDebug()<<"fileToStringList"<<fileToStringList;

    if( !fileToStringList[0].contains("R_Real1 ") || !fileToStringList[1].contains("R_Real2 ") ||
            !fileToStringList[2].contains("Temperature1_type0 ") || !fileToStringList[3].contains("Temperature2_type0 ") ||
            !fileToStringList[4].contains("Temperature1_type1 ") || !fileToStringList[5].contains("Temperature2_type1 ") ||
            !fileToStringList[6].contains("Temperature1_type2 ") || !fileToStringList[7].contains("Temperature2_type2 ") ||
            !fileToStringList[8].contains("Temperature1_type3 ") || !fileToStringList[9].contains("Temperature2_type3 ") ||
            !fileToStringList[10].contains("Acceptable_R_Ref1 ") || !fileToStringList[11].contains("Acceptable_R_Ref2 ") ||
            !fileToStringList[12].contains("Acceptable_TMeasDir ") || !fileToStringList[13].contains("Acceptable_TMeasRev ") ||
            !fileToStringList[14].contains("Error_R_Reff1 ") || !fileToStringList[15].contains("Error_R_Reff2 ") ||
            !fileToStringList[16].contains("Error_TMeasDir ") || !fileToStringList[17].contains("Error_TMeasRev ") ) {

        QMessageBox::information(this, "", "Неверный формат файла");
 //       ui->toolButton_startCalibration->setEnabled(false);
        return;

    }


    QString R_Real1String = fileToStringList[0];
    R_Real1String.remove("R_Real1 ");

    R_Real1ByteArray = on_lineEdit_R_Real1_2_textChanged(R_Real1String);
    calibrationMap["R_Real1ByteArray"] = R_Real1ByteArray;
    calibrationFloatMap["R_Real1Float"] = R_Real1String.toFloat();

 //   ui->lineEdit_R_Real1_2->setText(R_Real1String);
    QString R_Real2String = fileToStringList[1];
    R_Real2String.remove("R_Real2 ");

    R_Real2ByteArray = on_lineEdit_R_Real1_2_textChanged(R_Real2String);
    calibrationMap["R_Real2ByteArray"] = R_Real2ByteArray;
    calibrationFloatMap["R_Real2Float"] = R_Real2String.toFloat();

 //   ui->lineEdit_R_Real2_2->setText(R_Real2String);

    if(RTD_TypeInt == 0) {
        QString temperature1String = fileToStringList[2];
        temperature1String.remove("Temperature1_type0 ");

        //
//        ui->lineEdit_Temperature1_2->setText(temperature1String);

        temperature1ByteArray = on_lineEdit_Temperature1_2_textChanged(temperature1String);
        temperature1Float = temperature1String.toFloat();
        calibrationMap["temperature1ByteArray"] = temperature1ByteArray;
        calibrationFloatMap["temperature1Float"] = temperature1Float;
        //

        QString temperature2String = fileToStringList[3];
        temperature2String.remove("Temperature2_type0 ");

        //
 //       ui->lineEdit_Temperature2_2->setText(temperature2String);

        temperature2ByteArray = on_lineEdit_Temperature1_2_textChanged(temperature2String);
        temperature2Float = temperature2String.toFloat();
        calibrationMap["temperature2ByteArray"] = temperature2ByteArray;
        calibrationFloatMap["temperature2Float"] = temperature2Float;
        //

    }
    if(RTD_TypeInt == 1) {
        QString temperature1String = fileToStringList[4];
        temperature1String.remove("Temperature1_type1 ");
        //
//        ui->lineEdit_Temperature1_2->setText(temperature1String);

        temperature1ByteArray = on_lineEdit_Temperature1_2_textChanged(temperature1String);
        temperature1Float = temperature1String.toFloat();
        calibrationMap["temperature1ByteArray"] = temperature1ByteArray;
        calibrationFloatMap["temperature1Float"] = temperature1Float;
        //

        QString temperature2String = fileToStringList[5];
        temperature2String.remove("Temperature2_type1 ");
        //
//        ui->lineEdit_Temperature2_2->setText(temperature2String);

        temperature2ByteArray = on_lineEdit_Temperature1_2_textChanged(temperature2String);
        temperature2Float = temperature2String.toFloat();
        calibrationMap["temperature2ByteArray"] = temperature2ByteArray;
        calibrationFloatMap["temperature2Float"] = temperature2Float;
        //
    }
    if(RTD_TypeInt == 2) {
        QString temperature1String = fileToStringList[6];
        temperature1String.remove("Temperature1_type2 ");
        //
//        ui->lineEdit_Temperature1_2->setText(temperature1String);

        temperature1ByteArray = on_lineEdit_Temperature1_2_textChanged(temperature1String);
        temperature1Float = temperature1String.toFloat();
        calibrationMap["temperature1ByteArray"] = temperature1ByteArray;
        calibrationFloatMap["temperature1Float"] = temperature1Float;
        //

        QString temperature2String = fileToStringList[7];
        temperature2String.remove("Temperature2_type2 ");
        //
 //       ui->lineEdit_Temperature2_2->setText(temperature2String);

        temperature2ByteArray = on_lineEdit_Temperature1_2_textChanged(temperature2String);
        temperature2Float = temperature2String.toFloat();
        calibrationMap["temperature2ByteArray"] = temperature2ByteArray;
        calibrationFloatMap["temperature2Float"] = temperature2Float;
        //
    }
    if(RTD_TypeInt == 3) {
        QString temperature1String = fileToStringList[8];
        temperature1String.remove("Temperature1_type3 ");
        //
 //       ui->lineEdit_Temperature1_2->setText(temperature1String);

        temperature1ByteArray = on_lineEdit_Temperature1_2_textChanged(temperature1String);
        temperature1Float = temperature1String.toFloat();
        calibrationMap["temperature1ByteArray"] = temperature1ByteArray;
        calibrationFloatMap["temperature1Float"] = temperature1Float;
        //

        QString temperature2String = fileToStringList[9];
        temperature2String.remove("Temperature2_type3 ");
        //
 //       ui->lineEdit_Temperature2_2->setText(temperature2String);

        temperature2ByteArray = on_lineEdit_Temperature1_2_textChanged(temperature2String);
        temperature2Float = temperature2String.toFloat();
        calibrationMap["temperature2ByteArray"] = temperature2ByteArray;
        calibrationFloatMap["temperature2Float"] = temperature2Float;
        //
    }

    QStringList Acceptable_R_Ref1List = fileToStringList[10].split(' ');
    ui->lineEdit_Acceptable_R_Ref1_2->setText(Acceptable_R_Ref1List[1]);
    Acceptable_R_Ref1Float = Acceptable_R_Ref1List[1].toFloat();
    calibrationFloatMap["Acceptable_R_Ref1Float"] = Acceptable_R_Ref1Float;

    QStringList Acceptable_R_Ref2List = fileToStringList[11].split(' ');
    ui->lineEdit_Acceptable_R_Ref2_2->setText(Acceptable_R_Ref2List[1]);
    Acceptable_R_Ref2Float = Acceptable_R_Ref2List[1].toFloat();
    calibrationFloatMap["Acceptable_R_Ref2Float"] = Acceptable_R_Ref2Float;

    QStringList Acceptable_TMeasDirList = fileToStringList[12].split(' ');
    ui->lineEdit_Acceptable_TMeasDir_2->setText(Acceptable_TMeasDirList[1]);
    Acceptable_TMeasDirFloat = Acceptable_TMeasDirList[1].toFloat();
    calibrationFloatMap["Acceptable_TMeasDirFloat"] = Acceptable_TMeasDirFloat;

    QStringList Acceptable_TMeasRevList = fileToStringList[13].split(' ');
    ui->lineEdit_Acceptable_TMeasRev_2->setText(Acceptable_TMeasRevList[1]);
    Acceptable_TMeasRevFloat = Acceptable_TMeasRevList[1].toFloat();
    calibrationFloatMap["Acceptable_TMeasRevFloat"] = Acceptable_TMeasRevFloat;

    QStringList Error_R_Reff1List = fileToStringList[14].split(' ');
    ui->lineEdit_Error_R_Reff1_2->setText(Error_R_Reff1List[1]);
    Error_R_Reff1Float = Error_R_Reff1List[1].toFloat();
    calibrationFloatMap["Error_R_Reff1Float"] = Error_R_Reff1Float;

    QStringList Error_R_Reff2List = fileToStringList[15].split(' ');
    ui->lineEdit_Error_R_Reff2_2->setText(Error_R_Reff2List[1]);
    Error_R_Reff2Float = Error_R_Reff2List[1].toFloat();
    calibrationFloatMap["Error_R_Reff2Float"] = Error_R_Reff2Float;

    QStringList Error_TMeasDirList = fileToStringList[16].split(' ');
    ui->lineEdit_Error_TMeasDir_2->setText(Error_TMeasDirList[1]);
    Error_TMeasDirFloat = Error_TMeasDirList[1].toFloat();
    calibrationFloatMap["Error_TMeasDirFloat"] = Error_TMeasDirFloat;

    QStringList Error_TMeasRevList = fileToStringList[17].split(' ');
    ui->lineEdit_Error_TMeasRev_2->setText(Error_TMeasRevList[1]);
    Error_TMeasRevFloat = Error_TMeasRevList[1].toFloat();
    calibrationFloatMap["Error_TMeasRevFloat"] = Error_TMeasRevFloat;


    loadTemplate.close();

    ObjectThread1->setCalibrationMap(calibrationMap);
    ObjectThread1->setCalibrationFloatMap(calibrationFloatMap);

 //   ui->toolButton_startCalibration->setEnabled(true);
}

void MainWindow::on_toolButton_startCalibration_clicked()
{
    slotStartCalibration(calibrationMap, calibrationFloatMap);
}

void MainWindow::on_lineEdit_periodBetweenPulses_textChanged(const QString &arg1)
{
    bool ok;
    periodBetweenPulses = arg1.toFloat(&ok);

    if(arg1.isEmpty()) {
        ui->toolButton_realClockCalibration->setEnabled(false);
    }

    if(ok == true) {
        ui->toolButton_realClockCalibration->setEnabled(true);
    }
    else {
        ui->toolButton_realClockCalibration->setEnabled(false);
    }
}

void MainWindow::on_toolButton_realClockCalibration_clicked()
{

    //    Значение коэффициента коррекции должно рассчитываться по формуле:
    //    K = |Round(983040 * (1 - 1953,125 / Tи))|,
    //    где Tи – измеренное значение периода в мс.

        float periodError = (1953.125/10000)*3;

        if( !((periodBetweenPulses >= 1953.125 - periodError) && (periodBetweenPulses <= 1953.125 + periodError)) ) {
            QMessageBox::information(this, "" , tr("Недопустимое значение периода следования импульсов "));
            return;
        }

        quint16 correctionCoeff = (quint16)round(abs(983040*(1 - 1953.125/periodBetweenPulses)));
        qDebug()<<"correctionCoeff "<<correctionCoeff;

        if(correctionCoeff > 240) {
            QMessageBox::information(this, "", tr("Недопустимое значение коэффициента коррекции ") + QString::number(correctionCoeff));
            return;
        }

        // установка/сброс старшего бита
        quint16 correctionCoeffResult = correctionCoeff;

        if(periodBetweenPulses>1953.125) {
            quint16 bitField = (1<<15);
            correctionCoeffResult = correctionCoeff | bitField;
            qDebug()<<"correctionCoeffResult case1 "<<correctionCoeffResult;
        }
        if(periodBetweenPulses<=1953.125) {
            quint16 bitField = ~(1<<15);
            correctionCoeffResult = correctionCoeff & bitField;
            qDebug()<<"correctionCoeffResult case2 "<<correctionCoeffResult;

        }




      //расчета коэффициента коррекции и записи его в энергонезависимую память
      //командой WCC, параметр RTC_Offset (значение параметра RTC_Tcomp всегда 0)

        slotStartRealClockCalibation(correctionCoeffResult);
}

QByteArray MainWindow::on_lineEdit_R_Real1_2_textChanged(const QString &arg1)
{
 //   R_Real1ByteArray.clear();
    QByteArray rRealByteArray;
    rRealByteArray.clear();

    bool ok;
    float rrealFloat = arg1.toFloat()*1000;

    quint32 rrealInt = (quint32)rrealFloat;
    rRealByteArray.append((quint8)(rrealInt>>24));
    rRealByteArray.append((quint8)(rrealInt>>16));
    rRealByteArray.append((quint8)(rrealInt>>8));
    rRealByteArray.append((quint8)(rrealInt));

    qDebug()<<"rRealByteArray.toHex() "<<rRealByteArray.toHex();

    quint32 rrealIntObr = (quint8)rRealByteArray[0];
    rrealIntObr = rrealIntObr<<8 | (quint8)rRealByteArray[1];
    rrealIntObr = rrealIntObr<<8 | (quint8)rRealByteArray[2];
    rrealIntObr = rrealIntObr<<8 | (quint8)rRealByteArray[3];

    qDebug()<<"QString::number(rrealIntObr) "<<QString::number(rrealIntObr/1000);

//    calibrationMap["R_Real1ByteArray"] = R_Real1ByteArray;

    return rRealByteArray;
}

QByteArray MainWindow::on_lineEdit_R_Real2_2_textChanged(const QString &arg1)
{
//    R_Real2ByteArray.clear();
//    bool ok;
//    float rreal2Float = arg1.toFloat()*1000;

//    quint32 rreal2Int = (quint32)rreal2Float;
//    R_Real2ByteArray.append((quint8)(rreal2Int>>24));
//    R_Real2ByteArray.append((quint8)(rreal2Int>>16));
//    R_Real2ByteArray.append((quint8)(rreal2Int>>8));
//    R_Real2ByteArray.append((quint8)(rreal2Int));

//    qDebug()<<"R_Real2ByteArray.toHex() "<<R_Real2ByteArray.toHex();

//    calibrationMap["R_Real2ByteArray"] = R_Real2ByteArray;
}

QByteArray MainWindow::on_lineEdit_Temperature1_2_textChanged(const QString &arg1)
{
 //   temperature1Float = arg1.toFloat();

    QByteArray tempByteArray;
    tempByteArray.clear();

    tempByteArray.clear();
    bool ok;
    quint16 temp1Int = arg1.toInt(&ok, 10);
    tempByteArray.append((quint8)temp1Int>>8);
    tempByteArray.append((quint8)temp1Int);

 //   calibrationMap["temperature1ByteArray"] = temperature1ByteArray;

    return tempByteArray;
}

void MainWindow::on_lineEdit_Temperature2_2_textChanged(const QString &arg1)
{
//    temperature2Float = arg1.toFloat();

//    temperature2ByteArray.clear();
//    bool ok;
//    quint16 temp2Int = arg1.toInt(&ok, 10);
//    temperature2ByteArray.append((quint8)temp2Int>>8);
//    temperature2ByteArray.append((quint8)temp2Int);

//    calibrationMap["temperature2ByteArray"] = temperature2ByteArray;
}

void MainWindow::on_comboBox_portListInterfaceChecking_currentIndexChanged(const QString &arg1)
{
    portDigitalInterfaceChecking->close();
    portDigitalInterfaceChecking->setPortName(arg1);
    portNameInterfaceChecking = arg1;

    qDebug()<<"portDigitalInterfaceChecking->portName() "<<portDigitalInterfaceChecking->portName();
}

void MainWindow::on_lineEdit_Error_TMeasRev_2_textChanged(const QString &arg1)
{

}

void MainWindow::on_lineEdit_Acceptable_TMeasDir_2_textChanged(const QString &arg1)
{

}

void MainWindow::on_lineEdit_PulsesValue1_textChanged(const QString &arg1)
{

}

void MainWindow::pulsesOutputHeat(int workPlaceNumber)
{
    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;


    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }

    portTmp->setBaudRate(QSerialPort::Baud19200);
    portTmp->setDataBits(QSerialPort::Data8);
    portTmp->setParity(QSerialPort::NoParity);
    portTmp->setStopBits(QSerialPort::OneStop);


    currentBoxNumber = 2;
    vectorIsErrorOccured[workPlaceNumber] = false;


        QColor color(255, 127, 50);
        ui->label_pulsesOutputHeat->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_pulsesOutputHeat->setText("X");
        ui->label_pulsesOutputHeat->setVisible(false);

        ui->label_StatusBar->setText("");

        pulsesMode1ByteArray.clear();
        pulsesMode2ByteArray.clear();
        quint8 byte = 1;
        pulsesMode1ByteArray.append(byte);
        pulsesMode2ByteArray.append(byte);
        //
        pulsesValue1ByteArray.clear();
        pulsesValue2ByteArray.clear();
        quint16 twoBytes = 100;
        pulsesValue1ByteArray.append((quint8)(twoBytes>>8));
        pulsesValue1ByteArray.append((quint8)(twoBytes));

        pulsesValue2ByteArray.append((quint8)(twoBytes>>8));
        pulsesValue2ByteArray.append((quint8)(twoBytes));
        //
        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
//                QMessageBox::information(this, "", "Не удалось открыть порт УСО-2. Рабочее место: " +
//                                         QString::number(workPlaceNumber + 1));
                ui->label_StatusBar->setText("Не удалось открыть порт УСО-2. Рабочее место: " +
                                             QString::number(workPlaceNumber + 1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkPulsesOutputHeat(currentIndicatorNumber);
                workPlaceOff(currentIndicatorNumber);
                return;
            }
        }

        //одна команда Write Software Configuration с открытием парольной сессии

        //Открыть парольную сессию 5a 00 08 40 01 04 57
        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x08;
           packetToRead.append(byte);
           byte = 0x40;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);
           byte = 0x04;
           packetToRead.append(byte);
           byte = 0x57;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 " Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkPulsesOutputHeat(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
//                   QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                                         " Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkPulsesOutputHeat(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
   //                ui->label_pulsesOutputHeat->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc0;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);


                  //
                  //



                  break;
               }
               else {
                        if(i==9) {
//                            QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                                     " Рабочее место: " + QString::number(workPlaceNumber+1));
                            ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkPulsesOutputHeat(currentIndicatorNumber);
                            workPlaceOff(currentIndicatorNumber);
     //                       ui->label_pulsesOutputHeat->setVisible(true);
                            return;
                        }

               }



           }


        }

        //Открыть парольную сессию 5a 00 08 40 01 04 57 /

        //
        //Write Software Configuration 5a 00 16 20
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x16;
           packetToRead.append(byte);
           byte = 0x20;
           packetToRead.append(byte);

           byte = flowMinByteArray[0];
           packetToRead.append(byte);
           byte = flowMinByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMinByteArray);
           mapwrite["flowMinByteArray"] = flowMinByteArray;


           byte = flowMaxByteArray[0];
           packetToRead.append(byte);
           byte = flowMaxByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMaxByteArray);
           mapwrite["flowMaxByteArray"] = flowMaxByteArray;


           byte = tinMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMinByteArray);
           mapwrite["tinMinByteArray"] = tinMinByteArray;


           byte = tinMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMaxByteArray);
           mapwrite["tinMaxByteArray"] = tinMaxByteArray;


           byte = toutMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMinByteArray);
           mapwrite["toutMinByteArray"] = toutMinByteArray;


           byte = toutMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMaxByteArray);
           mapwrite["toutMaxByteArray"] = toutMaxByteArray;


           byte = reportDataByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(reportDataByteArray);
           mapwrite["reportDataByteArray"] = reportDataByteArray;


           byte = averageTByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(averageTByteArray);
           mapwrite["averageTByteArray"] = averageTByteArray;


           byte = pulsesMode1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode1ByteArray);
           mapwrite["pulsesMode1ByteArray"] = pulsesMode1ByteArray;


           byte = pulsesMode2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode2ByteArray);
           mapwrite["pulsesMode2ByteArray"] = pulsesMode2ByteArray;


           byte = pulsesValue1ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue1ByteArray);
           mapwrite["pulsesValue1ByteArray"] = pulsesValue1ByteArray;


           byte = pulsesValue2ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue2ByteArray);
           mapwrite["pulsesValue2ByteArray"] = pulsesValue2ByteArray;

           byte = devType[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(devType);
           mapwrite["devType"] = devType;

           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                        " Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkPulsesOutputHeat(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Software Configuration") +
//                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Software Configuration") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkPulsesOutputHeat(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
    //               ui->label_pulsesOutputHeat->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa0;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Software Configuration") +
//                                               " Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Software Configuration") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkPulsesOutputHeat(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
    //                  ui->label_pulsesOutputHeat->setVisible(true);
                      return;
                   }
               }



           }


        }


        //
        //Read Software Configuration 5a000502
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x02;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                        " Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkPulsesOutputHeat(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось прочитать данные") +
//                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkPulsesOutputHeat(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
   //                ui->label_pulsesOutputHeat->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x16;
               bytesForChecking.append(byte);
               byte = 0x82;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
    //              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

    //              emit sendbufferReadSoftWareConfiguration(buffer);

                  //
                  //flowMin
                  QByteArray flowMinArray;
                  flowMinArray.append(buffer[4]);
                  flowMinArray.append(buffer[5]);
     //             ui->lineEdit_Flow_min->setText(flowMinArray.toHex());

     //             float flowMinFloat = buffer[4];
                  quint16 flowMinQuint16 = buffer[4];
                  flowMinQuint16 = flowMinQuint16<<8 | buffer[5];
                  float flowMinFloat = (float)flowMinQuint16/1000;
                  if(flowMinFloat>=0 && flowMinFloat<=0.2) {
                      ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальный расход"));
                      ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
                  }

                  qDebug()<<"flowMinArray.toHex() "<<flowMinArray.toHex();
                  paramsVector.append(flowMinArray);
                  mapRead["flowMinByteArray"] = flowMinArray;

                  //
                  //flowMax
                  QByteArray flowMaxArray;
                  flowMaxArray.append(buffer[6]);
                  flowMaxArray.append(buffer[7]);

     //             float flowMaxFloat = buffer[6];
                  quint16 flowMaxQuint16 = buffer[6];
                  flowMaxQuint16 = (flowMaxQuint16<<8) | (quint8)(buffer.at(7));
                  float flowMaxFloat = flowMaxQuint16;
                  flowMaxFloat = flowMaxFloat/1000;
                  if(flowMaxFloat>=2 && flowMaxFloat<=5) {
                      ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальный расход"));
                      ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
                  }

                  qDebug()<<"flowMaxArray.toHex() "<<flowMaxArray.toHex();
                  paramsVector.append(flowMaxArray);
                  mapRead["flowMaxByteArray"] = flowMaxArray;

                  //
                  //tinMin
                  QByteArray tinMinArray;
                  tinMinArray.append(buffer[8]);


                  quint8 tinMinQuint8 = buffer[8];
                  if(tinMinQuint8>=10 && tinMinQuint8<=60) {
                      ui->spinBox_Tin_min->setValue(tinMinQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура подачи"));
                  }

                  qDebug()<<"tinMinArray.toHex() "<<tinMinArray.toHex();
                  paramsVector.append(tinMinArray);
                  mapRead["tinMinByteArray"] = tinMinArray;

                  //
                  //tinMax
                  QByteArray tinMaxArray;
                  tinMaxArray.append(buffer[9]);


                  quint8 tinMaxQuint8 = buffer[9];
                  if(tinMaxQuint8>=50 && tinMaxQuint8<=150) {
                      ui->spinBox_Tin_max->setValue(tinMaxQuint8);
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура подачи"));
                  }

                  qDebug()<<"tinMaxArray.toHex() "<<tinMaxArray.toHex();
                  paramsVector.append(tinMaxArray);
                  mapRead["tinMaxByteArray"] = tinMaxArray;

                  //
                  //toutMin
                  QByteArray toutMinArray;
                  toutMinArray.append(buffer[10]);

                  quint8 toutMinQuint8 = buffer[10];
                  if(toutMinQuint8>=10 && toutMinQuint8<=60) {
                      ui->spinBox_Tout_min->setValue(toutMinQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура обратки"));
                  }

                  qDebug()<<"toutMinArray.toHex() "<<toutMinArray.toHex();
                  paramsVector.append(toutMinArray);
                  mapRead["toutMinByteArray"] = toutMinArray;


                  //
                  //toutMax
                  QByteArray toutMaxArray;
                  toutMaxArray.append(buffer[11]);

                  quint8 toutMaxQuint8 = buffer[11];
                  if(toutMaxQuint8>=50 && toutMaxQuint8<=150) {
                      ui->spinBox_Tout_max->setValue(toutMaxQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура обратки"));
                  }

                  qDebug()<<"toutMaxArray.toHex() "<<toutMaxArray.toHex();
                  paramsVector.append(toutMaxArray);
                  mapRead["toutMaxByteArray"] = toutMaxArray;

                  //
                  //reportData
                  QByteArray reportDataArray;
                  reportDataArray.append(buffer[12]);

                  quint8 reportDataInt = buffer[12];
                  if(reportDataInt>=0 && reportDataInt<=31) {
                      ui->spinBox_ReportData->setValue(reportDataInt);
                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: Дата сохранения в журнал"));
                  }

                  qDebug()<<"reportDataArray.toHex() "<<reportDataArray.toHex();
                  paramsVector.append(reportDataArray);
                  mapRead["reportDataByteArray"] = reportDataArray;

                  //
                  //AverageT
                  QByteArray AverageTArray;
                  AverageTArray.append(buffer[13]);


                  quint8 AverageTInt = buffer[13];
                  if(AverageTList.contains(QString::number(AverageTInt))) {
                      ui->comboBox_Average_T->setCurrentText(QString::number(AverageTInt));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Тип усреднения температуры"));
                  }

                  qDebug()<<"AverageTArray.toHex() "<<AverageTArray.toHex();
                  paramsVector.append(AverageTArray);
                  mapRead["averageTByteArray"] = AverageTArray;

                  //
                  //pulsesMode1
                  QByteArray pulsesMode1Array;
                  pulsesMode1Array.append(buffer[14]);


                  quint8 pulsesMode1Int = (quint8)buffer[14];
                  if(pulsesMode1List.contains(QString::number(pulsesMode1Int))) {
                      ui->comboBox_PulsesMode1->setCurrentText(QString::number(pulsesMode1Int));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
                  }

                  qDebug()<<"pulsesMode1Array.toHex() "<<pulsesMode1Array.toHex();
                  paramsVector.append(pulsesMode1Array);
                  mapRead["pulsesMode1ByteArray"] = pulsesMode1Array;

                  //
                  //pulsesMode2
                  QByteArray pulsesMode2Array;
                  pulsesMode2Array.append(buffer[15]);


                  quint8 pulsesMode2Int = (quint8)buffer[15];
                  if(pulsesMode1List.contains(QString::number(pulsesMode2Int))) {
                      ui->comboBox_PulsesMode2->setCurrentText(QString::number(pulsesMode2Int));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
                  }

                  qDebug()<<"pulsesMode2Array.toHex() "<<pulsesMode2Array.toHex();
                  paramsVector.append(pulsesMode2Array);
                  mapRead["pulsesMode2ByteArray"] = pulsesMode2Array;

                  //
                  //pulsesValue1
                  QByteArray pulsesValue1Array;
                  pulsesValue1Array.append(buffer[16]);
                  pulsesValue1Array.append(buffer[17]);


                  quint16 pulsesValue1Int = buffer[16];
                  pulsesValue1Int = pulsesValue1Int<<8 | (quint8)buffer[17];
    //              if((pulsesValue1Int<=101) && (pulsesValue1Int>=99)) {

    //              }
                  ui->lineEdit_PulsesValue1->setText(QString::number(pulsesValue1Int));

                  qDebug()<<"pulsesValue1Array.toHex() "<<pulsesValue1Array.toHex();
                  paramsVector.append(pulsesValue1Array);
                  mapRead["pulsesValue1ByteArray"] = pulsesValue1Array;

                  //
                  //pulsesValue2
                  QByteArray pulsesValue2Array;
                  pulsesValue2Array.append(buffer[18]);
                  pulsesValue2Array.append(buffer[19]);
                  qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();

                  quint16 pulsesValue2Int = buffer[18];
                  pulsesValue2Int = pulsesValue2Int<<8 | (quint8)buffer[19];
                  ui->lineEdit_PulsesValue2->setText(QString::number(pulsesValue2Int));

                  qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();
                  paramsVector.append(pulsesValue2Array);
                  mapRead["pulsesValue2ByteArray"] = pulsesValue2Array;

                  //
                  //DevType
                  QByteArray devType;
                  devType.append(buffer[20]);

                  if(devType[0] == 0x04) {
                      ui->comboBox_DevType->setCurrentText("Обратный");
                  }

                  if(devType[0] == 0x0c) {
                      ui->comboBox_DevType->setCurrentText("Подающий");
                  }

                  if((devType[0] != 0x04) && (devType[0] != 0x0c) ) {
                      QMessageBox::information(this, "", tr("Недопустимое значение: Тип счётчика"));
                  }

                  qDebug()<<"devType.toHex() "<<devType.toHex();
                  paramsVector.append(devType);
                  mapRead["devType"] = devType;


                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка данных") +
//                                               " Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkPulsesOutputHeat(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
   //                   ui->label_pulsesOutputHeat->setVisible(true);
                      return;
                   }
               }

           }


        }



        QVector<QByteArray> writeVector;
        writeVector.append(mapwrite["flowMinByteArray"]);
        writeVector.append(mapwrite["flowMaxByteArray"]);
        writeVector.append(mapwrite["tinMinByteArray"]);
        writeVector.append(mapwrite["tinMaxByteArray"]);
        writeVector.append(mapwrite["toutMinByteArray"]);
        writeVector.append(mapwrite["toutMaxByteArray"]);
        writeVector.append(mapwrite["reportDataByteArray"]);
        writeVector.append(mapwrite["averageTByteArray"]);
        writeVector.append(mapwrite["pulsesMode1ByteArray"]);
        writeVector.append(mapwrite["pulsesMode2ByteArray"]);
        writeVector.append(mapwrite["pulsesValue1ByteArray"]);
        writeVector.append(mapwrite["pulsesValue2ByteArray"]);

        QVector<QByteArray> readVector;
        readVector.append(mapRead["flowMinByteArray"]);
        readVector.append(mapRead["flowMaxByteArray"]);
        readVector.append(mapRead["tinMinByteArray"]);
        readVector.append(mapRead["tinMaxByteArray"]);
        readVector.append(mapRead["toutMinByteArray"]);
        readVector.append(mapRead["toutMaxByteArray"]);
        readVector.append(mapRead["reportDataByteArray"]);
        readVector.append(mapRead["averageTByteArray"]);
        readVector.append(mapRead["pulsesMode1ByteArray"]);
        readVector.append(mapRead["pulsesMode2ByteArray"]);
        readVector.append(mapRead["pulsesValue1ByteArray"]);
        readVector.append(mapRead["pulsesValue2ByteArray"]);

        for(int i=0; i<allParamsNameList.size(); i++) {
            qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
            qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();
        }

        for(int i=0; i<writeVector.size(); i++) {


            if((i == (writeVector.size() - 2)) || (i == (writeVector.size() - 1))) {
                int paramRead = (quint8)(readVector[i][0]);
                paramRead = paramRead<<8 | (quint8)(readVector[i][1]);

                int paramWrite = (quint8)(writeVector[i][0]);
                paramWrite = paramWrite<<8 | (quint8)(writeVector[i][1]);

                if((paramRead >= (paramWrite - 1)) && (paramRead <= (paramWrite + 1))) {

                }
                else {
//                    QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
//                                             " " + "чтение " + readVector[i].toHex());
                    ui->label_StatusBar->setText("Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                                 " " + "чтение " + readVector[i].toHex() +
                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
                    errorString.append(ui->label_StatusBar->text() + '\n');
                    vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                    checkPulsesOutputHeat(currentIndicatorNumber);
                    workPlaceOff(currentIndicatorNumber);
   //                 ui->label_pulsesOutputHeat->setVisible(true);
                    return;
                }
            }
            else {
                    if((readVector[i] != writeVector[i]) && (i != (writeVector.size() - 2)) && (i != (writeVector.size() - 1)) ) {
//                       QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
//                                             " " + "чтение " + readVector[i].toHex());
                       ui->label_StatusBar->setText("Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                                    " " + "чтение " + readVector[i].toHex() +
                                                    ". Рабочее место: " + QString::number(workPlaceNumber+1));
                       errorString.append(ui->label_StatusBar->text() + '\n');
                       vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                       checkPulsesOutputHeat(currentIndicatorNumber);
                       workPlaceOff(currentIndicatorNumber);
     //                  ui->label_pulsesOutputHeat->setVisible(true);
                       return;
                    }
            }
        }


        ui->label_pulsesOutputHeat->setStyleSheet(QString("color: green").arg(color.name()));
        ui->label_pulsesOutputHeat->setText("V");
  //      ui->label_pulsesOutputHeat->setVisible(true);


        checkPulsesOutputHeat(currentIndicatorNumber);


}

void MainWindow::on_toolButton_pulsesOutputHeat_clicked()
{
    QColor color(255, 127, 50);
    ui->label_pulsesOutputHeat->setStyleSheet(QString("color: red").arg(color.name()));
    ui->label_pulsesOutputHeat->setText("X");
    ui->label_pulsesOutputHeat->setVisible(false);

    ui->label_StatusBar->setText("");

    pulsesMode1ByteArray.clear();
    pulsesMode2ByteArray.clear();
    quint8 byte = 1;
    pulsesMode1ByteArray.append(byte);
    pulsesMode2ByteArray.append(byte);
    //
    pulsesValue1ByteArray.clear();
    pulsesValue2ByteArray.clear();
    quint16 twoBytes = 100;
    pulsesValue1ByteArray.append((quint8)(twoBytes>>8));
    pulsesValue1ByteArray.append((quint8)(twoBytes));

    pulsesValue2ByteArray.append((quint8)(twoBytes>>8));
    pulsesValue2ByteArray.append((quint8)(twoBytes));
    //
    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
            return;
        }
    }

    //одна команда Write Software Configuration с открытием парольной сессии

    //Открыть парольную сессию 5a 00 08 40 01 04 57
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x08;
       packetToRead.append(byte);
       byte = 0x40;
       packetToRead.append(byte);
       byte = 0x01;
       packetToRead.append(byte);
       byte = 0x04;
       packetToRead.append(byte);
       byte = 0x57;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
               ui->label_pulsesOutputHeat->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xc0;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);


              //
              //



              break;
           }
           else {
                    if(i==2) {
                        QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
                        ui->label_pulsesOutputHeat->setVisible(true);
                        return;
                    }

           }



       }


    }

    //
    //Write Software Configuration 5a 00 16 20
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x16;
       packetToRead.append(byte);
       byte = 0x20;
       packetToRead.append(byte);

       byte = flowMinByteArray[0];
       packetToRead.append(byte);
       byte = flowMinByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowMinByteArray);
       mapwrite["flowMinByteArray"] = flowMinByteArray;


       byte = flowMaxByteArray[0];
       packetToRead.append(byte);
       byte = flowMaxByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowMaxByteArray);
       mapwrite["flowMaxByteArray"] = flowMaxByteArray;


       byte = tinMinByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(tinMinByteArray);
       mapwrite["tinMinByteArray"] = tinMinByteArray;


       byte = tinMaxByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(tinMaxByteArray);
       mapwrite["tinMaxByteArray"] = tinMaxByteArray;


       byte = toutMinByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(toutMinByteArray);
       mapwrite["toutMinByteArray"] = toutMinByteArray;


       byte = toutMaxByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(toutMaxByteArray);
       mapwrite["toutMaxByteArray"] = toutMaxByteArray;


       byte = reportDataByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(reportDataByteArray);
       mapwrite["reportDataByteArray"] = reportDataByteArray;


       byte = averageTByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(averageTByteArray);
       mapwrite["averageTByteArray"] = averageTByteArray;


       byte = pulsesMode1ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesMode1ByteArray);
       mapwrite["pulsesMode1ByteArray"] = pulsesMode1ByteArray;


       byte = pulsesMode2ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesMode2ByteArray);
       mapwrite["pulsesMode2ByteArray"] = pulsesMode2ByteArray;


       byte = pulsesValue1ByteArray[0];
       packetToRead.append(byte);
       byte = pulsesValue1ByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesValue1ByteArray);
       mapwrite["pulsesValue1ByteArray"] = pulsesValue1ByteArray;


       byte = pulsesValue2ByteArray[0];
       packetToRead.append(byte);
       byte = pulsesValue2ByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesValue2ByteArray);
       mapwrite["pulsesValue2ByteArray"] = pulsesValue2ByteArray;

       byte = devType[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(devType);
       mapwrite["devType"] = devType;

       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : Software Configuration"));
               ui->label_pulsesOutputHeat->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xa0;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных : Software Configuration"));
                  ui->label_pulsesOutputHeat->setVisible(true);
                  return;
               }
           }



       }


    }


    //
    //Read Software Configuration 5a000502
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x02;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               ui->label_pulsesOutputHeat->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x16;
           bytesForChecking.append(byte);
           byte = 0x82;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
//              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

              emit sendbufferReadSoftWareConfiguration(buffer);

              //
              //flowMin
              QByteArray flowMinArray;
              flowMinArray.append(buffer[4]);
              flowMinArray.append(buffer[5]);
 //             ui->lineEdit_Flow_min->setText(flowMinArray.toHex());

 //             float flowMinFloat = buffer[4];
              quint16 flowMinQuint16 = buffer[4];
              flowMinQuint16 = flowMinQuint16<<8 | buffer[5];
              float flowMinFloat = (float)flowMinQuint16/1000;
              if(flowMinFloat>=0 && flowMinFloat<=0.2) {
                  ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальный расход"));
                  ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
              }

              qDebug()<<"flowMinArray.toHex() "<<flowMinArray.toHex();
              paramsVector.append(flowMinArray);
              mapRead["flowMinByteArray"] = flowMinArray;

              //
              //flowMax
              QByteArray flowMaxArray;
              flowMaxArray.append(buffer[6]);
              flowMaxArray.append(buffer[7]);

 //             float flowMaxFloat = buffer[6];
              quint16 flowMaxQuint16 = buffer[6];
              flowMaxQuint16 = (flowMaxQuint16<<8) | (quint8)(buffer.at(7));
              float flowMaxFloat = flowMaxQuint16;
              flowMaxFloat = flowMaxFloat/1000;
              if(flowMaxFloat>=2 && flowMaxFloat<=5) {
                  ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальный расход"));
                  ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
              }

              qDebug()<<"flowMaxArray.toHex() "<<flowMaxArray.toHex();
              paramsVector.append(flowMaxArray);
              mapRead["flowMaxByteArray"] = flowMaxArray;

              //
              //tinMin
              QByteArray tinMinArray;
              tinMinArray.append(buffer[8]);


              quint8 tinMinQuint8 = buffer[8];
              if(tinMinQuint8>=10 && tinMinQuint8<=60) {
                  ui->spinBox_Tin_min->setValue(tinMinQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура подачи"));
              }

              qDebug()<<"tinMinArray.toHex() "<<tinMinArray.toHex();
              paramsVector.append(tinMinArray);
              mapRead["tinMinByteArray"] = tinMinArray;

              //
              //tinMax
              QByteArray tinMaxArray;
              tinMaxArray.append(buffer[9]);


              quint8 tinMaxQuint8 = buffer[9];
              if(tinMaxQuint8>=50 && tinMaxQuint8<=150) {
                  ui->spinBox_Tin_max->setValue(tinMaxQuint8);
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура подачи"));
              }

              qDebug()<<"tinMaxArray.toHex() "<<tinMaxArray.toHex();
              paramsVector.append(tinMaxArray);
              mapRead["tinMaxByteArray"] = tinMaxArray;

              //
              //toutMin
              QByteArray toutMinArray;
              toutMinArray.append(buffer[10]);

              quint8 toutMinQuint8 = buffer[10];
              if(toutMinQuint8>=10 && toutMinQuint8<=60) {
                  ui->spinBox_Tout_min->setValue(toutMinQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура обратки"));
              }

              qDebug()<<"toutMinArray.toHex() "<<toutMinArray.toHex();
              paramsVector.append(toutMinArray);
              mapRead["toutMinByteArray"] = toutMinArray;


              //
              //toutMax
              QByteArray toutMaxArray;
              toutMaxArray.append(buffer[11]);

              quint8 toutMaxQuint8 = buffer[11];
              if(toutMaxQuint8>=50 && toutMaxQuint8<=150) {
                  ui->spinBox_Tout_max->setValue(toutMaxQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура обратки"));
              }

              qDebug()<<"toutMaxArray.toHex() "<<toutMaxArray.toHex();
              paramsVector.append(toutMaxArray);
              mapRead["toutMaxByteArray"] = toutMaxArray;

              //
              //reportData
              QByteArray reportDataArray;
              reportDataArray.append(buffer[12]);

              quint8 reportDataInt = buffer[12];
              if(reportDataInt>=0 && reportDataInt<=31) {
                  ui->spinBox_ReportData->setValue(reportDataInt);
              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: Дата сохранения в журнал"));
              }

              qDebug()<<"reportDataArray.toHex() "<<reportDataArray.toHex();
              paramsVector.append(reportDataArray);
              mapRead["reportDataByteArray"] = reportDataArray;

              //
              //AverageT
              QByteArray AverageTArray;
              AverageTArray.append(buffer[13]);


              quint8 AverageTInt = buffer[13];
              if(AverageTList.contains(QString::number(AverageTInt))) {
                  ui->comboBox_Average_T->setCurrentText(QString::number(AverageTInt));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Тип усреднения температуры"));
              }

              qDebug()<<"AverageTArray.toHex() "<<AverageTArray.toHex();
              paramsVector.append(AverageTArray);
              mapRead["averageTByteArray"] = AverageTArray;

              //
              //pulsesMode1
              QByteArray pulsesMode1Array;
              pulsesMode1Array.append(buffer[14]);


              quint8 pulsesMode1Int = (quint8)buffer[14];
              if(pulsesMode1List.contains(QString::number(pulsesMode1Int))) {
                  ui->comboBox_PulsesMode1->setCurrentText(QString::number(pulsesMode1Int));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
              }

              qDebug()<<"pulsesMode1Array.toHex() "<<pulsesMode1Array.toHex();
              paramsVector.append(pulsesMode1Array);
              mapRead["pulsesMode1ByteArray"] = pulsesMode1Array;

              //
              //pulsesMode2
              QByteArray pulsesMode2Array;
              pulsesMode2Array.append(buffer[15]);


              quint8 pulsesMode2Int = (quint8)buffer[15];
              if(pulsesMode1List.contains(QString::number(pulsesMode2Int))) {
                  ui->comboBox_PulsesMode2->setCurrentText(QString::number(pulsesMode2Int));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
              }

              qDebug()<<"pulsesMode2Array.toHex() "<<pulsesMode2Array.toHex();
              paramsVector.append(pulsesMode2Array);
              mapRead["pulsesMode2ByteArray"] = pulsesMode2Array;

              //
              //pulsesValue1
              QByteArray pulsesValue1Array;
              pulsesValue1Array.append(buffer[16]);
              pulsesValue1Array.append(buffer[17]);


              quint16 pulsesValue1Int = buffer[16];
              pulsesValue1Int = pulsesValue1Int<<8 | (quint8)buffer[17];
//              if((pulsesValue1Int<=101) && (pulsesValue1Int>=99)) {

//              }
              ui->lineEdit_PulsesValue1->setText(QString::number(pulsesValue1Int));

              qDebug()<<"pulsesValue1Array.toHex() "<<pulsesValue1Array.toHex();
              paramsVector.append(pulsesValue1Array);
              mapRead["pulsesValue1ByteArray"] = pulsesValue1Array;

              //
              //pulsesValue2
              QByteArray pulsesValue2Array;
              pulsesValue2Array.append(buffer[18]);
              pulsesValue2Array.append(buffer[19]);
              qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();

              quint16 pulsesValue2Int = buffer[18];
              pulsesValue2Int = pulsesValue2Int<<8 | (quint8)buffer[19];
              ui->lineEdit_PulsesValue2->setText(QString::number(pulsesValue2Int));

              qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();
              paramsVector.append(pulsesValue2Array);
              mapRead["pulsesValue2ByteArray"] = pulsesValue2Array;

              //
              //DevType
              QByteArray devType;
              devType.append(buffer[20]);

              if(devType[0] == 0x04) {
                  ui->comboBox_DevType->setCurrentText("Обратный");
              }

              if(devType[0] == 0x0c) {
                  ui->comboBox_DevType->setCurrentText("Подающий");
              }

              if((devType[0] != 0x04) && (devType[0] != 0x0c) ) {
                  QMessageBox::information(this, "", tr("Недопустимое значение: Тип счётчика"));
              }

              qDebug()<<"devType.toHex() "<<devType.toHex();
              paramsVector.append(devType);
              mapRead["devType"] = devType;


              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  ui->label_pulsesOutputHeat->setVisible(true);
                  return;
               }
           }

       }


    }



    QVector<QByteArray> writeVector;
    writeVector.append(mapwrite["flowMinByteArray"]);
    writeVector.append(mapwrite["flowMaxByteArray"]);
    writeVector.append(mapwrite["tinMinByteArray"]);
    writeVector.append(mapwrite["tinMaxByteArray"]);
    writeVector.append(mapwrite["toutMinByteArray"]);
    writeVector.append(mapwrite["toutMaxByteArray"]);
    writeVector.append(mapwrite["reportDataByteArray"]);
    writeVector.append(mapwrite["averageTByteArray"]);
    writeVector.append(mapwrite["pulsesMode1ByteArray"]);
    writeVector.append(mapwrite["pulsesMode2ByteArray"]);
    writeVector.append(mapwrite["pulsesValue1ByteArray"]);
    writeVector.append(mapwrite["pulsesValue2ByteArray"]);

    QVector<QByteArray> readVector;
    readVector.append(mapRead["flowMinByteArray"]);
    readVector.append(mapRead["flowMaxByteArray"]);
    readVector.append(mapRead["tinMinByteArray"]);
    readVector.append(mapRead["tinMaxByteArray"]);
    readVector.append(mapRead["toutMinByteArray"]);
    readVector.append(mapRead["toutMaxByteArray"]);
    readVector.append(mapRead["reportDataByteArray"]);
    readVector.append(mapRead["averageTByteArray"]);
    readVector.append(mapRead["pulsesMode1ByteArray"]);
    readVector.append(mapRead["pulsesMode2ByteArray"]);
    readVector.append(mapRead["pulsesValue1ByteArray"]);
    readVector.append(mapRead["pulsesValue2ByteArray"]);

    for(int i=0; i<allParamsNameList.size(); i++) {
        qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
        qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();
    }

    for(int i=0; i<writeVector.size(); i++) {


        if((i == (writeVector.size() - 2)) || (i == (writeVector.size() - 1))) {
            int paramRead = (quint8)(readVector[i][0]);
            paramRead = paramRead<<8 | (quint8)(readVector[i][1]);

            int paramWrite = (quint8)(writeVector[i][0]);
            paramWrite = paramWrite<<8 | (quint8)(writeVector[i][1]);

            if((paramRead >= (paramWrite - 1)) && (paramRead <= (paramWrite + 1))) {

            }
            else {
                QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                         " " + "чтение " + readVector[i].toHex());
                ui->label_pulsesOutputHeat->setVisible(true);
                return;
            }
        }
        else {
                if((readVector[i] != writeVector[i]) && (i != (writeVector.size() - 2)) && (i != (writeVector.size() - 1)) ) {
                   QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                         " " + "чтение " + readVector[i].toHex());
                   ui->label_pulsesOutputHeat->setVisible(true);
                   return;
                }
        }
    }


    ui->label_pulsesOutputHeat->setStyleSheet(QString("color: green").arg(color.name()));
    ui->label_pulsesOutputHeat->setText("V");
    ui->label_pulsesOutputHeat->setVisible(true);



//    on_toolButton_writeParams_clicked();
}

void MainWindow::pulsesInputVolume(int workPlaceNumber)
{

    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }

    portTmp->setBaudRate(QSerialPort::Baud19200);
    portTmp->setDataBits(QSerialPort::Data8);
    portTmp->setParity(QSerialPort::NoParity);
    portTmp->setStopBits(QSerialPort::OneStop);


    currentBoxNumber = 3;
    vectorIsErrorOccured[workPlaceNumber] = false;

        ui->label_StatusBar->setText("");

        QColor color(255, 127, 50);
        ui->label_pulsesInputVolume->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_pulsesInputVolume->setText("X");
        ui->label_pulsesInputVolume->setVisible(false);

        pulsesMode1ByteArray.clear();
        pulsesMode2ByteArray.clear();
        quint8 byte = 2;
        pulsesMode1ByteArray.append(byte);
        pulsesMode2ByteArray.append(byte);
        //
        pulsesValue1ByteArray.clear();
        pulsesValue2ByteArray.clear();
        quint16 twoBytes = 100;
        pulsesValue1ByteArray.append((quint8)(twoBytes>>8));
        pulsesValue1ByteArray.append((quint8)(twoBytes));

        pulsesValue2ByteArray.append((quint8)(twoBytes>>8));
        pulsesValue2ByteArray.append((quint8)(twoBytes));

        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
//                QMessageBox::information(this, "", "Не удалось открыть порт УСО-2. Рабочее место: " +
//                                         QString::number(workPlaceNumber + 1) );
                ui->label_StatusBar->setText("Не удалось открыть порт УСО-2. Рабочее место: " +
                                             QString::number(workPlaceNumber + 1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkPulsesInputVolume(currentIndicatorNumber);
                workPlaceOff(currentIndicatorNumber);
                return;
            }
        }

        //одна команда Write Software Configuration с открытием парольной сессии

        //Открыть парольную сессию 5a 00 08 40 01 04 57
        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x08;
           packetToRead.append(byte);
           byte = 0x40;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);
           byte = 0x04;
           packetToRead.append(byte);
           byte = 0x57;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                        " Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkPulsesInputVolume(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
//                   QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                " Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkPulsesInputVolume(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
 //                  ui->label_pulsesInputVolume->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc0;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);


                  //
                  //



                  break;
               }
               else {
                        if(i==9) {
//                            QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") +
//                                                     " Рабочее место: " + QString::number(workPlaceNumber+1));
                            ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") +
                                                         " Рабочее место: " + QString::number(workPlaceNumber+1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkPulsesInputVolume(currentIndicatorNumber);
                            workPlaceOff(currentIndicatorNumber);
  //                          ui->label_pulsesInputVolume->setVisible(true);
                            return;
                        }

               }



           }


        }

        //
        //Write Software Configuration 5a 00 16 20
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x16;
           packetToRead.append(byte);
           byte = 0x20;
           packetToRead.append(byte);

           byte = flowMinByteArray[0];
           packetToRead.append(byte);
           byte = flowMinByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMinByteArray);
           mapwrite["flowMinByteArray"] = flowMinByteArray;


           byte = flowMaxByteArray[0];
           packetToRead.append(byte);
           byte = flowMaxByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMaxByteArray);
           mapwrite["flowMaxByteArray"] = flowMaxByteArray;


           byte = tinMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMinByteArray);
           mapwrite["tinMinByteArray"] = tinMinByteArray;


           byte = tinMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMaxByteArray);
           mapwrite["tinMaxByteArray"] = tinMaxByteArray;


           byte = toutMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMinByteArray);
           mapwrite["toutMinByteArray"] = toutMinByteArray;


           byte = toutMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMaxByteArray);
           mapwrite["toutMaxByteArray"] = toutMaxByteArray;


           byte = reportDataByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(reportDataByteArray);
           mapwrite["reportDataByteArray"] = reportDataByteArray;


           byte = averageTByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(averageTByteArray);
           mapwrite["averageTByteArray"] = averageTByteArray;


           byte = pulsesMode1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode1ByteArray);
           mapwrite["pulsesMode1ByteArray"] = pulsesMode1ByteArray;


           byte = pulsesMode2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode2ByteArray);
           mapwrite["pulsesMode2ByteArray"] = pulsesMode2ByteArray;


           byte = pulsesValue1ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue1ByteArray);
           mapwrite["pulsesValue1ByteArray"] = pulsesValue1ByteArray;


           byte = pulsesValue2ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue2ByteArray);
           mapwrite["pulsesValue2ByteArray"] = pulsesValue2ByteArray;

           byte = devType[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(devType);
           mapwrite["devType"] = devType;

           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                        " Рабочее место: " + QString::number(workPlaceNumber+1));
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkPulsesInputVolume(currentIndicatorNumber);
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Software Configuration") +
//                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Software Configuration") +
                                                " Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkPulsesInputVolume(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
 //                  ui->label_pulsesInputVolume->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa0;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Software Configuration") +
//                                               " Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Software Configuration") +
                                                   " Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkPulsesInputVolume(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
     //                 ui->label_pulsesInputVolume->setVisible(true);
                      return;
                   }
               }



           }


        }


        //
        //Read Software Configuration 5a000502
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x02;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                        " Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkPulsesInputVolume(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось прочитать данные") +
//                                            " Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") +
                                                " Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkPulsesInputVolume(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
  //                 ui->label_pulsesInputVolume->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x16;
               bytesForChecking.append(byte);
               byte = 0x82;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
    //              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

    //              emit sendbufferReadSoftWareConfiguration(buffer);

                  //
                  //flowMin
                  QByteArray flowMinArray;
                  flowMinArray.append(buffer[4]);
                  flowMinArray.append(buffer[5]);
     //             ui->lineEdit_Flow_min->setText(flowMinArray.toHex());

     //             float flowMinFloat = buffer[4];
                  quint16 flowMinQuint16 = buffer[4];
                  flowMinQuint16 = flowMinQuint16<<8 | buffer[5];
                  float flowMinFloat = (float)flowMinQuint16/1000;
                  if(flowMinFloat>=0 && flowMinFloat<=0.2) {
                      ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальный расход"));
                      ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
                  }

                  qDebug()<<"flowMinArray.toHex() "<<flowMinArray.toHex();
                  paramsVector.append(flowMinArray);
                  mapRead["flowMinByteArray"] = flowMinArray;

                  //
                  //flowMax
                  QByteArray flowMaxArray;
                  flowMaxArray.append(buffer[6]);
                  flowMaxArray.append(buffer[7]);

     //             float flowMaxFloat = buffer[6];
                  quint16 flowMaxQuint16 = buffer[6];
                  flowMaxQuint16 = (flowMaxQuint16<<8) | (quint8)(buffer.at(7));
                  float flowMaxFloat = flowMaxQuint16;
                  flowMaxFloat = flowMaxFloat/1000;
                  if(flowMaxFloat>=2 && flowMaxFloat<=5) {
                      ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальный расход"));
                      ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
                  }

                  qDebug()<<"flowMaxArray.toHex() "<<flowMaxArray.toHex();
                  paramsVector.append(flowMaxArray);
                  mapRead["flowMaxByteArray"] = flowMaxArray;

                  //
                  //tinMin
                  QByteArray tinMinArray;
                  tinMinArray.append(buffer[8]);


                  quint8 tinMinQuint8 = buffer[8];
                  if(tinMinQuint8>=10 && tinMinQuint8<=60) {
                      ui->spinBox_Tin_min->setValue(tinMinQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура подачи"));
                  }

                  qDebug()<<"tinMinArray.toHex() "<<tinMinArray.toHex();
                  paramsVector.append(tinMinArray);
                  mapRead["tinMinByteArray"] = tinMinArray;

                  //
                  //tinMax
                  QByteArray tinMaxArray;
                  tinMaxArray.append(buffer[9]);


                  quint8 tinMaxQuint8 = buffer[9];
                  if(tinMaxQuint8>=50 && tinMaxQuint8<=150) {
                      ui->spinBox_Tin_max->setValue(tinMaxQuint8);
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура подачи"));
                  }

                  qDebug()<<"tinMaxArray.toHex() "<<tinMaxArray.toHex();
                  paramsVector.append(tinMaxArray);
                  mapRead["tinMaxByteArray"] = tinMaxArray;

                  //
                  //toutMin
                  QByteArray toutMinArray;
                  toutMinArray.append(buffer[10]);

                  quint8 toutMinQuint8 = buffer[10];
                  if(toutMinQuint8>=10 && toutMinQuint8<=60) {
                      ui->spinBox_Tout_min->setValue(toutMinQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура обратки"));
                  }

                  qDebug()<<"toutMinArray.toHex() "<<toutMinArray.toHex();
                  paramsVector.append(toutMinArray);
                  mapRead["toutMinByteArray"] = toutMinArray;


                  //
                  //toutMax
                  QByteArray toutMaxArray;
                  toutMaxArray.append(buffer[11]);

                  quint8 toutMaxQuint8 = buffer[11];
                  if(toutMaxQuint8>=50 && toutMaxQuint8<=150) {
                      ui->spinBox_Tout_max->setValue(toutMaxQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура обратки"));
                  }

                  qDebug()<<"toutMaxArray.toHex() "<<toutMaxArray.toHex();
                  paramsVector.append(toutMaxArray);
                  mapRead["toutMaxByteArray"] = toutMaxArray;

                  //
                  //reportData
                  QByteArray reportDataArray;
                  reportDataArray.append(buffer[12]);

                  quint8 reportDataInt = buffer[12];
                  if(reportDataInt>=0 && reportDataInt<=31) {
                      ui->spinBox_ReportData->setValue(reportDataInt);
                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: Дата сохранения в журнал"));
                  }

                  qDebug()<<"reportDataArray.toHex() "<<reportDataArray.toHex();
                  paramsVector.append(reportDataArray);
                  mapRead["reportDataByteArray"] = reportDataArray;

                  //
                  //AverageT
                  QByteArray AverageTArray;
                  AverageTArray.append(buffer[13]);


                  quint8 AverageTInt = buffer[13];
                  if(AverageTList.contains(QString::number(AverageTInt))) {
                      ui->comboBox_Average_T->setCurrentText(QString::number(AverageTInt));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Тип усреднения температуры"));
                  }

                  qDebug()<<"AverageTArray.toHex() "<<AverageTArray.toHex();
                  paramsVector.append(AverageTArray);
                  mapRead["averageTByteArray"] = AverageTArray;

                  //
                  //pulsesMode1
                  QByteArray pulsesMode1Array;
                  pulsesMode1Array.append(buffer[14]);


                  quint8 pulsesMode1Int = (quint8)buffer[14];
                  if(pulsesMode1List.contains(QString::number(pulsesMode1Int))) {
                      ui->comboBox_PulsesMode1->setCurrentText(QString::number(pulsesMode1Int));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
                  }

                  qDebug()<<"pulsesMode1Array.toHex() "<<pulsesMode1Array.toHex();
                  paramsVector.append(pulsesMode1Array);
                  mapRead["pulsesMode1ByteArray"] = pulsesMode1Array;

                  //
                  //pulsesMode2
                  QByteArray pulsesMode2Array;
                  pulsesMode2Array.append(buffer[15]);


                  quint8 pulsesMode2Int = (quint8)buffer[15];
                  if(pulsesMode1List.contains(QString::number(pulsesMode2Int))) {
                      ui->comboBox_PulsesMode2->setCurrentText(QString::number(pulsesMode2Int));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
                  }

                  qDebug()<<"pulsesMode2Array.toHex() "<<pulsesMode2Array.toHex();
                  paramsVector.append(pulsesMode2Array);
                  mapRead["pulsesMode2ByteArray"] = pulsesMode2Array;

                  //
                  //pulsesValue1
                  QByteArray pulsesValue1Array;
                  pulsesValue1Array.append(buffer[16]);
                  pulsesValue1Array.append(buffer[17]);


                  quint16 pulsesValue1Int = buffer[16];
                  pulsesValue1Int = pulsesValue1Int<<8 | (quint8)buffer[17];
    //              if((pulsesValue1Int<=101) && (pulsesValue1Int>=99)) {

    //              }
                  ui->lineEdit_PulsesValue1->setText(QString::number(pulsesValue1Int));

                  qDebug()<<"pulsesValue1Array.toHex() "<<pulsesValue1Array.toHex();
                  paramsVector.append(pulsesValue1Array);
                  mapRead["pulsesValue1ByteArray"] = pulsesValue1Array;

                  //
                  //pulsesValue2
                  QByteArray pulsesValue2Array;
                  pulsesValue2Array.append(buffer[18]);
                  pulsesValue2Array.append(buffer[19]);
                  qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();

                  quint16 pulsesValue2Int = buffer[18];
                  pulsesValue2Int = pulsesValue2Int<<8 | (quint8)buffer[19];
                  ui->lineEdit_PulsesValue2->setText(QString::number(pulsesValue2Int));

                  qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();
                  paramsVector.append(pulsesValue2Array);
                  mapRead["pulsesValue2ByteArray"] = pulsesValue2Array;

                  //
                  //DevType
                  QByteArray devType;
                  devType.append(buffer[20]);

                  if(devType[0] == 0x04) {
                      ui->comboBox_DevType->setCurrentText("Обратный");
                  }

                  if(devType[0] == 0x0c) {
                      ui->comboBox_DevType->setCurrentText("Подающий");
                  }

                  if((devType[0] != 0x04) && (devType[0] != 0x0c) ) {
//                      QMessageBox::information(this, "", tr("Недопустимое значение: Тип счётчика") +
//                                               " Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Недопустимое значение: Тип счётчика") +
                                                   " Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkPulsesInputVolume(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
      //                ui->label_pulsesInputVolume->setVisible(true);
                      return;
                  }

                  qDebug()<<"devType.toHex() "<<devType.toHex();
                  paramsVector.append(devType);
                  mapRead["devType"] = devType;



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка данных") +
//                                               " Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка данных") +
                                                   " Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkPulsesInputVolume(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
       //               ui->label_pulsesInputVolume->setVisible(true);
                      return;
                   }
               }

           }


        }



        QVector<QByteArray> writeVector;
        writeVector.append(mapwrite["flowMinByteArray"]);
        writeVector.append(mapwrite["flowMaxByteArray"]);
        writeVector.append(mapwrite["tinMinByteArray"]);
        writeVector.append(mapwrite["tinMaxByteArray"]);
        writeVector.append(mapwrite["toutMinByteArray"]);
        writeVector.append(mapwrite["toutMaxByteArray"]);
        writeVector.append(mapwrite["reportDataByteArray"]);
        writeVector.append(mapwrite["averageTByteArray"]);
        writeVector.append(mapwrite["pulsesMode1ByteArray"]);
        writeVector.append(mapwrite["pulsesMode2ByteArray"]);
        writeVector.append(mapwrite["pulsesValue1ByteArray"]);
        writeVector.append(mapwrite["pulsesValue2ByteArray"]);

        QVector<QByteArray> readVector;
        readVector.append(mapRead["flowMinByteArray"]);
        readVector.append(mapRead["flowMaxByteArray"]);
        readVector.append(mapRead["tinMinByteArray"]);
        readVector.append(mapRead["tinMaxByteArray"]);
        readVector.append(mapRead["toutMinByteArray"]);
        readVector.append(mapRead["toutMaxByteArray"]);
        readVector.append(mapRead["reportDataByteArray"]);
        readVector.append(mapRead["averageTByteArray"]);
        readVector.append(mapRead["pulsesMode1ByteArray"]);
        readVector.append(mapRead["pulsesMode2ByteArray"]);
        readVector.append(mapRead["pulsesValue1ByteArray"]);
        readVector.append(mapRead["pulsesValue2ByteArray"]);

        for(int i=0; i<allParamsNameList.size(); i++) {
            qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
            qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();
        }

        for(int i=0; i<writeVector.size(); i++) {


            if((i == (writeVector.size() - 2)) || (i == (writeVector.size() - 1))) {
                int paramRead = (quint8)(readVector[i][0]);
                paramRead = paramRead<<8 | (quint8)(readVector[i][1]);

                int paramWrite = (quint8)(writeVector[i][0]);
                paramWrite = paramWrite<<8 | (quint8)(writeVector[i][1]);

                if((paramRead >= (paramWrite - 1)) && (paramRead <= (paramWrite + 1))) {

                }
                else {
//                    QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
//                                             " " + "чтение " + readVector[i].toHex() +
//                                             " Рабочее место: " + QString::number(workPlaceNumber+1));
                    ui->label_StatusBar->setText("Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                                 " " + "чтение " + readVector[i].toHex() +
                                                 " Рабочее место: " + QString::number(workPlaceNumber+1));
                    errorString.append(ui->label_StatusBar->text() + '\n');
                    vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                    checkPulsesInputVolume(currentIndicatorNumber);
                    workPlaceOff(currentIndicatorNumber);
    //                ui->label_pulsesInputVolume->setVisible(true);
                    return;
                }
            }
            else {
                    if((readVector[i] != writeVector[i]) && (i != (writeVector.size() - 2)) && (i != (writeVector.size() - 1)) ) {
//                       QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
//                                             " " + "чтение " + readVector[i].toHex() +
//                                                " Рабочее место: " + QString::number(workPlaceNumber+1));
                       ui->label_StatusBar->setText("Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                                    " " + "чтение " + readVector[i].toHex() +
                                                       " Рабочее место: " + QString::number(workPlaceNumber+1));
                       errorString.append(ui->label_StatusBar->text() + '\n');
                       vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                       checkPulsesInputVolume(currentIndicatorNumber);
                       workPlaceOff(currentIndicatorNumber);
     //                  ui->label_pulsesInputVolume->setVisible(true);
                       return;
                    }
            }
        }


        ui->label_pulsesInputVolume->setStyleSheet(QString("color: green").arg(color.name()));
        ui->label_pulsesInputVolume->setText("V");
   //     ui->label_pulsesInputVolume->setVisible(true);


        checkPulsesInputVolume(currentIndicatorNumber);


}

void MainWindow::on_toolButton_pulsesInputVolume_clicked()
{
    ui->label_StatusBar->setText("");

    QColor color(255, 127, 50);
    ui->label_pulsesInputVolume->setStyleSheet(QString("color: red").arg(color.name()));
    ui->label_pulsesInputVolume->setText("X");
    ui->label_pulsesInputVolume->setVisible(false);

    pulsesMode1ByteArray.clear();
    pulsesMode2ByteArray.clear();
    quint8 byte = 2;
    pulsesMode1ByteArray.append(byte);
    pulsesMode2ByteArray.append(byte);
    //
    pulsesValue1ByteArray.clear();
    pulsesValue2ByteArray.clear();
    quint16 twoBytes = 100;
    pulsesValue1ByteArray.append((quint8)(twoBytes>>8));
    pulsesValue1ByteArray.append((quint8)(twoBytes));

    pulsesValue2ByteArray.append((quint8)(twoBytes>>8));
    pulsesValue2ByteArray.append((quint8)(twoBytes));

    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
            return;
        }
    }

    //одна команда Write Software Configuration с открытием парольной сессии

    //Открыть парольную сессию 5a 00 08 40 01 04 57
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x08;
       packetToRead.append(byte);
       byte = 0x40;
       packetToRead.append(byte);
       byte = 0x01;
       packetToRead.append(byte);
       byte = 0x04;
       packetToRead.append(byte);
       byte = 0x57;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
               ui->label_pulsesInputVolume->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xc0;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);


              //
              //



              break;
           }
           else {
                    if(i==2) {
                        QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
                        ui->label_pulsesInputVolume->setVisible(true);
                        return;
                    }

           }



       }


    }

    //
    //Write Software Configuration 5a 00 16 20
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x16;
       packetToRead.append(byte);
       byte = 0x20;
       packetToRead.append(byte);

       byte = flowMinByteArray[0];
       packetToRead.append(byte);
       byte = flowMinByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowMinByteArray);
       mapwrite["flowMinByteArray"] = flowMinByteArray;


       byte = flowMaxByteArray[0];
       packetToRead.append(byte);
       byte = flowMaxByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowMaxByteArray);
       mapwrite["flowMaxByteArray"] = flowMaxByteArray;


       byte = tinMinByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(tinMinByteArray);
       mapwrite["tinMinByteArray"] = tinMinByteArray;


       byte = tinMaxByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(tinMaxByteArray);
       mapwrite["tinMaxByteArray"] = tinMaxByteArray;


       byte = toutMinByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(toutMinByteArray);
       mapwrite["toutMinByteArray"] = toutMinByteArray;


       byte = toutMaxByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(toutMaxByteArray);
       mapwrite["toutMaxByteArray"] = toutMaxByteArray;


       byte = reportDataByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(reportDataByteArray);
       mapwrite["reportDataByteArray"] = reportDataByteArray;


       byte = averageTByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(averageTByteArray);
       mapwrite["averageTByteArray"] = averageTByteArray;


       byte = pulsesMode1ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesMode1ByteArray);
       mapwrite["pulsesMode1ByteArray"] = pulsesMode1ByteArray;


       byte = pulsesMode2ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesMode2ByteArray);
       mapwrite["pulsesMode2ByteArray"] = pulsesMode2ByteArray;


       byte = pulsesValue1ByteArray[0];
       packetToRead.append(byte);
       byte = pulsesValue1ByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesValue1ByteArray);
       mapwrite["pulsesValue1ByteArray"] = pulsesValue1ByteArray;


       byte = pulsesValue2ByteArray[0];
       packetToRead.append(byte);
       byte = pulsesValue2ByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesValue2ByteArray);
       mapwrite["pulsesValue2ByteArray"] = pulsesValue2ByteArray;

       byte = devType[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(devType);
       mapwrite["devType"] = devType;

       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : Software Configuration"));
               ui->label_pulsesInputVolume->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xa0;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных : Software Configuration"));
                  ui->label_pulsesInputVolume->setVisible(true);
                  return;
               }
           }



       }


    }


    //
    //Read Software Configuration 5a000502
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x02;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               ui->label_pulsesInputVolume->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x16;
           bytesForChecking.append(byte);
           byte = 0x82;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
//              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

              emit sendbufferReadSoftWareConfiguration(buffer);

              //
              //flowMin
              QByteArray flowMinArray;
              flowMinArray.append(buffer[4]);
              flowMinArray.append(buffer[5]);
 //             ui->lineEdit_Flow_min->setText(flowMinArray.toHex());

 //             float flowMinFloat = buffer[4];
              quint16 flowMinQuint16 = buffer[4];
              flowMinQuint16 = flowMinQuint16<<8 | buffer[5];
              float flowMinFloat = (float)flowMinQuint16/1000;
              if(flowMinFloat>=0 && flowMinFloat<=0.2) {
                  ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальный расход"));
                  ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
              }

              qDebug()<<"flowMinArray.toHex() "<<flowMinArray.toHex();
              paramsVector.append(flowMinArray);
              mapRead["flowMinByteArray"] = flowMinArray;

              //
              //flowMax
              QByteArray flowMaxArray;
              flowMaxArray.append(buffer[6]);
              flowMaxArray.append(buffer[7]);

 //             float flowMaxFloat = buffer[6];
              quint16 flowMaxQuint16 = buffer[6];
              flowMaxQuint16 = (flowMaxQuint16<<8) | (quint8)(buffer.at(7));
              float flowMaxFloat = flowMaxQuint16;
              flowMaxFloat = flowMaxFloat/1000;
              if(flowMaxFloat>=2 && flowMaxFloat<=5) {
                  ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальный расход"));
                  ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
              }

              qDebug()<<"flowMaxArray.toHex() "<<flowMaxArray.toHex();
              paramsVector.append(flowMaxArray);
              mapRead["flowMaxByteArray"] = flowMaxArray;

              //
              //tinMin
              QByteArray tinMinArray;
              tinMinArray.append(buffer[8]);


              quint8 tinMinQuint8 = buffer[8];
              if(tinMinQuint8>=10 && tinMinQuint8<=60) {
                  ui->spinBox_Tin_min->setValue(tinMinQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура подачи"));
              }

              qDebug()<<"tinMinArray.toHex() "<<tinMinArray.toHex();
              paramsVector.append(tinMinArray);
              mapRead["tinMinByteArray"] = tinMinArray;

              //
              //tinMax
              QByteArray tinMaxArray;
              tinMaxArray.append(buffer[9]);


              quint8 tinMaxQuint8 = buffer[9];
              if(tinMaxQuint8>=50 && tinMaxQuint8<=150) {
                  ui->spinBox_Tin_max->setValue(tinMaxQuint8);
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура подачи"));
              }

              qDebug()<<"tinMaxArray.toHex() "<<tinMaxArray.toHex();
              paramsVector.append(tinMaxArray);
              mapRead["tinMaxByteArray"] = tinMaxArray;

              //
              //toutMin
              QByteArray toutMinArray;
              toutMinArray.append(buffer[10]);

              quint8 toutMinQuint8 = buffer[10];
              if(toutMinQuint8>=10 && toutMinQuint8<=60) {
                  ui->spinBox_Tout_min->setValue(toutMinQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура обратки"));
              }

              qDebug()<<"toutMinArray.toHex() "<<toutMinArray.toHex();
              paramsVector.append(toutMinArray);
              mapRead["toutMinByteArray"] = toutMinArray;


              //
              //toutMax
              QByteArray toutMaxArray;
              toutMaxArray.append(buffer[11]);

              quint8 toutMaxQuint8 = buffer[11];
              if(toutMaxQuint8>=50 && toutMaxQuint8<=150) {
                  ui->spinBox_Tout_max->setValue(toutMaxQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура обратки"));
              }

              qDebug()<<"toutMaxArray.toHex() "<<toutMaxArray.toHex();
              paramsVector.append(toutMaxArray);
              mapRead["toutMaxByteArray"] = toutMaxArray;

              //
              //reportData
              QByteArray reportDataArray;
              reportDataArray.append(buffer[12]);

              quint8 reportDataInt = buffer[12];
              if(reportDataInt>=0 && reportDataInt<=31) {
                  ui->spinBox_ReportData->setValue(reportDataInt);
              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: Дата сохранения в журнал"));
              }

              qDebug()<<"reportDataArray.toHex() "<<reportDataArray.toHex();
              paramsVector.append(reportDataArray);
              mapRead["reportDataByteArray"] = reportDataArray;

              //
              //AverageT
              QByteArray AverageTArray;
              AverageTArray.append(buffer[13]);


              quint8 AverageTInt = buffer[13];
              if(AverageTList.contains(QString::number(AverageTInt))) {
                  ui->comboBox_Average_T->setCurrentText(QString::number(AverageTInt));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Тип усреднения температуры"));
              }

              qDebug()<<"AverageTArray.toHex() "<<AverageTArray.toHex();
              paramsVector.append(AverageTArray);
              mapRead["averageTByteArray"] = AverageTArray;

              //
              //pulsesMode1
              QByteArray pulsesMode1Array;
              pulsesMode1Array.append(buffer[14]);


              quint8 pulsesMode1Int = (quint8)buffer[14];
              if(pulsesMode1List.contains(QString::number(pulsesMode1Int))) {
                  ui->comboBox_PulsesMode1->setCurrentText(QString::number(pulsesMode1Int));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
              }

              qDebug()<<"pulsesMode1Array.toHex() "<<pulsesMode1Array.toHex();
              paramsVector.append(pulsesMode1Array);
              mapRead["pulsesMode1ByteArray"] = pulsesMode1Array;

              //
              //pulsesMode2
              QByteArray pulsesMode2Array;
              pulsesMode2Array.append(buffer[15]);


              quint8 pulsesMode2Int = (quint8)buffer[15];
              if(pulsesMode1List.contains(QString::number(pulsesMode2Int))) {
                  ui->comboBox_PulsesMode2->setCurrentText(QString::number(pulsesMode2Int));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
              }

              qDebug()<<"pulsesMode2Array.toHex() "<<pulsesMode2Array.toHex();
              paramsVector.append(pulsesMode2Array);
              mapRead["pulsesMode2ByteArray"] = pulsesMode2Array;

              //
              //pulsesValue1
              QByteArray pulsesValue1Array;
              pulsesValue1Array.append(buffer[16]);
              pulsesValue1Array.append(buffer[17]);


              quint16 pulsesValue1Int = buffer[16];
              pulsesValue1Int = pulsesValue1Int<<8 | (quint8)buffer[17];
//              if((pulsesValue1Int<=101) && (pulsesValue1Int>=99)) {

//              }
              ui->lineEdit_PulsesValue1->setText(QString::number(pulsesValue1Int));

              qDebug()<<"pulsesValue1Array.toHex() "<<pulsesValue1Array.toHex();
              paramsVector.append(pulsesValue1Array);
              mapRead["pulsesValue1ByteArray"] = pulsesValue1Array;

              //
              //pulsesValue2
              QByteArray pulsesValue2Array;
              pulsesValue2Array.append(buffer[18]);
              pulsesValue2Array.append(buffer[19]);
              qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();

              quint16 pulsesValue2Int = buffer[18];
              pulsesValue2Int = pulsesValue2Int<<8 | (quint8)buffer[19];
              ui->lineEdit_PulsesValue2->setText(QString::number(pulsesValue2Int));

              qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();
              paramsVector.append(pulsesValue2Array);
              mapRead["pulsesValue2ByteArray"] = pulsesValue2Array;

              //
              //DevType
              QByteArray devType;
              devType.append(buffer[20]);

              if(devType[0] == 0x04) {
                  ui->comboBox_DevType->setCurrentText("Обратный");
              }

              if(devType[0] == 0x0c) {
                  ui->comboBox_DevType->setCurrentText("Подающий");
              }

              if((devType[0] != 0x04) && (devType[0] != 0x0c) ) {
                  QMessageBox::information(this, "", tr("Недопустимое значение: Тип счётчика"));
              }

              qDebug()<<"devType.toHex() "<<devType.toHex();
              paramsVector.append(devType);
              mapRead["devType"] = devType;



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  ui->label_pulsesInputVolume->setVisible(true);
                  return;
               }
           }

       }


    }



    QVector<QByteArray> writeVector;
    writeVector.append(mapwrite["flowMinByteArray"]);
    writeVector.append(mapwrite["flowMaxByteArray"]);
    writeVector.append(mapwrite["tinMinByteArray"]);
    writeVector.append(mapwrite["tinMaxByteArray"]);
    writeVector.append(mapwrite["toutMinByteArray"]);
    writeVector.append(mapwrite["toutMaxByteArray"]);
    writeVector.append(mapwrite["reportDataByteArray"]);
    writeVector.append(mapwrite["averageTByteArray"]);
    writeVector.append(mapwrite["pulsesMode1ByteArray"]);
    writeVector.append(mapwrite["pulsesMode2ByteArray"]);
    writeVector.append(mapwrite["pulsesValue1ByteArray"]);
    writeVector.append(mapwrite["pulsesValue2ByteArray"]);

    QVector<QByteArray> readVector;
    readVector.append(mapRead["flowMinByteArray"]);
    readVector.append(mapRead["flowMaxByteArray"]);
    readVector.append(mapRead["tinMinByteArray"]);
    readVector.append(mapRead["tinMaxByteArray"]);
    readVector.append(mapRead["toutMinByteArray"]);
    readVector.append(mapRead["toutMaxByteArray"]);
    readVector.append(mapRead["reportDataByteArray"]);
    readVector.append(mapRead["averageTByteArray"]);
    readVector.append(mapRead["pulsesMode1ByteArray"]);
    readVector.append(mapRead["pulsesMode2ByteArray"]);
    readVector.append(mapRead["pulsesValue1ByteArray"]);
    readVector.append(mapRead["pulsesValue2ByteArray"]);

    for(int i=0; i<allParamsNameList.size(); i++) {
        qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
        qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();
    }

    for(int i=0; i<writeVector.size(); i++) {


        if((i == (writeVector.size() - 2)) || (i == (writeVector.size() - 1))) {
            int paramRead = (quint8)(readVector[i][0]);
            paramRead = paramRead<<8 | (quint8)(readVector[i][1]);

            int paramWrite = (quint8)(writeVector[i][0]);
            paramWrite = paramWrite<<8 | (quint8)(writeVector[i][1]);

            if((paramRead >= (paramWrite - 1)) && (paramRead <= (paramWrite + 1))) {

            }
            else {
                QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                         " " + "чтение " + readVector[i].toHex());
                ui->label_pulsesInputVolume->setVisible(true);
                return;
            }
        }
        else {
                if((readVector[i] != writeVector[i]) && (i != (writeVector.size() - 2)) && (i != (writeVector.size() - 1)) ) {
                   QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                         " " + "чтение " + readVector[i].toHex());
                   ui->label_pulsesInputVolume->setVisible(true);
                   return;
                }
        }
    }


    ui->label_pulsesInputVolume->setStyleSheet(QString("color: green").arg(color.name()));
    ui->label_pulsesInputVolume->setText("V");
    ui->label_pulsesInputVolume->setVisible(true);


//    on_toolButton_writeParams_clicked();
}

void MainWindow::pulsesOutputDefault(int workPlaceNumber)
{

    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }

    portTmp->setBaudRate(QSerialPort::Baud19200);
    portTmp->setDataBits(QSerialPort::Data8);
    portTmp->setParity(QSerialPort::NoParity);
    portTmp->setStopBits(QSerialPort::OneStop);


    currentBoxNumber = 4;
    vectorIsErrorOccured[workPlaceNumber] = false;

        ui->label_StatusBar->setText("");

        QColor color(255, 127, 50);
        ui->label_pulsesOutputOff->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_pulsesOutputOff->setText("X");
        ui->label_pulsesOutputOff->setVisible(false);

        pulsesMode1ByteArray.clear();
        pulsesMode2ByteArray.clear();

        pulsesMode1ByteArray.append(pulsesMode1PrimalInt); //append(byte);
        pulsesMode2ByteArray.append(pulsesMode2PrimalInt); //append(byte);


        if(pulsesValue1PrimeInt == 0) {
//            QMessageBox::information(this, "", tr("Недоустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt) +
//                                     ". Рабочее место: " + QString::number(workPlaceNumber + 1));
            ui->label_StatusBar->setText(tr("Недоустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt) +
                                         ". Рабочее место: " + QString::number(workPlaceNumber + 1));
            errorString.append(ui->label_StatusBar->text() + '\n');
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkPulsesOutputDefault(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
            return;
        }
        if(pulsesValue2PrimeInt == 0) {
//            QMessageBox::information(this, "", tr("Недоустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt) +
//                                     ". Рабочее место: " + QString::number(workPlaceNumber + 1));
            ui->label_StatusBar->setText(tr("Недоустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt) +
                                         ". Рабочее место: " + QString::number(workPlaceNumber + 1));
            errorString.append(ui->label_StatusBar->text() + '\n');
            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
            checkPulsesOutputDefault(currentIndicatorNumber);
            workPlaceOff(currentIndicatorNumber);
            return;
        }
        pulsesValue1ByteArray.clear();
        pulsesValue2ByteArray.clear();
        pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt>>8));
        pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt));

        pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt>>8));
        pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt));

        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
//                QMessageBox::information(this, "", "Не удалось открыть порт УСО-2. Рабочее место: "
//                                         + QString::number(workPlaceNumber + 1));
                ui->label_StatusBar->setText("Не удалось открыть порт УСО-2. Рабочее место: "
                                             + QString::number(workPlaceNumber + 1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkPulsesOutputDefault(currentIndicatorNumber);
                workPlaceOff(currentIndicatorNumber);
                return;
            }
        }

        //одна команда Write Software Configuration с открытием парольной сессии

        //Открыть парольную сессию 5a 00 08 40 01 04 57
        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x08;
           packetToRead.append(byte);
           byte = 0x40;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);
           byte = 0x04;
           packetToRead.append(byte);
           byte = 0x57;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: "
//                                                 + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") + ". Рабочее место: "
                                            + QString::number(workPlaceNumber + 1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkPulsesOutputDefault(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
//                   QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") + ". Рабочее место: "
//                                            + QString::number(workPlaceNumber + 1));
                   ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") + ". Рабочее место: "
                                                + QString::number(workPlaceNumber + 1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkPulsesOutputDefault(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
     //              ui->label_pulsesOutputOff->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc0;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);


                  //
                  //



                  break;
               }
               else {
                        if(i==9) {
//                            QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") + ". Рабочее место: "
//                                                     + QString::number(workPlaceNumber + 1));
                            ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") + ". Рабочее место: "
                                                         + QString::number(workPlaceNumber + 1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkPulsesOutputDefault(currentIndicatorNumber);
                            workPlaceOff(currentIndicatorNumber);
     //                       ui->label_pulsesOutputOff->setVisible(true);
                            return;
                        }

               }



           }


        }

        //
        //Write Software Configuration 5a 00 16 20
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x16;
           packetToRead.append(byte);
           byte = 0x20;
           packetToRead.append(byte);

           byte = flowMinByteArray[0];
           packetToRead.append(byte);
           byte = flowMinByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMinByteArray);
           mapwrite["flowMinByteArray"] = flowMinByteArray;


           byte = flowMaxByteArray[0];
           packetToRead.append(byte);
           byte = flowMaxByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(flowMaxByteArray);
           mapwrite["flowMaxByteArray"] = flowMaxByteArray;


           byte = tinMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMinByteArray);
           mapwrite["tinMinByteArray"] = tinMinByteArray;


           byte = tinMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(tinMaxByteArray);
           mapwrite["tinMaxByteArray"] = tinMaxByteArray;


           byte = toutMinByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMinByteArray);
           mapwrite["toutMinByteArray"] = toutMinByteArray;


           byte = toutMaxByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(toutMaxByteArray);
           mapwrite["toutMaxByteArray"] = toutMaxByteArray;


           byte = reportDataByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(reportDataByteArray);
           mapwrite["reportDataByteArray"] = reportDataByteArray;


           byte = averageTByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(averageTByteArray);
           mapwrite["averageTByteArray"] = averageTByteArray;


           byte = pulsesMode1ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode1ByteArray);
           mapwrite["pulsesMode1ByteArray"] = pulsesMode1ByteArray;


           byte = pulsesMode2ByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesMode2ByteArray);
           mapwrite["pulsesMode2ByteArray"] = pulsesMode2ByteArray;


           byte = pulsesValue1ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue1ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue1ByteArray);
           mapwrite["pulsesValue1ByteArray"] = pulsesValue1ByteArray;


           byte = pulsesValue2ByteArray[0];
           packetToRead.append(byte);
           byte = pulsesValue2ByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(pulsesValue2ByteArray);
           mapwrite["pulsesValue2ByteArray"] = pulsesValue2ByteArray;

           byte = devType[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(devType);
           mapwrite["devType"] = devType;

           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: "
//                                        + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") + ". Рабочее место: "
                                            + QString::number(workPlaceNumber + 1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkPulsesOutputDefault(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
      //         ui->label_pulsesOutputOff->setVisible(true);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось записать данные : Software Configuration") + ". Рабочее место: "
//                                            + QString::number(workPlaceNumber + 1));
                   ui->label_StatusBar->setText(tr("Не удалось записать данные : Software Configuration") + ". Рабочее место: "
                                                + QString::number(workPlaceNumber + 1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkPulsesOutputDefault(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
      //             ui->label_pulsesOutputOff->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xa0;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : Software Configuration") + ". Рабочее место: "
//                                               + QString::number(workPlaceNumber + 1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : Software Configuration") + ". Рабочее место: "
                                                   + QString::number(workPlaceNumber + 1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkPulsesOutputDefault(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
    //                  ui->label_pulsesOutputOff->setVisible(true);
                      return;
                   }
               }



           }


        }


        //
        //Read Software Configuration 5a000502
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x02;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: "
//                                        + QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") + ". Рабочее место: "
                                            + QString::number(workPlaceNumber + 1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkPulsesOutputDefault(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
   //            ui->label_pulsesOutputOff->setVisible(true);
               return;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось прочитать данные") + ". Рабочее место: "
//                                            + QString::number(workPlaceNumber + 1));
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") + ". Рабочее место: "
                                                + QString::number(workPlaceNumber + 1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkPulsesOutputDefault(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
     //              ui->label_pulsesOutputOff->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x16;
               bytesForChecking.append(byte);
               byte = 0x82;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
    //              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

     //             emit sendbufferReadSoftWareConfiguration(buffer);

                  //
                  //flowMin
                  QByteArray flowMinArray;
                  flowMinArray.append(buffer[4]);
                  flowMinArray.append(buffer[5]);
     //             ui->lineEdit_Flow_min->setText(flowMinArray.toHex());

     //             float flowMinFloat = buffer[4];
                  quint16 flowMinQuint16 = buffer[4];
                  flowMinQuint16 = flowMinQuint16<<8 | buffer[5];
                  float flowMinFloat = (float)flowMinQuint16/1000;
                  if(flowMinFloat>=0 && flowMinFloat<=0.2) {
                      ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальный расход"));
                      ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
                  }

                  qDebug()<<"flowMinArray.toHex() "<<flowMinArray.toHex();
                  paramsVector.append(flowMinArray);
                  mapRead["flowMinByteArray"] = flowMinArray;

                  //
                  //flowMax
                  QByteArray flowMaxArray;
                  flowMaxArray.append(buffer[6]);
                  flowMaxArray.append(buffer[7]);

     //             float flowMaxFloat = buffer[6];
                  quint16 flowMaxQuint16 = buffer[6];
                  flowMaxQuint16 = (flowMaxQuint16<<8) | (quint8)(buffer.at(7));
                  float flowMaxFloat = flowMaxQuint16;
                  flowMaxFloat = flowMaxFloat/1000;
                  if(flowMaxFloat>=2 && flowMaxFloat<=5) {
                      ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальный расход"));
                      ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
                  }

                  qDebug()<<"flowMaxArray.toHex() "<<flowMaxArray.toHex();
                  paramsVector.append(flowMaxArray);
                  mapRead["flowMaxByteArray"] = flowMaxArray;

                  //
                  //tinMin
                  QByteArray tinMinArray;
                  tinMinArray.append(buffer[8]);


                  quint8 tinMinQuint8 = buffer[8];
                  if(tinMinQuint8>=10 && tinMinQuint8<=60) {
                      ui->spinBox_Tin_min->setValue(tinMinQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура подачи"));
                  }

                  qDebug()<<"tinMinArray.toHex() "<<tinMinArray.toHex();
                  paramsVector.append(tinMinArray);
                  mapRead["tinMinByteArray"] = tinMinArray;

                  //
                  //tinMax
                  QByteArray tinMaxArray;
                  tinMaxArray.append(buffer[9]);


                  quint8 tinMaxQuint8 = buffer[9];
                  if(tinMaxQuint8>=50 && tinMaxQuint8<=150) {
                      ui->spinBox_Tin_max->setValue(tinMaxQuint8);
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура подачи"));
                  }

                  qDebug()<<"tinMaxArray.toHex() "<<tinMaxArray.toHex();
                  paramsVector.append(tinMaxArray);
                  mapRead["tinMaxByteArray"] = tinMaxArray;

                  //
                  //toutMin
                  QByteArray toutMinArray;
                  toutMinArray.append(buffer[10]);

                  quint8 toutMinQuint8 = buffer[10];
                  if(toutMinQuint8>=10 && toutMinQuint8<=60) {
                      ui->spinBox_Tout_min->setValue(toutMinQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура обратки"));
                  }

                  qDebug()<<"toutMinArray.toHex() "<<toutMinArray.toHex();
                  paramsVector.append(toutMinArray);
                  mapRead["toutMinByteArray"] = toutMinArray;


                  //
                  //toutMax
                  QByteArray toutMaxArray;
                  toutMaxArray.append(buffer[11]);

                  quint8 toutMaxQuint8 = buffer[11];
                  if(toutMaxQuint8>=50 && toutMaxQuint8<=150) {
                      ui->spinBox_Tout_max->setValue(toutMaxQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура обратки"));
                  }

                  qDebug()<<"toutMaxArray.toHex() "<<toutMaxArray.toHex();
                  paramsVector.append(toutMaxArray);
                  mapRead["toutMaxByteArray"] = toutMaxArray;

                  //
                  //reportData
                  QByteArray reportDataArray;
                  reportDataArray.append(buffer[12]);

                  quint8 reportDataInt = buffer[12];
                  if(reportDataInt>=0 && reportDataInt<=31) {
                      ui->spinBox_ReportData->setValue(reportDataInt);
                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: Дата сохранения в журнал"));
                  }

                  qDebug()<<"reportDataArray.toHex() "<<reportDataArray.toHex();
                  paramsVector.append(reportDataArray);
                  mapRead["reportDataByteArray"] = reportDataArray;

                  //
                  //AverageT
                  QByteArray AverageTArray;
                  AverageTArray.append(buffer[13]);


                  quint8 AverageTInt = buffer[13];
                  if(AverageTList.contains(QString::number(AverageTInt))) {
                      ui->comboBox_Average_T->setCurrentText(QString::number(AverageTInt));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Тип усреднения температуры"));
                  }

                  qDebug()<<"AverageTArray.toHex() "<<AverageTArray.toHex();
                  paramsVector.append(AverageTArray);
                  mapRead["averageTByteArray"] = AverageTArray;

                  //
                  //pulsesMode1
                  QByteArray pulsesMode1Array;
                  pulsesMode1Array.append(buffer[14]);


                  quint8 pulsesMode1Int = (quint8)buffer[14];
                  if(pulsesMode1List.contains(QString::number(pulsesMode1Int))) {
                      ui->comboBox_PulsesMode1->setCurrentText(QString::number(pulsesMode1Int));
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
                  }

                  qDebug()<<"pulsesMode1Array.toHex() "<<pulsesMode1Array.toHex();
                  paramsVector.append(pulsesMode1Array);
                  mapRead["pulsesMode1ByteArray"] = pulsesMode1Array;

                  //
                  //pulsesMode2
                  QByteArray pulsesMode2Array;
                  pulsesMode2Array.append(buffer[15]);


                  quint8 pulsesMode2Int = (quint8)buffer[15];
                  if(pulsesMode1List.contains(QString::number(pulsesMode2Int))) {
                      ui->comboBox_PulsesMode2->setCurrentText(QString::number(pulsesMode2Int));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
                  }

                  qDebug()<<"pulsesMode2Array.toHex() "<<pulsesMode2Array.toHex();
                  paramsVector.append(pulsesMode2Array);
                  mapRead["pulsesMode2ByteArray"] = pulsesMode2Array;

                  //
                  //pulsesValue1
                  QByteArray pulsesValue1Array;
                  pulsesValue1Array.append(buffer[16]);
                  pulsesValue1Array.append(buffer[17]);


                  quint16 pulsesValue1Int = buffer[16];
                  pulsesValue1Int = pulsesValue1Int<<8 | (quint8)buffer[17];
    //              if((pulsesValue1Int<=101) && (pulsesValue1Int>=99)) {

    //              }
                  ui->lineEdit_PulsesValue1->setText(QString::number(pulsesValue1Int));

                  qDebug()<<"pulsesValue1Array.toHex() "<<pulsesValue1Array.toHex();
                  paramsVector.append(pulsesValue1Array);
                  mapRead["pulsesValue1ByteArray"] = pulsesValue1Array;

                  //
                  //pulsesValue2
                  QByteArray pulsesValue2Array;
                  pulsesValue2Array.append(buffer[18]);
                  pulsesValue2Array.append(buffer[19]);
                  qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();

                  quint16 pulsesValue2Int = buffer[18];
                  pulsesValue2Int = pulsesValue2Int<<8 | (quint8)buffer[19];
                  ui->lineEdit_PulsesValue2->setText(QString::number(pulsesValue2Int));

                  qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();
                  paramsVector.append(pulsesValue2Array);
                  mapRead["pulsesValue2ByteArray"] = pulsesValue2Array;

                  //
                  //DevType
                  QByteArray devType;
                  devType.append(buffer[20]);

                  if(devType[0] == 0x04) {
                      ui->comboBox_DevType->setCurrentText("Обратный");
                  }

                  if(devType[0] == 0x0c) {
                      ui->comboBox_DevType->setCurrentText("Подающий");
                  }

                  if((devType[0] != 0x04) && (devType[0] != 0x0c) ) {
//                      QMessageBox::information(this, "", tr("Недопустимое значение: Тип счётчика") + ". Рабочее место: "
//                                               + QString::number(workPlaceNumber + 1));
                      ui->label_StatusBar->setText(tr("Недопустимое значение: Тип счётчика") + ". Рабочее место: "
                                                   + QString::number(workPlaceNumber + 1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkPulsesOutputDefault(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                  }

                  qDebug()<<"devType.toHex() "<<devType.toHex();
                  paramsVector.append(devType);
                  mapRead["devType"] = devType;



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка данных") + ". Рабочее место: "
//                                               + QString::number(workPlaceNumber + 1));
                      ui->label_StatusBar->setText(tr("Ошибка данных") + ". Рабочее место: "
                                                   + QString::number(workPlaceNumber + 1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
         //             ui->label_pulsesOutputOff->setVisible(true);
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkPulsesOutputDefault(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }

           }


        }



        QVector<QByteArray> writeVector;
        writeVector.append(mapwrite["flowMinByteArray"]);
        writeVector.append(mapwrite["flowMaxByteArray"]);
        writeVector.append(mapwrite["tinMinByteArray"]);
        writeVector.append(mapwrite["tinMaxByteArray"]);
        writeVector.append(mapwrite["toutMinByteArray"]);
        writeVector.append(mapwrite["toutMaxByteArray"]);
        writeVector.append(mapwrite["reportDataByteArray"]);
        writeVector.append(mapwrite["averageTByteArray"]);
        writeVector.append(mapwrite["pulsesMode1ByteArray"]);
        writeVector.append(mapwrite["pulsesMode2ByteArray"]);
        writeVector.append(mapwrite["pulsesValue1ByteArray"]);
        writeVector.append(mapwrite["pulsesValue2ByteArray"]);

        QVector<QByteArray> readVector;
        readVector.append(mapRead["flowMinByteArray"]);
        readVector.append(mapRead["flowMaxByteArray"]);
        readVector.append(mapRead["tinMinByteArray"]);
        readVector.append(mapRead["tinMaxByteArray"]);
        readVector.append(mapRead["toutMinByteArray"]);
        readVector.append(mapRead["toutMaxByteArray"]);
        readVector.append(mapRead["reportDataByteArray"]);
        readVector.append(mapRead["averageTByteArray"]);
        readVector.append(mapRead["pulsesMode1ByteArray"]);
        readVector.append(mapRead["pulsesMode2ByteArray"]);
        readVector.append(mapRead["pulsesValue1ByteArray"]);
        readVector.append(mapRead["pulsesValue2ByteArray"]);

        for(int i=0; i<allParamsNameList.size(); i++) {
            qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
            qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();
        }

        for(int i=0; i<writeVector.size(); i++) {


            if((i == (writeVector.size() - 2)) || (i == (writeVector.size() - 1))) {
                int paramRead = (quint8)(readVector[i][0]);
                paramRead = paramRead<<8 | (quint8)(readVector[i][1]);

                int paramWrite = (quint8)(writeVector[i][0]);
                paramWrite = paramWrite<<8 | (quint8)(writeVector[i][1]);

                if((paramRead >= (paramWrite - 1)) && (paramRead <= (paramWrite + 1))) {

                }
                else {
//                    QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
//                                             " " + "чтение " + readVector[i].toHex() + ". Рабочее место: "
//                                             + QString::number(workPlaceNumber + 1));
                    ui->label_StatusBar->setText("Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                                 " " + "чтение " + readVector[i].toHex() + ". Рабочее место: "
                                                 + QString::number(workPlaceNumber + 1));
                    errorString.append(ui->label_StatusBar->text() + '\n');
      //              ui->label_pulsesOutputOff->setVisible(true);
                    vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                    checkPulsesOutputDefault(currentIndicatorNumber);
                    workPlaceOff(currentIndicatorNumber);
                    return;
                }
            }
            else {
                    if((readVector[i] != writeVector[i]) && (i != (writeVector.size() - 2)) && (i != (writeVector.size() - 1)) ) {
//                       QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
//                                             " " + "чтение " + readVector[i].toHex() + ". Рабочее место: "
//                                                + QString::number(workPlaceNumber + 1));
                       ui->label_StatusBar->setText("Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                                    " " + "чтение " + readVector[i].toHex() + ". Рабочее место: "
                                                       + QString::number(workPlaceNumber + 1));
                       errorString.append(ui->label_StatusBar->text() + '\n');
          //             ui->label_pulsesOutputOff->setVisible(true);
                       vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                       checkPulsesOutputDefault(currentIndicatorNumber);
                       workPlaceOff(currentIndicatorNumber);
                       return;
                    }
            }
        }


        ui->label_pulsesOutputOff->setStyleSheet(QString("color: green").arg(color.name()));
        ui->label_pulsesOutputOff->setText("V");
    //    ui->label_pulsesOutputOff->setVisible(true);


        checkPulsesOutputDefault(currentIndicatorNumber);


}

void MainWindow::on_toolButton_pulsesOutputOff_clicked()
{
    ui->label_StatusBar->setText("");

    QColor color(255, 127, 50);
    ui->label_pulsesOutputOff->setStyleSheet(QString("color: red").arg(color.name()));
    ui->label_pulsesOutputOff->setText("X");
    ui->label_pulsesOutputOff->setVisible(false);

    pulsesMode1ByteArray.clear();
    pulsesMode2ByteArray.clear();

    pulsesMode1ByteArray.append(pulsesMode1PrimalInt); //append(byte);
    pulsesMode2ByteArray.append(pulsesMode2PrimalInt); //append(byte);


    if(pulsesValue1PrimeInt == 0) {
        QMessageBox::information(this, "", tr("Недоустимое значение pulsesvalue1 ") + QString::number(pulsesValue1PrimeInt));
        return;
    }
    if(pulsesValue2PrimeInt == 0) {
        QMessageBox::information(this, "", tr("Недоустимое значение pulsesvalue2 ") + QString::number(pulsesValue2PrimeInt));
        return;
    }
    pulsesValue1ByteArray.clear();
    pulsesValue2ByteArray.clear();
    pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt>>8));
    pulsesValue1ByteArray.append((quint8)(pulsesValue1PrimeInt));

    pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt>>8));
    pulsesValue2ByteArray.append((quint8)(pulsesValue2PrimeInt));

    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
            return;
        }
    }

    //одна команда Write Software Configuration с открытием парольной сессии

    //Открыть парольную сессию 5a 00 08 40 01 04 57
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x08;
       packetToRead.append(byte);
       byte = 0x40;
       packetToRead.append(byte);
       byte = 0x01;
       packetToRead.append(byte);
       byte = 0x04;
       packetToRead.append(byte);
       byte = 0x57;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
               ui->label_pulsesOutputOff->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xc0;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);


              //
              //



              break;
           }
           else {
                    if(i==2) {
                        QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
                        ui->label_pulsesOutputOff->setVisible(true);
                        return;
                    }

           }



       }


    }

    //
    //Write Software Configuration 5a 00 16 20
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x16;
       packetToRead.append(byte);
       byte = 0x20;
       packetToRead.append(byte);

       byte = flowMinByteArray[0];
       packetToRead.append(byte);
       byte = flowMinByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowMinByteArray);
       mapwrite["flowMinByteArray"] = flowMinByteArray;


       byte = flowMaxByteArray[0];
       packetToRead.append(byte);
       byte = flowMaxByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(flowMaxByteArray);
       mapwrite["flowMaxByteArray"] = flowMaxByteArray;


       byte = tinMinByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(tinMinByteArray);
       mapwrite["tinMinByteArray"] = tinMinByteArray;


       byte = tinMaxByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(tinMaxByteArray);
       mapwrite["tinMaxByteArray"] = tinMaxByteArray;


       byte = toutMinByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(toutMinByteArray);
       mapwrite["toutMinByteArray"] = toutMinByteArray;


       byte = toutMaxByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(toutMaxByteArray);
       mapwrite["toutMaxByteArray"] = toutMaxByteArray;


       byte = reportDataByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(reportDataByteArray);
       mapwrite["reportDataByteArray"] = reportDataByteArray;


       byte = averageTByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(averageTByteArray);
       mapwrite["averageTByteArray"] = averageTByteArray;


       byte = pulsesMode1ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesMode1ByteArray);
       mapwrite["pulsesMode1ByteArray"] = pulsesMode1ByteArray;


       byte = pulsesMode2ByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesMode2ByteArray);
       mapwrite["pulsesMode2ByteArray"] = pulsesMode2ByteArray;


       byte = pulsesValue1ByteArray[0];
       packetToRead.append(byte);
       byte = pulsesValue1ByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesValue1ByteArray);
       mapwrite["pulsesValue1ByteArray"] = pulsesValue1ByteArray;


       byte = pulsesValue2ByteArray[0];
       packetToRead.append(byte);
       byte = pulsesValue2ByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(pulsesValue2ByteArray);
       mapwrite["pulsesValue2ByteArray"] = pulsesValue2ByteArray;

       byte = devType[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(devType);
       mapwrite["devType"] = devType;

       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось записать данные : Software Configuration"));
               ui->label_pulsesOutputOff->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xa0;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных : Software Configuration"));
                  ui->label_pulsesOutputOff->setVisible(true);
                  return;
               }
           }



       }


    }


    //
    //Read Software Configuration 5a000502
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x02;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
               ui->label_pulsesOutputOff->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x16;
           bytesForChecking.append(byte);
           byte = 0x82;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
//              ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

              emit sendbufferReadSoftWareConfiguration(buffer);

              //
              //flowMin
              QByteArray flowMinArray;
              flowMinArray.append(buffer[4]);
              flowMinArray.append(buffer[5]);
 //             ui->lineEdit_Flow_min->setText(flowMinArray.toHex());

 //             float flowMinFloat = buffer[4];
              quint16 flowMinQuint16 = buffer[4];
              flowMinQuint16 = flowMinQuint16<<8 | buffer[5];
              float flowMinFloat = (float)flowMinQuint16/1000;
              if(flowMinFloat>=0 && flowMinFloat<=0.2) {
                  ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальный расход"));
                  ui->lineEdit_Flow_min->setText(QString::number(flowMinFloat));
              }

              qDebug()<<"flowMinArray.toHex() "<<flowMinArray.toHex();
              paramsVector.append(flowMinArray);
              mapRead["flowMinByteArray"] = flowMinArray;

              //
              //flowMax
              QByteArray flowMaxArray;
              flowMaxArray.append(buffer[6]);
              flowMaxArray.append(buffer[7]);

 //             float flowMaxFloat = buffer[6];
              quint16 flowMaxQuint16 = buffer[6];
              flowMaxQuint16 = (flowMaxQuint16<<8) | (quint8)(buffer.at(7));
              float flowMaxFloat = flowMaxQuint16;
              flowMaxFloat = flowMaxFloat/1000;
              if(flowMaxFloat>=2 && flowMaxFloat<=5) {
                  ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальный расход"));
                  ui->lineEdit_Flow_max->setText(QString::number(flowMaxFloat));
              }

              qDebug()<<"flowMaxArray.toHex() "<<flowMaxArray.toHex();
              paramsVector.append(flowMaxArray);
              mapRead["flowMaxByteArray"] = flowMaxArray;

              //
              //tinMin
              QByteArray tinMinArray;
              tinMinArray.append(buffer[8]);


              quint8 tinMinQuint8 = buffer[8];
              if(tinMinQuint8>=10 && tinMinQuint8<=60) {
                  ui->spinBox_Tin_min->setValue(tinMinQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура подачи"));
              }

              qDebug()<<"tinMinArray.toHex() "<<tinMinArray.toHex();
              paramsVector.append(tinMinArray);
              mapRead["tinMinByteArray"] = tinMinArray;

              //
              //tinMax
              QByteArray tinMaxArray;
              tinMaxArray.append(buffer[9]);


              quint8 tinMaxQuint8 = buffer[9];
              if(tinMaxQuint8>=50 && tinMaxQuint8<=150) {
                  ui->spinBox_Tin_max->setValue(tinMaxQuint8);
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура подачи"));
              }

              qDebug()<<"tinMaxArray.toHex() "<<tinMaxArray.toHex();
              paramsVector.append(tinMaxArray);
              mapRead["tinMaxByteArray"] = tinMaxArray;

              //
              //toutMin
              QByteArray toutMinArray;
              toutMinArray.append(buffer[10]);

              quint8 toutMinQuint8 = buffer[10];
              if(toutMinQuint8>=10 && toutMinQuint8<=60) {
                  ui->spinBox_Tout_min->setValue(toutMinQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Минимальная температура обратки"));
              }

              qDebug()<<"toutMinArray.toHex() "<<toutMinArray.toHex();
              paramsVector.append(toutMinArray);
              mapRead["toutMinByteArray"] = toutMinArray;


              //
              //toutMax
              QByteArray toutMaxArray;
              toutMaxArray.append(buffer[11]);

              quint8 toutMaxQuint8 = buffer[11];
              if(toutMaxQuint8>=50 && toutMaxQuint8<=150) {
                  ui->spinBox_Tout_max->setValue(toutMaxQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Максимальная температура обратки"));
              }

              qDebug()<<"toutMaxArray.toHex() "<<toutMaxArray.toHex();
              paramsVector.append(toutMaxArray);
              mapRead["toutMaxByteArray"] = toutMaxArray;

              //
              //reportData
              QByteArray reportDataArray;
              reportDataArray.append(buffer[12]);

              quint8 reportDataInt = buffer[12];
              if(reportDataInt>=0 && reportDataInt<=31) {
                  ui->spinBox_ReportData->setValue(reportDataInt);
              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: Дата сохранения в журнал"));
              }

              qDebug()<<"reportDataArray.toHex() "<<reportDataArray.toHex();
              paramsVector.append(reportDataArray);
              mapRead["reportDataByteArray"] = reportDataArray;

              //
              //AverageT
              QByteArray AverageTArray;
              AverageTArray.append(buffer[13]);


              quint8 AverageTInt = buffer[13];
              if(AverageTList.contains(QString::number(AverageTInt))) {
                  ui->comboBox_Average_T->setCurrentText(QString::number(AverageTInt));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Тип усреднения температуры"));
              }

              qDebug()<<"AverageTArray.toHex() "<<AverageTArray.toHex();
              paramsVector.append(AverageTArray);
              mapRead["averageTByteArray"] = AverageTArray;

              //
              //pulsesMode1
              QByteArray pulsesMode1Array;
              pulsesMode1Array.append(buffer[14]);


              quint8 pulsesMode1Int = (quint8)buffer[14];
              if(pulsesMode1List.contains(QString::number(pulsesMode1Int))) {
                  ui->comboBox_PulsesMode1->setCurrentText(QString::number(pulsesMode1Int));
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
              }

              qDebug()<<"pulsesMode1Array.toHex() "<<pulsesMode1Array.toHex();
              paramsVector.append(pulsesMode1Array);
              mapRead["pulsesMode1ByteArray"] = pulsesMode1Array;

              //
              //pulsesMode2
              QByteArray pulsesMode2Array;
              pulsesMode2Array.append(buffer[15]);


              quint8 pulsesMode2Int = (quint8)buffer[15];
              if(pulsesMode1List.contains(QString::number(pulsesMode2Int))) {
                  ui->comboBox_PulsesMode2->setCurrentText(QString::number(pulsesMode2Int));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Режим работы импульсного вывода"));
              }

              qDebug()<<"pulsesMode2Array.toHex() "<<pulsesMode2Array.toHex();
              paramsVector.append(pulsesMode2Array);
              mapRead["pulsesMode2ByteArray"] = pulsesMode2Array;

              //
              //pulsesValue1
              QByteArray pulsesValue1Array;
              pulsesValue1Array.append(buffer[16]);
              pulsesValue1Array.append(buffer[17]);


              quint16 pulsesValue1Int = buffer[16];
              pulsesValue1Int = pulsesValue1Int<<8 | (quint8)buffer[17];
//              if((pulsesValue1Int<=101) && (pulsesValue1Int>=99)) {

//              }
              ui->lineEdit_PulsesValue1->setText(QString::number(pulsesValue1Int));

              qDebug()<<"pulsesValue1Array.toHex() "<<pulsesValue1Array.toHex();
              paramsVector.append(pulsesValue1Array);
              mapRead["pulsesValue1ByteArray"] = pulsesValue1Array;

              //
              //pulsesValue2
              QByteArray pulsesValue2Array;
              pulsesValue2Array.append(buffer[18]);
              pulsesValue2Array.append(buffer[19]);
              qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();

              quint16 pulsesValue2Int = buffer[18];
              pulsesValue2Int = pulsesValue2Int<<8 | (quint8)buffer[19];
              ui->lineEdit_PulsesValue2->setText(QString::number(pulsesValue2Int));

              qDebug()<<"pulsesValue2Array.toHex() "<<pulsesValue2Array.toHex();
              paramsVector.append(pulsesValue2Array);
              mapRead["pulsesValue2ByteArray"] = pulsesValue2Array;

              //
              //DevType
              QByteArray devType;
              devType.append(buffer[20]);

              if(devType[0] == 0x04) {
                  ui->comboBox_DevType->setCurrentText("Обратный");
              }

              if(devType[0] == 0x0c) {
                  ui->comboBox_DevType->setCurrentText("Подающий");
              }

              if((devType[0] != 0x04) && (devType[0] != 0x0c) ) {
                  QMessageBox::information(this, "", tr("Недопустимое значение: Тип счётчика"));
              }

              qDebug()<<"devType.toHex() "<<devType.toHex();
              paramsVector.append(devType);
              mapRead["devType"] = devType;



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
                  ui->label_pulsesOutputOff->setVisible(true);
                  return;
               }
           }

       }


    }



    QVector<QByteArray> writeVector;
    writeVector.append(mapwrite["flowMinByteArray"]);
    writeVector.append(mapwrite["flowMaxByteArray"]);
    writeVector.append(mapwrite["tinMinByteArray"]);
    writeVector.append(mapwrite["tinMaxByteArray"]);
    writeVector.append(mapwrite["toutMinByteArray"]);
    writeVector.append(mapwrite["toutMaxByteArray"]);
    writeVector.append(mapwrite["reportDataByteArray"]);
    writeVector.append(mapwrite["averageTByteArray"]);
    writeVector.append(mapwrite["pulsesMode1ByteArray"]);
    writeVector.append(mapwrite["pulsesMode2ByteArray"]);
    writeVector.append(mapwrite["pulsesValue1ByteArray"]);
    writeVector.append(mapwrite["pulsesValue2ByteArray"]);

    QVector<QByteArray> readVector;
    readVector.append(mapRead["flowMinByteArray"]);
    readVector.append(mapRead["flowMaxByteArray"]);
    readVector.append(mapRead["tinMinByteArray"]);
    readVector.append(mapRead["tinMaxByteArray"]);
    readVector.append(mapRead["toutMinByteArray"]);
    readVector.append(mapRead["toutMaxByteArray"]);
    readVector.append(mapRead["reportDataByteArray"]);
    readVector.append(mapRead["averageTByteArray"]);
    readVector.append(mapRead["pulsesMode1ByteArray"]);
    readVector.append(mapRead["pulsesMode2ByteArray"]);
    readVector.append(mapRead["pulsesValue1ByteArray"]);
    readVector.append(mapRead["pulsesValue2ByteArray"]);

    for(int i=0; i<allParamsNameList.size(); i++) {
        qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
        qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();
    }

    for(int i=0; i<writeVector.size(); i++) {


        if((i == (writeVector.size() - 2)) || (i == (writeVector.size() - 1))) {
            int paramRead = (quint8)(readVector[i][0]);
            paramRead = paramRead<<8 | (quint8)(readVector[i][1]);

            int paramWrite = (quint8)(writeVector[i][0]);
            paramWrite = paramWrite<<8 | (quint8)(writeVector[i][1]);

            if((paramRead >= (paramWrite - 1)) && (paramRead <= (paramWrite + 1))) {

            }
            else {
                QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                         " " + "чтение " + readVector[i].toHex());
                ui->label_pulsesOutputOff->setVisible(true);
                return;
            }
        }
        else {
                if((readVector[i] != writeVector[i]) && (i != (writeVector.size() - 2)) && (i != (writeVector.size() - 1)) ) {
                   QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                         " " + "чтение " + readVector[i].toHex());
                   ui->label_pulsesOutputOff->setVisible(true);
                   return;
                }
        }
    }


    ui->label_pulsesOutputOff->setStyleSheet(QString("color: green").arg(color.name()));
    ui->label_pulsesOutputOff->setText("V");
    ui->label_pulsesOutputOff->setVisible(true);

//    on_toolButton_writeParams_clicked();


}

void MainWindow::slotGetSerialFromParamsEdit(QString serial)
{
    ui->lineEdit_serial->setText(serial);

 //   ui->spinBox_serial->setValue(serial.toInt());
}

void MainWindow::slotGetSerial2FromParamsEdit(QString serial)
{
    ui->lineEdit_serial_2->setText(serial);

//    ui->spinBox_serial->setValue(serial.toInt());
}

void MainWindow::slotGetSerial3FromParamsEdit(QString serial)
{
    ui->lineEdit_serial_3->setText(serial);

 //   ui->spinBox_serial->setValue(serial.toInt());
}

void MainWindow::slotGetSerial4FromParamsEdit(QString serial)
{
    ui->lineEdit_serial_4->setText(serial);

  //  ui->spinBox_serial->setValue(serial.toInt());
}

void MainWindow::on_lineEdit_Error_TMeasDir_2_textChanged(const QString &arg1)
{

}

void MainWindow::on_lineEdit_Error_R_Reff1_2_textChanged(const QString &arg1)
{

}

void MainWindow::MBusOn(int workPlaceNumber)
{

    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }


    currentBoxNumber = 5;
    vectorIsErrorOccured[workPlaceNumber] = false;


        QColor color(255, 127, 50);
        ui->label_MBusOn->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_MBusOn->setText("X");
        ui->label_MBusOn->setVisible(false);

        ui->label_StatusBar->setText("");

    //    ProtTypeByteArray.clear();
    //    quint8 byte = 0;
    //    ProtTypeByteArray.append(byte);

        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
//                QMessageBox::information(this, "", "Не удалось открыть порт УСО-2. Рабочее место: " +
//                                         QString::number(workPlaceNumber + 1));
                ui->label_StatusBar->setText("Не удалось открыть порт УСО-2. Рабочее место: " +
                                             QString::number(workPlaceNumber + 1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkMbusOn(currentIndicatorNumber);
                return;
            }
        }

        //Открыть парольную сессию, Write External interface Settings

        //
        //Открыть парольную сессию 5a 00 08 40 01 04 57
        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x08;
           packetToRead.append(byte);
           byte = 0x40;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);
           byte = 0x04;
           packetToRead.append(byte);
           byte = 0x57;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " +
//                                        QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") + ". Рабочее место: " +
                                            QString::number(workPlaceNumber + 1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkMbusOn(currentIndicatorNumber);

               return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
//                   QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") + ". Рабочее место: " +
//                                            QString::number(workPlaceNumber + 1));
                   ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") + ". Рабочее место: " +
                                                QString::number(workPlaceNumber + 1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkMbusOn(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xc0;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);


                  //
                  //



                  break;
               }
               else {
                        if(i==9) {
//                            QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии") + ". Рабочее место: " +
//                                                     QString::number(workPlaceNumber + 1));
                            ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии") + ". Рабочее место: " +
                                                         QString::number(workPlaceNumber + 1));
                            errorString.append(ui->label_StatusBar->text() + '\n');
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkMbusOn(currentIndicatorNumber);
                            return;
                        }

               }



           }


        }

        //
        //
        //Write External Interface Settings 5a 00 0e 2b
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x0e;
           packetToRead.append(byte);
           byte = 0x2b;
           packetToRead.append(byte);

           byte = addrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(addrByteArray);
           mapwrite["addrByteArray"] = addrByteArray;


           byte = baudRateByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(baudRateByteArray);
           mapwrite["baudRateByteArray"] = baudRateByteArray;


           byte = HMP_TransByteArray[0];
           packetToRead.append(byte);
           byte = HMP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(HMP_TransByteArray);
           mapwrite["HMP_TransByteArray"] = HMP_TransByteArray;


           byte = EPP_TransByteArray[0];
           packetToRead.append(byte);
           byte = EPP_TransByteArray[1];
           packetToRead.append(byte);
           paramsVectorToWrite.append(EPP_TransByteArray);
           mapwrite["EPP_TransByteArray"] = EPP_TransByteArray;


           byte = P1PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P1PrimAddrByteArray);
           mapwrite["P1PrimAddrByteArray"] = P1PrimAddrByteArray;


           byte = P2PrimAddrByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(P2PrimAddrByteArray);
           mapwrite["P2PrimAddrByteArray"] = P2PrimAddrByteArray;

               //
               ProtTypeByteArray.clear();
               byte = 0;
               ProtTypeByteArray.append(byte);
               //
           byte = ProtTypeByteArray[0];
           packetToRead.append(byte);
           paramsVectorToWrite.append(ProtTypeByteArray);
           mapwrite["ProtTypeByteArray"] = ProtTypeByteArray;

           ProtTypeByteArray.clear();
           byte = 0xff;
           ProtTypeByteArray.append(byte);


           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " +
//                                                 QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") + ". Рабочее место: " +
                                            QString::number(workPlaceNumber + 1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkMbusOn(currentIndicatorNumber);
               return;
           }

           global::pause(210);//(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
     //              QMessageBox::information(this, "", tr("Не удалось записать данные : External Interface Settings"));
     //              ui->label_MBusOn->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xab;
               bytesForChecking.append(byte);

               quint8 error = buffer[4];

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка записи данных : External Interface Settings") + ". Рабочее место: " +
//                                               QString::number(workPlaceNumber + 1));
                      ui->label_StatusBar->setText(tr("Ошибка записи данных : External Interface Settings") + ". Рабочее место: " +
                                                   QString::number(workPlaceNumber + 1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkMbusOn(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }


        //
        //Read External Interface Settings 5a 00 05 1b
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x05;
           packetToRead.append(byte);
           byte = 0x1b;
           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") + ". Рабочее место: " +
//                                        QString::number(workPlaceNumber + 1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") + ". Рабочее место: " +
                                            QString::number(workPlaceNumber + 1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkMbusOn(currentIndicatorNumber);
               return;
           }

           global::pause(110);//(200);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
//                   QMessageBox::information(this, "", tr("Не удалось прочитать данные") + ". Рабочее место: " +
//                                            QString::number(workPlaceNumber + 1));
                   ui->label_StatusBar->setText(tr("Не удалось прочитать данные") + ". Рабочее место: " +
                                                QString::number(workPlaceNumber + 1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkMbusOn(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x0e;
               bytesForChecking.append(byte);
               byte = 0x9b;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);
     //             ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

                  emit sendbufferReadExternalInterfaceSettings(buffer);

                  //
                  //Addr
                  QByteArray AddrArray;
                  AddrArray.append(buffer[4]);
                  qDebug()<<"AddrArray.toHex() "<<AddrArray.toHex();

                  quint8 AddrQuint8 = (quint8)buffer[4];

                  if(AddrQuint8>=0 && AddrQuint8<=252) {
                      ui->spinBox_Addr->setValue(AddrQuint8);
                  }
                  else {
     //                 QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес счётчика "));
                      ui->spinBox_Addr->setValue(AddrQuint8);
                  }

                  paramsVector.append(AddrArray);
                  mapRead["addrByteArray"] = AddrArray;

                  //
                  //BaudRate
                  QByteArray BaudRateArray;
                  BaudRateArray.append(buffer[5]);
                  qDebug()<<"BaudRateArray.toHex() "<<BaudRateArray.toHex();

                  quint8 BaudRateQuint8 = (quint8)buffer[5];

                  for(int j=0; j< ui->comboBox_BaudRate->count(); j++) {
                      ui->comboBox_BaudRate->setCurrentIndex(j);
                      if(BaudRateQuint8 == (quint8)ui->comboBox_BaudRate->currentData().toInt()) {
                          break;
                      }

                      if(j==3 && (BaudRateQuint8 != (quint8)ui->comboBox_BaudRate->currentData().toInt())) {
                           //                 QMessageBox::information(this, "", tr("Недопустимое значение: Скорость обмена ") + QString::number(BaudRateQuint8, 16));
                      }
                  }

    //              if(BaudRateList.contains(QString::number(BaudRateQuint8, 16))) {
    //                  ui->comboBox_BaudRate->setCurrentText(QString::number(BaudRateQuint8, 16));
    //              }
    //              else {
    //   //                 QMessageBox::information(this, "", tr("Недопустимое значение: Скорость обмена ") + QString::number(BaudRateQuint8, 16));
    //              }

                  paramsVector.append(BaudRateArray);
                  mapRead["baudRateByteArray"] = BaudRateArray;

                  //
                  //HMP_Trans 2bytes  6,7
                  QByteArray HMP_TransArray;
                  HMP_TransArray.append(buffer[6]);
                  HMP_TransArray.append(buffer[7]);
                  qDebug()<<"HMP_TransArray.toHex() "<<HMP_TransArray.toHex();

                  quint16 HMP_TransInt = (quint8)buffer[6];
                  HMP_TransInt = HMP_TransInt<<8 | (quint8)buffer[7];

                  if(HMP_TransInt == 0x3fff) {
                      ui->lineEdit_HMP_Trans->setText(QString::number(HMP_TransInt, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Позиционный код передаваемых параметров HMP_Trans ") +
    //                                           QString::number(HMP_TransInt, 16));
                  }

                  paramsVector.append(HMP_TransArray);
                  mapRead["HMP_TransByteArray"] = HMP_TransArray;

                  //
                  //EPP_Trans 2bytes  8,9
                  QByteArray EPP_TransArray;
                  EPP_TransArray.append(buffer[8]);
                  EPP_TransArray.append(buffer[9]);
                  qDebug()<<"EPP_TransArray.toHex() "<<EPP_TransArray.toHex();

                  quint16 EPP_TransInt = (quint8)buffer[8];
                  EPP_TransInt = EPP_TransInt<<8 | (quint8)buffer[9];

                  if(EPP_TransInt == 0x000f) {
                      ui->lineEdit_EPP_Trans->setText(QString::number(EPP_TransInt, 16));
                  }
                  else {
      //                QMessageBox::information(this, "", tr("Недопустимое значение: Позиционный код передаваемых параметров EPP_Trans ") +
      //                                         QString::number(EPP_TransInt, 16));
                  }

                  paramsVector.append(EPP_TransArray);
                  mapRead["EPP_TransByteArray"] = EPP_TransArray;

                  //
                  //P1_PrimAddr 1byte  10
                  QByteArray P1_PrimAddrArray;
                  P1_PrimAddrArray.append(buffer[10]);
                  qDebug()<<"P1_PrimAddrArray.toHex() "<<P1_PrimAddrArray.toHex();

                  quint8 P1_PrimAddrInt = (quint8)buffer[10];

                  if(P1_PrimAddrInt>=0 && P1_PrimAddrInt<=252) {
                      ui->spinBox_P1PrimAddr->setValue(P1_PrimAddrInt);
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P1_PrimAddr ") +
    //                                           QString::number(P1_PrimAddrInt, 10));
                  }

                  paramsVector.append(P1_PrimAddrArray);
                  mapRead["P1PrimAddrByteArray"] = P1_PrimAddrArray;

                  //
                  //P2_PrimAddr 1byte  11
                  QByteArray P2_PrimAddrArray;
                  P2_PrimAddrArray.append(buffer[11]);
                  qDebug()<<"P2_PrimAddrArray.toHex() "<<P2_PrimAddrArray.toHex();

                  quint8 P2_PrimAddrInt = (quint8)buffer[11];

                  if(P2_PrimAddrInt>=0 && P2_PrimAddrInt<=252) {
                      ui->spinBox_P2PrimAddr->setValue(P2_PrimAddrInt);
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P2_PrimAddr ") +
    //                                           QString::number(P2_PrimAddrInt, 10));
                  }

                  paramsVector.append(P2_PrimAddrArray);
                  mapRead["P2PrimAddrByteArray"] = P2_PrimAddrArray;

                  //
                  //ProtType 1byte  12
                  QByteArray ProtTypeArray;
                  ProtTypeArray.append(buffer[12]);
                  qDebug()<<"ProtTypeArray.toHex() "<<ProtTypeArray.toHex();

                  quint8 ProtTypeInt = (quint8)buffer[12];

                  if(ProtTypeInt == 0xff) {
                      ui->lineEdit_ProtType->setText(QString::number(ProtTypeInt, 16));
                  }
                  else {
    //                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P2_PrimAddr ") +
    //                                           QString::number(ProtTypeInt, 16));
                  }

                  paramsVector.append(ProtTypeArray);
                  mapRead["ProtTypeByteArray"] = ProtTypeArray;




                  break;
               }
               else {
                   if(i==2) {
//                      QMessageBox::information(this, "", tr("Ошибка данных") + ". Рабочее место: " +
//                                               QString::number(workPlaceNumber + 1));
                      ui->label_StatusBar->setText(tr("Ошибка данных") + ". Рабочее место: " +
                                                   QString::number(workPlaceNumber + 1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkMbusOn(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }




//        QVector<QByteArray> writeVector;
//        writeVector.append(mapwrite["addrByteArray"]);
//        writeVector.append(mapwrite["baudRateByteArray"]);
//        writeVector.append(mapwrite["HMP_TransByteArray"]);
//        writeVector.append(mapwrite["EPP_TransByteArray"]);
//        writeVector.append(mapwrite["P1PrimAddrByteArray"]);
//        writeVector.append(mapwrite["P2PrimAddrByteArray"]);
//        writeVector.append(mapwrite["ProtTypeByteArray"]);

//        QVector<QByteArray> readVector;
//        readVector.append(mapRead["addrByteArray"]);
//        readVector.append(mapRead["baudRateByteArray"]);
//        readVector.append(mapRead["HMP_TransByteArray"]);
//        readVector.append(mapRead["EPP_TransByteArray"]);
//        readVector.append(mapRead["P1PrimAddrByteArray"]);
//        readVector.append(mapRead["P2PrimAddrByteArray"]);
//        readVector.append(mapRead["ProtTypeByteArray"]);


//        for(int i=0; i<allParamsNameList.size(); i++) {
//            qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
//            qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();
//        }

//        for(int i=0; i<writeVector.size(); i++) {

//                    if((readVector[i] != writeVector[i]) && (i != (writeVector.size() - 2)) && (i != (writeVector.size() - 1)) ) {
//                       QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
//                                             " " + "чтение " + readVector[i].toHex() + ". Рабочее место: " +
//                                                QString::number(workPlaceNumber + 1));
//                       ui->label_StatusBar->setText();
//                       errorString.append(ui->label_StatusBar->text() + '\n');
//                       vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
//                       checkMbusOn(currentIndicatorNumber);
//                       return;
//                    }

//        }


        ui->label_MBusOn->setStyleSheet(QString("color: green").arg(color.name()));
        ui->label_MBusOn->setText("V");
        ui->label_MBusOn->setVisible(true);


        checkMbusOn(currentIndicatorNumber);


}

void MainWindow::on_toolButton_MBusOn_clicked()
{

    QColor color(255, 127, 50);
    ui->label_MBusOn->setStyleSheet(QString("color: red").arg(color.name()));
    ui->label_MBusOn->setText("X");
    ui->label_MBusOn->setVisible(false);

    ui->label_StatusBar->setText("");

//    ProtTypeByteArray.clear();
//    quint8 byte = 0;
//    ProtTypeByteArray.append(byte);

    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
            return;
        }
    }

    //Открыть парольную сессию, Write External interface Settings

    //
    //Открыть парольную сессию 5a 00 08 40 01 04 57
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x08;
       packetToRead.append(byte);
       byte = 0x40;
       packetToRead.append(byte);
       byte = 0x01;
       packetToRead.append(byte);
       byte = 0x04;
       packetToRead.append(byte);
       byte = 0x57;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
 //              ui->label_MBusOn->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xc0;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);


              //
              //



              break;
           }
           else {
                    if(i==2) {
                        QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
  //                      ui->label_MBusOn->setVisible(true);
                        return;
                    }

           }



       }


    }

    //
    //
    //Write External Interface Settings 5a 00 0e 2b
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x0e;
       packetToRead.append(byte);
       byte = 0x2b;
       packetToRead.append(byte);

       byte = addrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(addrByteArray);
       mapwrite["addrByteArray"] = addrByteArray;


       byte = baudRateByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(baudRateByteArray);
       mapwrite["baudRateByteArray"] = baudRateByteArray;


       byte = HMP_TransByteArray[0];
       packetToRead.append(byte);
       byte = HMP_TransByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(HMP_TransByteArray);
       mapwrite["HMP_TransByteArray"] = HMP_TransByteArray;


       byte = EPP_TransByteArray[0];
       packetToRead.append(byte);
       byte = EPP_TransByteArray[1];
       packetToRead.append(byte);
       paramsVectorToWrite.append(EPP_TransByteArray);
       mapwrite["EPP_TransByteArray"] = EPP_TransByteArray;


       byte = P1PrimAddrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(P1PrimAddrByteArray);
       mapwrite["P1PrimAddrByteArray"] = P1PrimAddrByteArray;


       byte = P2PrimAddrByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(P2PrimAddrByteArray);
       mapwrite["P2PrimAddrByteArray"] = P2PrimAddrByteArray;

           //
           ProtTypeByteArray.clear();
           byte = 0;
           ProtTypeByteArray.append(byte);
           //
       byte = ProtTypeByteArray[0];
       packetToRead.append(byte);
       paramsVectorToWrite.append(ProtTypeByteArray);
       mapwrite["ProtTypeByteArray"] = ProtTypeByteArray;

       ProtTypeByteArray.clear();
       byte = 0xff;
       ProtTypeByteArray.append(byte);


       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(300);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex() " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
 //              QMessageBox::information(this, "", tr("Не удалось записать данные : External Interface Settings"));
 //              ui->label_MBusOn->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x06;
           bytesForChecking.append(byte);
           byte = 0xab;
           bytesForChecking.append(byte);

           quint8 error = buffer[4];

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && error == 0) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка записи данных : External Interface Settings"));
 //                 ui->label_MBusOn->setVisible(true);
                  return;
               }
           }



       }


    }


    //
    //Read External Interface Settings 5a 00 05 1b
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x5a;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0x05;
       packetToRead.append(byte);
       byte = 0x1b;
       packetToRead.append(byte);
       quint8 crc = makeCRC(packetToRead);
       packetToRead.append(crc);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(200);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               QMessageBox::information(this, "", tr("Не удалось прочитать данные"));
   //            ui->label_MBusOn->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета
           QByteArray bytesForChecking;
           quint8 byte = 0x5a;
           bytesForChecking.append(byte);
           byte = 0x00;
           bytesForChecking.append(byte);
           byte = 0x0e;
           bytesForChecking.append(byte);
           byte = 0x9b;
           bytesForChecking.append(byte);

           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);
 //             ui->textBrowser->append("buffer.toHex()     " + buffer.toHex());

              emit sendbufferReadExternalInterfaceSettings(buffer);

              //
              //Addr
              QByteArray AddrArray;
              AddrArray.append(buffer[4]);
              qDebug()<<"AddrArray.toHex() "<<AddrArray.toHex();

              quint8 AddrQuint8 = (quint8)buffer[4];

              if(AddrQuint8>=0 && AddrQuint8<=252) {
                  ui->spinBox_Addr->setValue(AddrQuint8);
              }
              else {
 //                 QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес счётчика "));
                  ui->spinBox_Addr->setValue(AddrQuint8);
              }

              paramsVector.append(AddrArray);
              mapRead["addrByteArray"] = AddrArray;

              //
              //BaudRate
              QByteArray BaudRateArray;
              BaudRateArray.append(buffer[5]);
              qDebug()<<"BaudRateArray.toHex() "<<BaudRateArray.toHex();

              quint8 BaudRateQuint8 = (quint8)buffer[5];

              for(int j=0; j< ui->comboBox_BaudRate->count(); j++) {
                  ui->comboBox_BaudRate->setCurrentIndex(j);
                  if(BaudRateQuint8 == (quint8)ui->comboBox_BaudRate->currentData().toInt()) {
                      break;
                  }

                  if(j==3 && (BaudRateQuint8 != (quint8)ui->comboBox_BaudRate->currentData().toInt())) {
                       //                 QMessageBox::information(this, "", tr("Недопустимое значение: Скорость обмена ") + QString::number(BaudRateQuint8, 16));
                  }
              }

//              if(BaudRateList.contains(QString::number(BaudRateQuint8, 16))) {
//                  ui->comboBox_BaudRate->setCurrentText(QString::number(BaudRateQuint8, 16));
//              }
//              else {
//   //                 QMessageBox::information(this, "", tr("Недопустимое значение: Скорость обмена ") + QString::number(BaudRateQuint8, 16));
//              }

              paramsVector.append(BaudRateArray);
              mapRead["baudRateByteArray"] = BaudRateArray;

              //
              //HMP_Trans 2bytes  6,7
              QByteArray HMP_TransArray;
              HMP_TransArray.append(buffer[6]);
              HMP_TransArray.append(buffer[7]);
              qDebug()<<"HMP_TransArray.toHex() "<<HMP_TransArray.toHex();

              quint16 HMP_TransInt = (quint8)buffer[6];
              HMP_TransInt = HMP_TransInt<<8 | (quint8)buffer[7];

              if(HMP_TransInt == 0x3fff) {
                  ui->lineEdit_HMP_Trans->setText(QString::number(HMP_TransInt, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Позиционный код передаваемых параметров HMP_Trans ") +
//                                           QString::number(HMP_TransInt, 16));
              }

              paramsVector.append(HMP_TransArray);
              mapRead["HMP_TransByteArray"] = HMP_TransArray;

              //
              //EPP_Trans 2bytes  8,9
              QByteArray EPP_TransArray;
              EPP_TransArray.append(buffer[8]);
              EPP_TransArray.append(buffer[9]);
              qDebug()<<"EPP_TransArray.toHex() "<<EPP_TransArray.toHex();

              quint16 EPP_TransInt = (quint8)buffer[8];
              EPP_TransInt = EPP_TransInt<<8 | (quint8)buffer[9];

              if(EPP_TransInt == 0x000f) {
                  ui->lineEdit_EPP_Trans->setText(QString::number(EPP_TransInt, 16));
              }
              else {
  //                QMessageBox::information(this, "", tr("Недопустимое значение: Позиционный код передаваемых параметров EPP_Trans ") +
  //                                         QString::number(EPP_TransInt, 16));
              }

              paramsVector.append(EPP_TransArray);
              mapRead["EPP_TransByteArray"] = EPP_TransArray;

              //
              //P1_PrimAddr 1byte  10
              QByteArray P1_PrimAddrArray;
              P1_PrimAddrArray.append(buffer[10]);
              qDebug()<<"P1_PrimAddrArray.toHex() "<<P1_PrimAddrArray.toHex();

              quint8 P1_PrimAddrInt = (quint8)buffer[10];

              if(P1_PrimAddrInt>=0 && P1_PrimAddrInt<=252) {
                  ui->spinBox_P1PrimAddr->setValue(P1_PrimAddrInt);
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P1_PrimAddr ") +
//                                           QString::number(P1_PrimAddrInt, 10));
              }

              paramsVector.append(P1_PrimAddrArray);
              mapRead["P1PrimAddrByteArray"] = P1_PrimAddrArray;

              //
              //P2_PrimAddr 1byte  11
              QByteArray P2_PrimAddrArray;
              P2_PrimAddrArray.append(buffer[11]);
              qDebug()<<"P2_PrimAddrArray.toHex() "<<P2_PrimAddrArray.toHex();

              quint8 P2_PrimAddrInt = (quint8)buffer[11];

              if(P2_PrimAddrInt>=0 && P2_PrimAddrInt<=252) {
                  ui->spinBox_P2PrimAddr->setValue(P2_PrimAddrInt);
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P2_PrimAddr ") +
//                                           QString::number(P2_PrimAddrInt, 10));
              }

              paramsVector.append(P2_PrimAddrArray);
              mapRead["P2PrimAddrByteArray"] = P2_PrimAddrArray;

              //
              //ProtType 1byte  12
              QByteArray ProtTypeArray;
              ProtTypeArray.append(buffer[12]);
              qDebug()<<"ProtTypeArray.toHex() "<<ProtTypeArray.toHex();

              quint8 ProtTypeInt = (quint8)buffer[12];

              if(ProtTypeInt == 0xff) {
                  ui->lineEdit_ProtType->setText(QString::number(ProtTypeInt, 16));
              }
              else {
//                  QMessageBox::information(this, "", tr("Недопустимое значение: Первичный адрес импульсных входов P2_PrimAddr ") +
//                                           QString::number(ProtTypeInt, 16));
              }

              paramsVector.append(ProtTypeArray);
              mapRead["ProtTypeByteArray"] = ProtTypeArray;




              break;
           }
           else {
               if(i==2) {
                  QMessageBox::information(this, "", tr("Ошибка данных"));
  //                ui->label_MBusOn->setVisible(true);
                  return;
               }
           }



       }


    }




    QVector<QByteArray> writeVector;
    writeVector.append(mapwrite["addrByteArray"]);
    writeVector.append(mapwrite["baudRateByteArray"]);
    writeVector.append(mapwrite["HMP_TransByteArray"]);
    writeVector.append(mapwrite["EPP_TransByteArray"]);
    writeVector.append(mapwrite["P1PrimAddrByteArray"]);
    writeVector.append(mapwrite["P2PrimAddrByteArray"]);
    writeVector.append(mapwrite["ProtTypeByteArray"]);

    QVector<QByteArray> readVector;
    readVector.append(mapRead["addrByteArray"]);
    readVector.append(mapRead["baudRateByteArray"]);
    readVector.append(mapRead["HMP_TransByteArray"]);
    readVector.append(mapRead["EPP_TransByteArray"]);
    readVector.append(mapRead["P1PrimAddrByteArray"]);
    readVector.append(mapRead["P2PrimAddrByteArray"]);
    readVector.append(mapRead["ProtTypeByteArray"]);


    for(int i=0; i<allParamsNameList.size(); i++) {
        qDebug()<<"Write "<<allParamsNameList[i] + " "<<mapwrite[allParamsNameList[i]].toHex();
        qDebug()<<"Read "<<allParamsNameList[i] + " "<<mapRead[allParamsNameList[i]].toHex();
    }

    for(int i=0; i<writeVector.size(); i++) {

                if((readVector[i] != writeVector[i]) && (i != (writeVector.size() - 2)) && (i != (writeVector.size() - 1)) ) {
                   QMessageBox::information(this, "", "Параметр записан некорректно: запись " + writeVector[i].toHex() +
                                         " " + "чтение " + readVector[i].toHex());
 //                  ui->label_MBusOn->setVisible(true);
                   return;
                }

    }


    ui->label_MBusOn->setStyleSheet(QString("color: green").arg(color.name()));
    ui->label_MBusOn->setText("V");
    ui->label_MBusOn->setVisible(true);

}

void MainWindow::MBusOff(int workPlaceNumber)
{
    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }


    currentBoxNumber = 9;
    vectorIsErrorOccured[workPlaceNumber] = false;

        ui->label_StatusBar->setText("");

        ProtTypeByteArray.clear();
        quint8 byte = 0;
        ProtTypeByteArray.append(byte);

        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
  //              QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
                ui->label_StatusBar->setText(tr("Не удалось открыть порт УСО-2") +
                                             ". Рабочее место: " + QString::number(workPlaceNumber+1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkMbusOff(currentIndicatorNumber);
                workPlaceOff(currentIndicatorNumber);
                return;
            }
        }



        //выключение протокола M-Bus

        portTmp->setBaudRate(QSerialPort::Baud2400);
        portTmp->setDataBits(QSerialPort::Data8);
        portTmp->setParity(QSerialPort::EvenParity);
        portTmp->setStopBits(QSerialPort::OneStop);

        //
        //
        //команда открытия парольной сессии 68 09 09 68 53 FE 51 03 FD 13 aa=0x04 aa=0x57 01

        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();

           quint8 byte = 0x68;
           packetToRead.append(byte);
           byte = 0x09;
           packetToRead.append(byte);
           byte = 0x09;
           packetToRead.append(byte);
           byte = 0x68;
           packetToRead.append(byte);
           byte = 0x53;
           packetToRead.append(byte);
           byte = 0xfe;
           packetToRead.append(byte);
           byte = 0x51;
           packetToRead.append(byte);
           byte = 0x03;
           packetToRead.append(byte);
           byte = 0xfd;
           packetToRead.append(byte);
           byte = 0x13;
           packetToRead.append(byte);
           byte = 0x57; //aa;
           packetToRead.append(byte);
           byte = 0x04; //aa;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);

           quint32 sum = 0;
           for(int j=4; j<packetToRead.size(); j++) {
               sum = sum + (quint8)packetToRead[j];
           }

           quint8 crcMod256 = (quint8)sum;
           packetToRead.append(crcMod256);
           byte = 0x16;
           packetToRead.append(byte);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
 //              QMessageBox::information(this, "", tr("Данные в порт не записаны"));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkMbusOff(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
                   portTmp->setBaudRate(QSerialPort::Baud19200);
                   portTmp->setDataBits(QSerialPort::Data8);
                   portTmp->setParity(QSerialPort::NoParity);
                   portTmp->setStopBits(QSerialPort::OneStop);
  //                 QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии по M-Bus"));
                   ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии по M-Bus") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkMbusOff(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета


               if((quint8)buffer[0] == 0xe5) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  portTmp->setBaudRate(QSerialPort::Baud19200);
                  portTmp->setDataBits(QSerialPort::Data8);
                  portTmp->setParity(QSerialPort::NoParity);
                  portTmp->setStopBits(QSerialPort::OneStop);                  

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==9) {
                      portTmp->setBaudRate(QSerialPort::Baud19200);
                      portTmp->setDataBits(QSerialPort::Data8);
                      portTmp->setParity(QSerialPort::NoParity);
                      portTmp->setStopBits(QSerialPort::OneStop);
 //                     QMessageBox::information(this, "", tr("Ошибка выключения режима M-Bus"));
                      ui->label_StatusBar->setText(tr("Ошибка открытия парольной сессии по M-Bus") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkMbusOff(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }

        //
        //
        //


        portTmp->setBaudRate(QSerialPort::Baud2400);
        portTmp->setDataBits(QSerialPort::Data8);
        portTmp->setParity(QSerialPort::EvenParity);
        portTmp->setStopBits(QSerialPort::OneStop);

        //команда изменения протокола 68 11 11 68 53 fe 51 0d 7C 04 55 4E 45 4D 06 54 45 53 74 72 50
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();

           quint8 byte = 0x68;
           packetToRead.append(byte);
           byte = 0x11;
           packetToRead.append(byte);
           byte = 0x11;
           packetToRead.append(byte);
           byte = 0x68;
           packetToRead.append(byte);
           byte = 0x53;
           packetToRead.append(byte);
           byte = 0xfe;
           packetToRead.append(byte);
           byte = 0x51;
           packetToRead.append(byte);
           byte = 0x0d;
           packetToRead.append(byte);
           byte = 0x7c;
           packetToRead.append(byte);
           byte = 0x04;
           packetToRead.append(byte);
           byte = 0x55;
           packetToRead.append(byte);
           byte = 0x4e;
           packetToRead.append(byte);
           byte = 0x45;
           packetToRead.append(byte);
           byte = 0x4d;
           packetToRead.append(byte);
           byte = 0x06;
           packetToRead.append(byte);
           byte = 0x54;
           packetToRead.append(byte);
           byte = 0x45;
           packetToRead.append(byte);
           byte = 0x53;
           packetToRead.append(byte);
           byte = 0x74;
           packetToRead.append(byte);
           byte = 0x72;
           packetToRead.append(byte);
           byte = 0x50;
           packetToRead.append(byte);

           quint32 sum = 0;
           for(int j=4; j<packetToRead.size(); j++) {
               sum = sum + (quint8)packetToRead[j];
           }

           quint8 crcMod256 = (quint8)sum;
           packetToRead.append(crcMod256);
           byte = 0x16;
           packetToRead.append(byte);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
  //             QMessageBox::information(this, "", tr("Данные в порт не записаны"));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkMbusOff(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
                   portTmp->setBaudRate(QSerialPort::Baud19200);
                   portTmp->setDataBits(QSerialPort::Data8);
                   portTmp->setParity(QSerialPort::NoParity);
                   portTmp->setStopBits(QSerialPort::OneStop);
    //               QMessageBox::information(this, "", tr("Ошибка выключения режима M-Bus"));
//                   ui->label_StatusBar->setText(tr("Ошибка выключения режима M-Bus") +
//                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
//                   errorString.append(ui->label_StatusBar->text() + '\n');
//                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
//                   checkMbusOff(currentIndicatorNumber);
//                   workPlaceOff(currentIndicatorNumber);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета


               if((quint8)buffer[0] == 0xe5) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  portTmp->setBaudRate(QSerialPort::Baud19200);
                  portTmp->setDataBits(QSerialPort::Data8);
                  portTmp->setParity(QSerialPort::NoParity);
                  portTmp->setStopBits(QSerialPort::OneStop);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
                      portTmp->setBaudRate(QSerialPort::Baud19200);
                      portTmp->setDataBits(QSerialPort::Data8);
                      portTmp->setParity(QSerialPort::NoParity);
                      portTmp->setStopBits(QSerialPort::OneStop);
   //                   QMessageBox::information(this, "", tr("Ошибка выключения режима M-Bus"));
//                      ui->label_StatusBar->setText(tr("Ошибка выключения режима M-Bus") +
//                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
//                      errorString.append(ui->label_StatusBar->text() + '\n');
//                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
//                      checkMbusOff(currentIndicatorNumber);
//                      workPlaceOff(currentIndicatorNumber);
                      return;
                   }
               }



           }


        }


        checkMbusOff(currentBoxNumber);


        portTmp->setBaudRate(QSerialPort::Baud19200);
        portTmp->setDataBits(QSerialPort::Data8);
        portTmp->setParity(QSerialPort::NoParity);
        portTmp->setStopBits(QSerialPort::OneStop);


}

void MainWindow::on_toolButton_MBusOff_clicked()
{
    ui->label_StatusBar->setText("");

    ProtTypeByteArray.clear();
    quint8 byte = 0;
    ProtTypeByteArray.append(byte);

    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт УСО-2");
            return;
        }
    }

    //
    //Установить пароль по умолчанию
//    for(int i=0; i<3;i++) {

//       portOptical->clear();
//       packetToRead.clear();
//       buffer.clear();
//       quint8 byte = 0x5a;
//       packetToRead.append(byte);
//       byte = 0x00;
//       packetToRead.append(byte);
//       byte = 0x07;
//       packetToRead.append(byte);
//       byte = 0x42;
//       packetToRead.append(byte);
//       byte = 0x23;
//       packetToRead.append(byte);
//       byte = 0x17;
//       packetToRead.append(byte);
//       quint8 crc = makeCRC(packetToRead);
//       packetToRead.append(crc);

//       quint64 cnt = portOptical->write(packetToRead);
//       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

//       qDebug()<<"cnt "<<cnt
//               <<"packetToRead.toHex() "<<packetToRead.toHex()
//               <<"portOptical->portName() "<<portOptical->portName();

//       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

//       global::pause(300);

//       buffer = portOptical->readAll();
//       qDebug()<<"buffer.toHex()"<<buffer.toHex();
//       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

//       if(buffer.isEmpty()) {
//           if(i==2) {
//               QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию"));
//               return;
//           } else{}

//       }
//       else {
//           //проверяем crc и первые четыре байта ответного пакета
//           QByteArray bytesForChecking;
//           quint8 byte = 0x5a;
//           bytesForChecking.append(byte);
//           byte = 0x00;
//           bytesForChecking.append(byte);
//           byte = 0x06;
//           bytesForChecking.append(byte);
//           byte = 0xc2;
//           bytesForChecking.append(byte);

//           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
//                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

//              qDebug()<<"buffer.toHex() "<<buffer.toHex()
//                   <<"checkCRC(buffer) "<<checkCRC(buffer);



//              //
//              //



//              break;
//           }
//           else {
//                    if(i==2) {
//                        QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию"));
//                        return;
//                    }

//           }



//       }


//    }


    //
    //Открыть парольную сессию
//    for(int i=0; i<3;i++) {

//       portOptical->clear();
//       packetToRead.clear();
//       buffer.clear();
//       quint8 byte = 0x5a;
//       packetToRead.append(byte);
//       byte = 0x00;
//       packetToRead.append(byte);
//       byte = 0x08;
//       packetToRead.append(byte);
//       byte = 0x40;
//       packetToRead.append(byte);
//       byte = 0x01;
//       packetToRead.append(byte);
//       byte = 0x04;
//       packetToRead.append(byte);
//       byte = 0x57;
//       packetToRead.append(byte);
//       quint8 crc = makeCRC(packetToRead);
//       packetToRead.append(crc);

//       quint64 cnt = portOptical->write(packetToRead);
//       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

//       qDebug()<<"cnt "<<cnt
//               <<"packetToRead.toHex() "<<packetToRead.toHex()
//               <<"portOptical->portName() "<<portOptical->portName();

//       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

//       global::pause(300);

//       buffer = portOptical->readAll();
//       qDebug()<<"buffer.toHex()"<<buffer.toHex();
//       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

//       if(buffer.isEmpty()) {
//           if(i==2) {
//               QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
//               return;
//           } else{}

//       }
//       else {
//           //проверяем crc и первые четыре байта ответного пакета
//           QByteArray bytesForChecking;
//           quint8 byte = 0x5a;
//           bytesForChecking.append(byte);
//           byte = 0x00;
//           bytesForChecking.append(byte);
//           byte = 0x06;
//           bytesForChecking.append(byte);
//           byte = 0xc0;
//           bytesForChecking.append(byte);

//           if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
//                                       bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

//              qDebug()<<"buffer.toHex() "<<buffer.toHex()
//                   <<"checkCRC(buffer) "<<checkCRC(buffer);


//              //
//              //



//              break;
//           }
//           else {
//                    if(i==2) {
//                        QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии"));
//                        return;
//                    }

//           }



//       }


//    }


    //выключение протокола M-Bus

    portOptical->setBaudRate(QSerialPort::Baud2400);
    portOptical->setDataBits(QSerialPort::Data8);
    portOptical->setParity(QSerialPort::EvenParity);
    portOptical->setStopBits(QSerialPort::OneStop);

    //
    //
    //команда открытия парольной сессии 68 09 09 68 53 FE 51 03 FD 13 aa=0x04 aa=0x57 01

    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();

       quint8 byte = 0x68;
       packetToRead.append(byte);
       byte = 0x09;
       packetToRead.append(byte);
       byte = 0x09;
       packetToRead.append(byte);
       byte = 0x68;
       packetToRead.append(byte);
       byte = 0x53;
       packetToRead.append(byte);
       byte = 0xfe;
       packetToRead.append(byte);
       byte = 0x51;
       packetToRead.append(byte);
       byte = 0x03;
       packetToRead.append(byte);
       byte = 0xfd;
       packetToRead.append(byte);
       byte = 0x13;
       packetToRead.append(byte);
       byte = 0x57; //aa;
       packetToRead.append(byte);
       byte = 0x04; //aa;
       packetToRead.append(byte);
       byte = 0x01;
       packetToRead.append(byte);

       quint32 sum = 0;
       for(int j=4; j<packetToRead.size(); j++) {
           sum = sum + (quint8)packetToRead[j];
       }

       quint8 crcMod256 = (quint8)sum;
       packetToRead.append(crcMod256);
       byte = 0x16;
       packetToRead.append(byte);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(500);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               portOptical->setBaudRate(QSerialPort::Baud19200);
               portOptical->setDataBits(QSerialPort::Data8);
               portOptical->setParity(QSerialPort::NoParity);
               portOptical->setStopBits(QSerialPort::OneStop);
               QMessageBox::information(this, "", tr("Ошибка открытия парольной сессии по M-Bus"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета


           if((quint8)buffer[0] == 0xe5) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              portOptical->setBaudRate(QSerialPort::Baud19200);
              portOptical->setDataBits(QSerialPort::Data8);
              portOptical->setParity(QSerialPort::NoParity);
              portOptical->setStopBits(QSerialPort::OneStop);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  portOptical->setBaudRate(QSerialPort::Baud19200);
                  portOptical->setDataBits(QSerialPort::Data8);
                  portOptical->setParity(QSerialPort::NoParity);
                  portOptical->setStopBits(QSerialPort::OneStop);
                  QMessageBox::information(this, "", tr("Ошибка выключения режима M-Bus"));
                  return;
               }
           }



       }


    }

    //
    //
    //


    portOptical->setBaudRate(QSerialPort::Baud2400);
    portOptical->setDataBits(QSerialPort::Data8);
    portOptical->setParity(QSerialPort::EvenParity);
    portOptical->setStopBits(QSerialPort::OneStop);

    //команда изменения протокола 68 11 11 68 53 fe 51 0d 7C 04 55 4E 45 4D 06 54 45 53 74 72 50
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();

       quint8 byte = 0x68;
       packetToRead.append(byte);
       byte = 0x11;
       packetToRead.append(byte);
       byte = 0x11;
       packetToRead.append(byte);
       byte = 0x68;
       packetToRead.append(byte);
       byte = 0x53;
       packetToRead.append(byte);
       byte = 0xfe;
       packetToRead.append(byte);
       byte = 0x51;
       packetToRead.append(byte);
       byte = 0x0d;
       packetToRead.append(byte);
       byte = 0x7c;
       packetToRead.append(byte);
       byte = 0x04;
       packetToRead.append(byte);
       byte = 0x55;
       packetToRead.append(byte);
       byte = 0x4e;
       packetToRead.append(byte);
       byte = 0x45;
       packetToRead.append(byte);
       byte = 0x4d;
       packetToRead.append(byte);
       byte = 0x06;
       packetToRead.append(byte);
       byte = 0x54;
       packetToRead.append(byte);
       byte = 0x45;
       packetToRead.append(byte);
       byte = 0x53;
       packetToRead.append(byte);
       byte = 0x74;
       packetToRead.append(byte);
       byte = 0x72;
       packetToRead.append(byte);
       byte = 0x50;
       packetToRead.append(byte);

       quint32 sum = 0;
       for(int j=4; j<packetToRead.size(); j++) {
           sum = sum + (quint8)packetToRead[j];
       }

       quint8 crcMod256 = (quint8)sum;
       packetToRead.append(crcMod256);
       byte = 0x16;
       packetToRead.append(byte);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(2000);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               portOptical->setBaudRate(QSerialPort::Baud19200);
               portOptical->setDataBits(QSerialPort::Data8);
               portOptical->setParity(QSerialPort::NoParity);
               portOptical->setStopBits(QSerialPort::OneStop);
//               QMessageBox::information(this, "", tr("Ошибка выключения режима M-Bus"));
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета


           if((quint8)buffer[0] == 0xe5) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              portOptical->setBaudRate(QSerialPort::Baud19200);
              portOptical->setDataBits(QSerialPort::Data8);
              portOptical->setParity(QSerialPort::NoParity);
              portOptical->setStopBits(QSerialPort::OneStop);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                  portOptical->setBaudRate(QSerialPort::Baud19200);
                  portOptical->setDataBits(QSerialPort::Data8);
                  portOptical->setParity(QSerialPort::NoParity);
                  portOptical->setStopBits(QSerialPort::OneStop);
                  QMessageBox::information(this, "", tr("Ошибка выключения режима M-Bus"));
                  return;
               }
           }



       }


    }



}

void MainWindow::MBusCheck(int workPlaceNumber)
{
    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }


    currentBoxNumber = 6;
    vectorIsErrorOccured[workPlaceNumber] = false;

        QColor color(255, 127, 50);
        ui->label_CheckMbus->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_CheckMbus->setText("X");
        ui->label_CheckMbus->setVisible(false);

        ui->label_StatusBar->setText("");

        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
//                QMessageBox::information(this, "", "Не удалось открыть порт" +
//                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
                ui->label_StatusBar->setText("Не удалось открыть порт. Рабочее место: " + QString::number(workPlaceNumber+1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkMbusCheck(currentIndicatorNumber);
                workPlaceOff(currentIndicatorNumber);
                return;
            }
        }



        portTmp->setBaudRate(QSerialPort::Baud2400);
        portTmp->setDataBits(QSerialPort::Data8);
        portTmp->setParity(QSerialPort::EvenParity);
        portTmp->setStopBits(QSerialPort::OneStop);


        //
        //Проверка протокола M-Bus //Проверка проводных интерфейсов 10 5B FE 59 16
        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x10;
           packetToRead.append(byte);
           byte = 0x5b;
           packetToRead.append(byte);
           byte = 0xfe;
           packetToRead.append(byte);
           byte = 0x59;
           packetToRead.append(byte);
           byte = 0x16;
           packetToRead.append(byte);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portDigitalInterfaceChecking->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                        ". Рабочее место: " + QString::number(workPlaceNumber+1));
               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkMbusCheck(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(2000);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
                   portTmp->setBaudRate(QSerialPort::Baud19200);
                   portTmp->setDataBits(QSerialPort::Data8);
                   portTmp->setParity(QSerialPort::NoParity);
                   portTmp->setStopBits(QSerialPort::OneStop);

//                   QMessageBox::information(this, "", tr("Ошибка проверки M-Bus") +
//                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   ui->label_StatusBar->setText(tr("Ошибка проверки M-Bus") +
                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkMbusCheck(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
//                   ui->label_CheckMbus->setVisible(true);
                   return;
               } else{}

           }
           else {

               int len =  (quint8)buffer[1];

               quint64 sumBytes = 0;
               for(int i=4; i<(buffer.size() - 2); i++) {
                   sumBytes = sumBytes + (quint8)buffer[i];
               }

               quint8 crcMod256 = (quint8)sumBytes;

               qDebug()<<"crcMod256 = "<<QString::number(crcMod256);

    //           Answer
    //           68	Begin Sync
    //           52	Len
    //           52	Len
    //           68	Begin Sync
    //           08	C-field
    //           Adr	Primary address
    //           72	CI-field
    //           xx	Serial
    //           xx
    //           xx
    //           xx
    //           B4	Man ID - SET
    //           4C
    //           01	Ver
    //           04 / 0C	Type
    //           xx	Num
    //           xx	Stat
    //           00	Sign
    //           00
    //           04	DIF
    //           FB	VIF
    //           0D
    //           xx	Heat energy, 1 Mcal
    //           xx
    //           xx
    //           xx
    //           04	DIF
    //           13	VIF
    //           xx	Volume, 1 l
    //           xx
    //           xx
    //           xx
    //           04	DIF
    //           1B	VIF
    //           xx	Mass, 1 kg
    //           xx
    //           xx
    //           xx
    //           02	DIF
    //           59	VIF
    //           xx	Inlet temperature,      0,01 °CInlet temperature,      0,01 °C
    //           xx
    //           02	DIF
    //           5D	VIF
    //           xx	Oulet temperature,      0,01 °COulet temperature,      0,01 °C
    //           xx
    //           02	DIF
    //           61	VIF
    //           xx	temperature differential, 10 mK
    //           xx
    //           04	DIF
    //           FD	VIF
    //           17
    //           xx	Tin_Er && Tout_Er
    //           xx	dT_Er && Flow_Er
    //           xx	Magnet state
    //           xx	CRC
    //           16	End Sync


               if(crcMod256 = buffer[buffer.size()-2]) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  portTmp->setBaudRate(QSerialPort::Baud19200);
                  portTmp->setDataBits(QSerialPort::Data8);
                  portTmp->setParity(QSerialPort::NoParity);
                  portTmp->setStopBits(QSerialPort::OneStop);

   //               ui->label_StatusBar->setText("Проверка протокола M-Bus : Успешно");
                  ui->label_CheckMbus->setStyleSheet(QString("color: green").arg(color.name()));
                  ui->label_CheckMbus->setText("V");
    //              ui->label_CheckMbus->setVisible(true);




                  break;
               }
               else {
                   if (i==2) {
                      portTmp->setBaudRate(QSerialPort::Baud19200);
                      portTmp->setDataBits(QSerialPort::Data8);
                      portTmp->setParity(QSerialPort::NoParity);
                      portTmp->setStopBits(QSerialPort::OneStop);
//                      QMessageBox::information(this, "", tr("Ошибка проверки M-Bus") +
//                                               ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      ui->label_StatusBar->setText(tr("Ошибка проверки M-Bus") +
                                                   ". Рабочее место: " + QString::number(workPlaceNumber+1));
                      errorString.append(ui->label_StatusBar->text() + '\n');
                      vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                      checkMbusCheck(currentIndicatorNumber);
                      workPlaceOff(currentIndicatorNumber);
      //                ui->label_CheckMbus->setVisible(true);
//                      ui->label_StatusBar->setText("Проверка протокола M-Bus : Неудачно. Рабочее место: " + QString::number(workPlaceNumber+1));
//                      errorString.append(ui->label_StatusBar->text() + '\n');
     //                 ui->label_CheckMbus->setVisible(true);
                      return;
                   }
               }



           }


        }


        checkMbusCheck(currentIndicatorNumber);

}

void MainWindow::on_toolButton_CheckMbus_clicked()
{
    QColor color(255, 127, 50);
    ui->label_CheckMbus->setStyleSheet(QString("color: red").arg(color.name()));
    ui->label_CheckMbus->setText("X");
    ui->label_CheckMbus->setVisible(false);

    ui->label_StatusBar->setText("");

    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт");
            return;
        }
    }



    portOptical->setBaudRate(QSerialPort::Baud2400);
    portOptical->setDataBits(QSerialPort::Data8);
    portOptical->setParity(QSerialPort::EvenParity);
    portOptical->setStopBits(QSerialPort::OneStop);


    //
    //Проверка протокола M-Bus //Проверка проводных интерфейсов 10 5B FE 59 16
    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();
       quint8 byte = 0x10;
       packetToRead.append(byte);
       byte = 0x5b;
       packetToRead.append(byte);
       byte = 0xfe;
       packetToRead.append(byte);
       byte = 0x59;
       packetToRead.append(byte);
       byte = 0x16;
       packetToRead.append(byte);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portDigitalInterfaceChecking->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(2000);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               portOptical->setBaudRate(QSerialPort::Baud19200);
               portOptical->setDataBits(QSerialPort::Data8);
               portOptical->setParity(QSerialPort::NoParity);
               portOptical->setStopBits(QSerialPort::OneStop);

               QMessageBox::information(this, "", tr("Ошибка проверки M-Bus"));
               ui->label_CheckMbus->setVisible(true);
               return;
           } else{}

       }
       else {

           int len =  (quint8)buffer[1];

           quint64 sumBytes = 0;
           for(int i=4; i<(buffer.size() - 2); i++) {
               sumBytes = sumBytes + (quint8)buffer[i];
           }

           quint8 crcMod256 = (quint8)sumBytes;

           qDebug()<<"crcMod256 = "<<QString::number(crcMod256);

//           Answer
//           68	Begin Sync
//           52	Len
//           52	Len
//           68	Begin Sync
//           08	C-field
//           Adr	Primary address
//           72	CI-field
//           xx	Serial
//           xx
//           xx
//           xx
//           B4	Man ID - SET
//           4C
//           01	Ver
//           04 / 0C	Type
//           xx	Num
//           xx	Stat
//           00	Sign
//           00
//           04	DIF
//           FB	VIF
//           0D
//           xx	Heat energy, 1 Mcal
//           xx
//           xx
//           xx
//           04	DIF
//           13	VIF
//           xx	Volume, 1 l
//           xx
//           xx
//           xx
//           04	DIF
//           1B	VIF
//           xx	Mass, 1 kg
//           xx
//           xx
//           xx
//           02	DIF
//           59	VIF
//           xx	Inlet temperature,      0,01 °CInlet temperature,      0,01 °C
//           xx
//           02	DIF
//           5D	VIF
//           xx	Oulet temperature,      0,01 °COulet temperature,      0,01 °C
//           xx
//           02	DIF
//           61	VIF
//           xx	temperature differential, 10 mK
//           xx
//           04	DIF
//           FD	VIF
//           17
//           xx	Tin_Er && Tout_Er
//           xx	dT_Er && Flow_Er
//           xx	Magnet state
//           xx	CRC
//           16	End Sync


           if(crcMod256 = buffer[buffer.size()-2]) {

              qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              portOptical->setBaudRate(QSerialPort::Baud19200);
              portOptical->setDataBits(QSerialPort::Data8);
              portOptical->setParity(QSerialPort::NoParity);
              portOptical->setStopBits(QSerialPort::OneStop);

              ui->label_StatusBar->setText("Проверка протокола M-Bus : Успешно");
              ui->label_CheckMbus->setStyleSheet(QString("color: green").arg(color.name()));
              ui->label_CheckMbus->setText("V");
              ui->label_CheckMbus->setVisible(true);




              break;
           }
           else {
               if (i==2) {
                  portOptical->setBaudRate(QSerialPort::Baud19200);
                  portOptical->setDataBits(QSerialPort::Data8);
                  portOptical->setParity(QSerialPort::NoParity);
                  portOptical->setStopBits(QSerialPort::OneStop);
                  QMessageBox::information(this, "", tr("Ошибка проверки M-Bus"));
                  ui->label_StatusBar->setText("Проверка протокола M-Bus : Неудачно");
                  ui->label_CheckMbus->setVisible(true);
                  return;
               }
           }



       }


    }

}

void MainWindow::calibrationModeOff(int workPlaceNumber)
{

    QSerialPort *portTmp;

    isNeedPaintEvent = true;//false;

    switch (workPlaceNumber) {
    case 0:
        portTmp = portOptical;
        currentIndicatorNumber = 0;
        break;
    case 1:
        portTmp = portOptical2;
        currentIndicatorNumber = 1;
        break;
    case 2:
        portTmp = portOptical3;
        currentIndicatorNumber = 2;
        break;
    case 3:
        portTmp = portOptical4;
        currentIndicatorNumber = 3;
        break;

    default:
        break;
    }


    currentBoxNumber = 7;
    vectorIsErrorOccured[workPlaceNumber] = false;



        QColor color(255, 127, 50);
        ui->label_calibrationModeOff->setStyleSheet(QString("color: red").arg(color.name()));
        ui->label_calibrationModeOff->setText("X");
        ui->label_calibrationModeOff->setVisible(false);

        ui->label_StatusBar->setText("");

        QByteArray buffer;

        if(!portTmp->isOpen()) {
            if(!portTmp->open(QIODevice::ReadWrite)) {
  //              QMessageBox::information(this, "", "Не удалось открыть порт");
                ui->label_StatusBar->setText("Не удалось открыть порт. Рабочее место: " + QString::number(workPlaceNumber+1));
                errorString.append(ui->label_StatusBar->text() + '\n');
                vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                checkCalibrationModeOff(currentIndicatorNumber);
                workPlaceOff(currentIndicatorNumber);
                return;
            }
        }


        //--------------------- Выключение режима калибровки по СЭТ --------------------
        // 5A	00	06	4C	Mode=1	CRC
        // 5A	00	06	CC	Error	CRC



        portTmp->setBaudRate(QSerialPort::Baud19200);
        portTmp->setDataBits(QSerialPort::Data8);
        portTmp->setParity(QSerialPort::NoParity);
        portTmp->setStopBits(QSerialPort::OneStop);


        //
        //Disable Calibr Mode 5a 00 06 4c 01 crc
        for(int i=0; i<10;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();
           quint8 byte = 0x5a;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0x06;
           packetToRead.append(byte);
           byte = 0x4c;
           packetToRead.append(byte);
           byte = 0x01;
           packetToRead.append(byte);
//           byte = 0x17;
//           packetToRead.append(byte);
           quint8 crc = makeCRC(packetToRead);
           packetToRead.append(crc);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны") +
//                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
//               ui->label_StatusBar->setText(tr("Данные в порт не записаны") +
//                                            ". Рабочее место: " + QString::number(workPlaceNumber+1));
//               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkCalibrationModeOff(currentIndicatorNumber);
 //              return;
           }

           global::pause(300);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==9) {
//                   QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию") +
//                                            "Рабочее место: " + QString::number(workPlaceNumber+1));
//                   ui->label_StatusBar->setText(tr("Ошибка выключения режима калибровки") +
//                                                ". Рабочее место: " + QString::number(workPlaceNumber+1));
//                   errorString.append(ui->label_StatusBar->text() + '\n');
//                   ui->label_writeParams->setVisible(true);
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkCalibrationModeOff(currentIndicatorNumber);
 //                  return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета  5A  00  06	CC	Error	CRC
               QByteArray bytesForChecking;
               quint8 byte = 0x5a;
               bytesForChecking.append(byte);
               byte = 0x00;
               bytesForChecking.append(byte);
               byte = 0x06;
               bytesForChecking.append(byte);
               byte = 0xcc;
               bytesForChecking.append(byte);

               if(checkCRC(buffer) == 0 && bytesForChecking[0] == buffer[0] && bytesForChecking[1] == buffer[1] &&
                                           bytesForChecking[2] == buffer[2] && bytesForChecking[3] == buffer[3] && buffer[4] == 0) {

                  qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);



                  //
                  //



                  break;
               }
               else {
                        if(i==9) {
//                            QMessageBox::information(this, "", tr("Ошибка установки пароля по умолчанию") +
//                                                     "Рабочее место: " + QString::number(workPlaceNumber+1));
//                            ui->label_StatusBar->setText(tr("Ошибка установки пароля по умолчанию") +
//                                                         ". Рабочее место: " + QString::number(workPlaceNumber+1));
//                            errorString.append(ui->label_StatusBar->text() + '\n');
//                            ui->label_writeParams->setVisible(true);
                            vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                            checkCalibrationModeOff(currentIndicatorNumber);
 //                           return;
                        }

               }



           }


        }


        if(vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] == false) {
            //ошибка не произошла

            checkCalibrationModeOff(currentIndicatorNumber);
            return;
        }

        //--------------------- Выключение режима калибровки по СЭТ --------------------/



        vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = false;

        //    Выключение режима "Калибровка" по M-Bus	CalibrEnable	SND-UD	Request	68	06	06	68	53 / 73	Adr		51	00	FD 15	(By4 + ... + By9) mod 256		16
        //        CalibrAcc			                                      Begin Sync Length	Length	Begin Sync	C-field	Primary address		CI-field	DIF	 VIF	           CRC		            End Sync
        //            Answer		E5


        portTmp->setBaudRate(QSerialPort::Baud2400);
        portTmp->setDataBits(QSerialPort::Data8);
        portTmp->setParity(QSerialPort::EvenParity);
        portTmp->setStopBits(QSerialPort::OneStop);


        for(int i=0; i<3;i++) {

           portTmp->clear();
           packetToRead.clear();
           buffer.clear();

           quint8 byte = 0x68;
           packetToRead.append(byte);
           byte = 0x06;
           packetToRead.append(byte);
           byte = 0x06;
           packetToRead.append(byte);
           byte = 0x68;
           packetToRead.append(byte);
           byte = 0x53;
           packetToRead.append(byte);
           byte = 0xfe;
           packetToRead.append(byte);
           byte = 0x51;
           packetToRead.append(byte);
           byte = 0x00;
           packetToRead.append(byte);
           byte = 0xfd;
           packetToRead.append(byte);
           byte = 0x15;
           packetToRead.append(byte);

           quint32 sum = 0;
           for(int j=4; j<packetToRead.size(); j++) {
               sum = sum + (quint8)packetToRead[j];
           }

           quint8 crcMod256 = (quint8)sum;
           packetToRead.append(crcMod256);
           byte = 0x16;
           packetToRead.append(byte);

           quint64 cnt = portTmp->write(packetToRead);
           ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

           qDebug()<<"cnt "<<cnt
                   <<"packetToRead.toHex() "<<packetToRead.toHex()
                   <<"portTmp->portName() "<<portTmp->portName();

           if(cnt == 0) {
//               QMessageBox::information(this, "", tr("Данные в порт не записаны"));
               ui->label_StatusBar->setText("Данные в порт не записаны. Рабочее место: " + QString::number(workPlaceNumber+1));
               errorString.append(ui->label_StatusBar->text() + '\n');
               vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
               checkCalibrationModeOff(currentIndicatorNumber);
               workPlaceOff(currentIndicatorNumber);
               return;
           }

           global::pause(2000);

           buffer = portTmp->readAll();
           qDebug()<<"buffer.toHex()"<<buffer.toHex();
           ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

           if(buffer.isEmpty()) {
               if(i==2) {
                   portTmp->setBaudRate(QSerialPort::Baud19200);
                   portTmp->setDataBits(QSerialPort::Data8);
                   portTmp->setParity(QSerialPort::NoParity);
                   portTmp->setStopBits(QSerialPort::OneStop);

 //                  QMessageBox::information(this, "", tr("Ошибка выключения режима калибровки. Рабочее место: "));
                   ui->label_StatusBar->setText(tr("Ошибка выключения режима калибровки. Рабочее место: ")
                                                + QString::number(workPlaceNumber+1));
                   errorString.append(ui->label_StatusBar->text() + '\n');
                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                   checkCalibrationModeOff(currentIndicatorNumber);
                   workPlaceOff(currentIndicatorNumber);
 //                  ui->label_calibrationModeOff->setVisible(true);
                   return;
               } else{}

           }
           else {
               //проверяем crc и первые четыре байта ответного пакета


               if((quint8)buffer[0] == 0xe5) {

                   portTmp->setBaudRate(QSerialPort::Baud19200);
                   portTmp->setDataBits(QSerialPort::Data8);
                   portTmp->setParity(QSerialPort::NoParity);
                   portTmp->setStopBits(QSerialPort::OneStop);

      //             ui->label_StatusBar->setText("Выключение режима калибровки : Успешно");
                   ui->label_calibrationModeOff->setStyleSheet(QString("color: green").arg(color.name()));
                   ui->label_calibrationModeOff->setText("V");
      //             ui->label_calibrationModeOff->setVisible(true);

                   qDebug()<<"buffer.toHex() "<<buffer.toHex()
                       <<"checkCRC(buffer) "<<checkCRC(buffer);

                  //


                  //
                  //



                  break;
               }
               else {
                   if(i==2) {
                       portTmp->setBaudRate(QSerialPort::Baud19200);
                       portTmp->setDataBits(QSerialPort::Data8);
                       portTmp->setParity(QSerialPort::NoParity);
                       portTmp->setStopBits(QSerialPort::OneStop);
 //                      QMessageBox::information(this, "", tr("Ошибка выключения режима калибровки"));
                       ui->label_StatusBar->setText(tr("Ошибка выключения режима калибровки. Рабочее место: ")
                                                    + QString::number(workPlaceNumber+1));
                       errorString.append(ui->label_StatusBar->text() + '\n');
                       vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;
                       checkCalibrationModeOff(currentIndicatorNumber);
                       workPlaceOff(currentIndicatorNumber);
//                       ui->label_calibrationModeOff->setVisible(true);
//                       ui->label_StatusBar->setText("Выключение режима калибровки : Неудачно");
//                       ui->label_calibrationModeOff->setVisible(true);
                       return;
                   }
               }



           }


        }


        checkCalibrationModeOff(currentIndicatorNumber);


}

void MainWindow::on_toolButton_calibrationModeOff_clicked()
{
//    Выключение режима "Калибровка"	CalibrEnable	SND-UD	Request	68	06	06	68	53 / 73	Adr		51	00	FD 15	(By4 + ... + By9) mod 256		16
//        CalibrAcc			                                      Begin Sync Length	Length	Begin Sync	C-field	Primary address		CI-field	DIF	 VIF	           CRC		            End Sync
//            Answer		E5

    QColor color(255, 127, 50);
    ui->label_calibrationModeOff->setStyleSheet(QString("color: red").arg(color.name()));
    ui->label_calibrationModeOff->setText("X");
    ui->label_calibrationModeOff->setVisible(false);

    ui->label_StatusBar->setText("");

    QByteArray buffer;

    if(!portOptical->isOpen()) {
        if(!portOptical->open(QIODevice::ReadWrite)) {
            QMessageBox::information(this, "", "Не удалось открыть порт");
            return;
        }
    }


    portOptical->setBaudRate(QSerialPort::Baud2400);
    portOptical->setDataBits(QSerialPort::Data8);
    portOptical->setParity(QSerialPort::EvenParity);
    portOptical->setStopBits(QSerialPort::OneStop);


    for(int i=0; i<3;i++) {

       portOptical->clear();
       packetToRead.clear();
       buffer.clear();

       quint8 byte = 0x68;
       packetToRead.append(byte);
       byte = 0x06;
       packetToRead.append(byte);
       byte = 0x06;
       packetToRead.append(byte);
       byte = 0x68;
       packetToRead.append(byte);
       byte = 0x53;
       packetToRead.append(byte);
       byte = 0xfe;
       packetToRead.append(byte);
       byte = 0x51;
       packetToRead.append(byte);
       byte = 0x00;
       packetToRead.append(byte);
       byte = 0xfd;
       packetToRead.append(byte);
       byte = 0x15;
       packetToRead.append(byte);

       quint32 sum = 0;
       for(int j=4; j<packetToRead.size(); j++) {
           sum = sum + (quint8)packetToRead[j];
       }

       quint8 crcMod256 = (quint8)sum;
       packetToRead.append(crcMod256);
       byte = 0x16;
       packetToRead.append(byte);

       quint64 cnt = portOptical->write(packetToRead);
       ui->textBrowser->append("packetOut.toHex() " + packetToRead.toHex());

       qDebug()<<"cnt "<<cnt
               <<"packetToRead.toHex() "<<packetToRead.toHex()
               <<"portOptical->portName() "<<portOptical->portName();

       if(cnt == 0) QMessageBox::information(this, "", tr("Данные в порт не записаны"));

       global::pause(2000);

       buffer = portOptical->readAll();
       qDebug()<<"buffer.toHex()"<<buffer.toHex();
       ui->textBrowser->append("buffer.toHex()       " + buffer.toHex());

       if(buffer.isEmpty()) {
           if(i==2) {
               portOptical->setBaudRate(QSerialPort::Baud19200);
               portOptical->setDataBits(QSerialPort::Data8);
               portOptical->setParity(QSerialPort::NoParity);
               portOptical->setStopBits(QSerialPort::OneStop);

               QMessageBox::information(this, "", tr("Ошибка выключения режима калибровки"));
               ui->label_calibrationModeOff->setVisible(true);
               return;
           } else{}

       }
       else {
           //проверяем crc и первые четыре байта ответного пакета


           if((quint8)buffer[0] == 0xe5) {

               portOptical->setBaudRate(QSerialPort::Baud19200);
               portOptical->setDataBits(QSerialPort::Data8);
               portOptical->setParity(QSerialPort::NoParity);
               portOptical->setStopBits(QSerialPort::OneStop);

               ui->label_StatusBar->setText("Выключение режима калибровки : Успешно");
               ui->label_calibrationModeOff->setStyleSheet(QString("color: green").arg(color.name()));
               ui->label_calibrationModeOff->setText("V");
               ui->label_calibrationModeOff->setVisible(true);

               qDebug()<<"buffer.toHex() "<<buffer.toHex()
                   <<"checkCRC(buffer) "<<checkCRC(buffer);

              //


              //
              //



              break;
           }
           else {
               if(i==2) {
                   portOptical->setBaudRate(QSerialPort::Baud19200);
                   portOptical->setDataBits(QSerialPort::Data8);
                   portOptical->setParity(QSerialPort::NoParity);
                   portOptical->setStopBits(QSerialPort::OneStop);
                   QMessageBox::information(this, "", tr("Ошибка выключения режима калибровки"));
                   ui->label_StatusBar->setText("Выключение режима калибровки : Неудачно");
                   ui->label_calibrationModeOff->setVisible(true);
                   return;
               }
           }



       }


    }

}

/*************************************************************************/
void MainWindow::saveCounterCheckingResult(int workplace, QString marker)
{
    QDateTime currentDateTime = QDateTime::currentDateTime();
    QDate currentDate = currentDateTime.date();
    QTime currentTime = currentDateTime.time();

    fileName = "Result/result_" + currentDate.toString("dd.MM.yyyy") + ".csv";

    QFile saveResult(fileName);
    if(fileName.isEmpty()) {
        return;
    }

    QString markerStr;
    if(isNoteWriting) markerStr = "";
    if(!isNoteWriting) markerStr = tr("Не записан");

    //
    //открываем файл для записи
    if(!saveResult.open(QIODevice::ReadWrite | QIODevice::Text)) {

//        QMessageBox box;
//        box.setText("Не удалось открыть файл");
//        box.exec();
//        qDebug()<<"не удалось открыть файл";
        return;

    }

    //прочитываем файл и проверяем дату
    QTextCodec* defaultTextCodec = QTextCodec::codecForName("Windows-1251");
    QTextDecoder *decoder = new QTextDecoder(defaultTextCodec);
    QString strFirst = decoder->toUnicode(saveResult.readAll());

    QString fileToString = strFirst; //saveResult.readAll();
    QStringList fileToStringList = fileToString.split('\n');
    fileToStringList.removeAt(fileToStringList.size() - 1);
    fileToStringList.removeAt(0);

    saveResult.close();

    //
    //открываем файл для очистки
    if(!saveResult.open(QIODevice::ReadWrite | QIODevice::Truncate)) {
        QMessageBox box;
        box.setText("Не удалось открыть файл");
        box.exec();
        qDebug()<<"не удалось открыть файл";
        return;
    }
    saveResult.close();

    //
    //открываем файл для записи
    if(!saveResult.open(QIODevice::ReadWrite | QIODevice::Text)) {

        QMessageBox box;
        box.setText("Не удалось открыть файл");
        box.exec();
        qDebug()<<"не удалось открыть файл";
        return;
    }

    //создаём поток записи в файл
    QFile *filePointer = &saveResult;
    QTextStream stream(filePointer);
    stream.setCodec("Windows-1251"); //("UTF-8");

    QString str = "";

    //заголовок файла
    QString strNull = "";
    stream<< "Дата/время" + strNull + ";" ;
    str = str + "Дата/время" + strNull + ";" ;
    stream<< "Маркер" + strNull + ";" ;
    str = str + "Маркер" + strNull + ";" ;
    stream<< "Серийный_номер" + strNull + ";" ;
    str = str + "Серийный_номер" + strNull + ";" ;
    stream<< "Номер_PCB" + strNull + ";" ;
    str = str + "Номер_PCB" + strNull + ";" ;
    stream<< "R_Ref1" + strNull + ";" ;
    str = str + "R_Ref1" + strNull + ";" ;
    stream<< "R_Ref2" + strNull + ";" ;
    str = str + "R_Ref2" + strNull + ";" ;
    stream<< "RTC_Offset" + strNull + ";" ;
    str = str + "RTC_Offset" + strNull + ";" ;
    stream<< "RTC_Tcomp" + strNull + ";" ;
    str = str + "RTC_Tcomp" + strNull + ";" ;
    stream<< "Годность" + strNull + ";" ;
    str = str + "Годность" + ";" ;
    stream<< "Инженер-регулировщик" + strNull + ";";
    str = str + "Инженер-регулировщик" + strNull + ";";
    stream<< "Файл_параметров" + strNull + ";" + strNull + "\n";
    str = str + "Файл_параметров" + strNull + ";" + strNull + "\n";

    //перезаписываем предыдущее содержимое
    for(int j=0; j<fileToStringList.size(); j++) {
        stream<< fileToStringList[j] + "\n";
        str = str + fileToStringList[j] + "\n";
    }


    QVector<QByteArray> resultDataFileVector;

    //
    if(ui->checkBox_workPlace1->isChecked()) {

       //сохраняем скрин экрана
//       QPixmap okno = QPixmap::grabWindow(QApplication::desktop()->winId());
//       okno.save("Screen/" + PCB_SN_ByteArray.toHex() + "_DateTime_" + currentDateTime.toString("dd_MM_yyyy__hh_mm_ss") + ".png");

       stream<< currentDateTime.toString("dd.MM.yyyy hh:mm:ss") + ";" ;
       str = str + currentDateTime.toString("dd.MM.yyyy hh:mm:ss") + ";" ;

       stream<<markerStr + ";" ;
       str = str + markerStr + ";" ;

       stream<<serialNumber.toHex() + ";" ;
       str = str + serialNumber.toHex() + ";" ;

       stream<<PCB_SN_ByteArray.toHex() + ";" ;
       str = str + PCB_SN_ByteArray.toHex() + ";" ;

       stream<<ObjectThread1->getR_Ref1_1() + ";" ;
       str = str + ObjectThread1->getR_Ref1_1() + ";" ;

       stream<< ObjectThread1->getR_Ref2_1() + ";" ;
       str = str + ObjectThread1->getR_Ref2_1() + ";" ;

       stream<< rtc_OffsetResult + ";" ;
       str = str + rtc_OffsetResult + ";" ;

       stream<< rtc_TcompResult + ";" ;
       str = str + rtc_TcompResult + ";" ;

       stream<< workPlace1ResultString + ";" ;
       str = str + workPlace1ResultString + ";" ;

       stream<<humanNameResult + ";";
       str = str + humanNameResult + ";";

       stream<< initFileNameResult + ";" + "\n";
       str = str + initFileNameResult + ";" + "\n";

    }

    if(ui->checkBox_workPlace2->isChecked()) {

       //сохраняем скрин экрана
//       QPixmap okno = QPixmap::grabWindow(QApplication::desktop()->winId());
//       okno.save("Screen/" + PCB_SN_ByteArray2.toHex() + "_DateTime_" + currentDateTime.toString("dd_MM_yyyy__hh_mm_ss") + ".png");

       stream<< currentDateTime.toString("dd.MM.yyyy hh:mm:ss") + ";" ;
       str = str + currentDateTime.toString("dd.MM.yyyy hh:mm:ss") + ";" ;

       stream<<markerStr + ";" ;
       str = str + markerStr + ";" ;

       stream<<serialNumber2.toHex() + ";" ;
       str = str + serialNumber2.toHex() + ";" ;

       stream<<PCB_SN_ByteArray2.toHex() + ";" ;
       str = str + PCB_SN_ByteArray2.toHex() + ";" ;

       stream<<ObjectThread2->getR_Ref1_2() + ";" ;
       str = str + ObjectThread2->getR_Ref1_2() + ";" ;

       stream<< ObjectThread2->getR_Ref2_2() + ";" ;
       str = str + ObjectThread2->getR_Ref2_2() + ";" ;

       stream<< rtc_OffsetResult2 + ";" ;
       str = str + rtc_OffsetResult2 + ";" ;

       stream<< rtc_TcompResult2 + ";" ;
       str = str + rtc_TcompResult2 + ";" ;

       stream<< workPlace2ResultString + ";" ;
       str = str + workPlace2ResultString + ";" ;

       stream<<humanNameResult + ";";
       str = str + humanNameResult + ";";

       stream<< initFileNameResult + ";" + "\n";
       str = str + initFileNameResult + ";" + "\n";

    }

    if(ui->checkBox_workPlace3->isChecked()) {

       //сохраняем скрин экрана
//       QPixmap okno = QPixmap::grabWindow(QApplication::desktop()->winId());
//       okno.save("Screen/" + PCB_SN_ByteArray3.toHex() + "_DateTime_" + currentDateTime.toString("dd_MM_yyyy__hh_mm_ss") + ".png");

       stream<< currentDateTime.toString("dd.MM.yyyy hh:mm:ss") + ";" ;
       str = str + currentDateTime.toString("dd.MM.yyyy hh:mm:ss") + ";" ;

       stream<<markerStr + ";" ;
       str = str + markerStr + ";" ;

       stream<<serialNumber3.toHex() + ";" ;
       str = str + serialNumber3.toHex() + ";" ;

       stream<<PCB_SN_ByteArray3.toHex() + ";" ;
       str = str + PCB_SN_ByteArray3.toHex() + ";" ;

       stream<<ObjectThread3->getR_Ref1_3() + ";" ;
       str = str + ObjectThread3->getR_Ref1_3() + ";" ;

       stream<< ObjectThread3->getR_Ref2_3() + ";" ;
       str = str + ObjectThread3->getR_Ref2_3() + ";" ;

       stream<< rtc_OffsetResult3 + ";" ;
       str = str + rtc_OffsetResult3 + ";" ;

       stream<< rtc_TcompResult3 + ";" ;
       str = str + rtc_TcompResult3 + ";" ;

       stream<< workPlace3ResultString + ";" ;
       str = str + workPlace3ResultString + ";" ;

       stream<<humanNameResult + ";";
       str = str + humanNameResult + ";";

       stream<< initFileNameResult + ";" + "\n";
       str = str + initFileNameResult + ";" + "\n";

    }

    if(ui->checkBox_workPlace4->isChecked()) {

       //сохраняем скрин экрана
//       QPixmap okno = QPixmap::grabWindow(QApplication::desktop()->winId());
//       okno.save("Screen/" + PCB_SN_ByteArray4.toHex() + "_DateTime_" + currentDateTime.toString("dd_MM_yyyy__hh_mm_ss") + ".png");

       stream<< currentDateTime.toString("dd.MM.yyyy hh:mm:ss") + ";" ;
       str = str + currentDateTime.toString("dd.MM.yyyy hh:mm:ss") + ";" ;

       stream<<markerStr + ";" ;
       str = str + markerStr + ";" ;

       stream<<serialNumber4.toHex() + ";" ;
       str = str + serialNumber4.toHex() + ";" ;

       stream<<PCB_SN_ByteArray4.toHex() + ";" ;
       str = str + PCB_SN_ByteArray4.toHex() + ";" ;

       stream<<ObjectThread4->getR_Ref1_4() + ";" ;
       str = str + ObjectThread4->getR_Ref1_4() + ";" ;

       stream<< ObjectThread4->getR_Ref2_4() + ";" ;
       str = str + ObjectThread4->getR_Ref2_4() + ";" ;

       stream<< rtc_OffsetResult4 + ";" ;
       str = str + rtc_OffsetResult4 + ";" ;

       stream<< rtc_TcompResult4 + ";" ;
       str = str + rtc_TcompResult4 + ";" ;

       stream<< workPlace4ResultString + ";" ;
       str = str + workPlace4ResultString + ";" ;

       stream<<humanNameResult + ";";
       str = str + humanNameResult + ";";

       stream<< initFileNameResult + ";" + "\n";
       str = str + initFileNameResult + ";" + "\n";

    }
    //

    QByteArray fileDataByteArray = str.toLocal8Bit();

    int sumData = 0;

    for(int i=0; i<fileDataByteArray.size(); i++) {
        sumData = sumData + (quint8)fileDataByteArray[i];
    }

    qDebug()<<"sumData "<<sumData;

    stream<< QString::number((quint8)sumData);

    saveResult.close();

}

/*******************************************************************************/

void MainWindow::on_toolButton_result_clicked()
{
    saveCounterCheckingResult(1, QString());
}
/*******************************************************************************/
void MainWindow::on_lineEdit_humanName_textEdited(const QString &arg1)
{
    humanNameResult = arg1;
}
/*******************************************************************************/
void MainWindow::on_toolButton_resultFileChecking_clicked()
{
    QMessageBox box;
    QFileDialog fileDialog;
    fileDialog.setFileMode(QFileDialog::Directory);
    QString fileName = fileDialog.getOpenFileName(this, tr("Open File"),
                                                  QDir::currentPath(),
                                                  tr("Текст (*.csv)"));
    qDebug()<<"fileName"<<fileName;

    QFile loadResult(fileName);
    if(fileName.isEmpty()) {
        return;
    }
    if(!loadResult.open(QIODevice::ReadOnly | QIODevice::Text)) {
        box.setText("Не удалось открыть файл");
        box.exec();
        qDebug()<<"не удалось открыть файл";
        return;
    }

    //
    //создаём поток записи в файл
//    QString stringFromWindowsCodec;
//    QString *stringPointer = &stringFromWindowsCodec;
//    QTextStream stream(stringPointer);
//    stream.setCodec("Windows-1251"); //("UTF-8");
//    //
//    //
//    stream<<loadResult.readAll();
//    qDebug()<<"stream "<<stream.readAll();

    QTextCodec* defaultTextCodec = QTextCodec::codecForName("Windows-1251");
    QTextDecoder *decoder = new QTextDecoder(defaultTextCodec);
    QString str = decoder->toUnicode(loadResult.readAll());



//    прочитываем файл в строку далее в лист
    QString fileToString = str; //stringFromWindowsCodec;

//    fileToString = trUtf8(fileToString); //fileToString.toUtf8();
    qDebug()<<"fileToString "<<fileToString;


    QStringList fileToStringList = fileToString.split("\n");
    QString crcMod256String = fileToStringList.last();
    quint8 crcMod256Int = crcMod256String.toInt();
    fileToStringList.removeAt(fileToStringList.size() - 1);

    fileToString = "";
    //файл-строка без crc
    for(int k=0; k<fileToStringList.size(); k++) {
        fileToString = fileToString + fileToStringList[k] + "\n";
    }

    QByteArray readAllByteArray;
    readAllByteArray.clear();
    readAllByteArray =  fileToString.toLocal8Bit();//loadResult.readAll();
    qDebug()<<"readAllByteArray.toHex() "<<readAllByteArray.toHex();

//    qDebug()<<"fileToStringList "<<fileToStringList;

//    QString endOfRaw = "\n";
//    fileToStringList[0] = fileToStringList[0] + "\n";
//    QString firstRaw = fileToStringList.at(0);
//    QByteArray sumByteArray = firstRaw.toLocal8Bit();
//    sumByteArray.append((quint8)(endOfRaw.toLocal8Bit()[0]));

//    qDebug()<<"sumByteArray.toHex() "<<sumByteArray.toHex();

    int sumData = 0;

    for(int i=0; i<readAllByteArray.size(); i++) {
        sumData = sumData + (quint8)readAllByteArray[i];
    }

    qDebug()<<"QString::number(sumData) "<<QString::number(sumData);

 //   QString crcString = fileToStringList.at(1);
    if((quint8)sumData == crcMod256Int) {
        QMessageBox::information(this, "", tr("Проверка корректности файла : Успешно"));
    }
    else {
        QMessageBox::information(this, "", tr("Проверка корректности файла : Неудачно"));
    }
}
/*******************************************************************************/
    void MainWindow::slotTimerWriteParams()
    {
        qDebug()<<"MainWindow::slotTimerWriteParams()";

        timerWriteParams.stop();

//        isNeedPaintEvent = true;

//        repaint();

//        isNeedPaintEvent = false;



//        if(((ui->label_writeParams->text() == "X") && (ui->label_writeParams->isVisible() == true))) {
//            usableResult = "Не годен";
//            on_toolButton_result_clicked();
//        }
    }
/*******************************************************************************/
    void MainWindow::slotTimerCalibration()
    {
//        timerCalibration.stop();

//        if(((ui->label_Calibration->text() == "X") && (ui->label_Calibration->isVisible() == true))) {
//            usableResult = "Не годен";
//            on_toolButton_result_clicked();
//        }

    }
/*******************************************************************************/
    void MainWindow::slotTimerPulsesOutputHeat()
    {

    }
/*******************************************************************************/
    void MainWindow::slotTimerPulsesInputVolume()
    {

    }
/*******************************************************************************/
    void MainWindow::slotTimerPulsesOutputOff()
    {

    }
/*******************************************************************************/
    void MainWindow::slotTimerCheckMbus()
    {

    }
/*******************************************************************************/
    void MainWindow::slotTimerCalibrationModeOff()
    {

    }
/*******************************************************************************/
    void MainWindow::slotTimerDigitalWireInterfaceChecking()
    {

    }
/*******************************************************************************/



void MainWindow::on_lineEdit_serial_textEdited(const QString &arg1)
{

}




void MainWindow::on_label_writeParams_windowTitleChanged(const QString &title)
{
    repaint();
}

void MainWindow::on_lineEdit_loadParamsFile_textChanged(const QString &arg1)
{

}

void MainWindow::on_toolButton_selectConfigFile_2_clicked()
{
        QMessageBox box;
        QFileDialog fileDialog;
        fileDialog.setFileMode(QFileDialog::Directory);
        QString fileName = fileDialog.getOpenFileName(this, tr("Open File"),
                                                      QDir::currentPath() + "/cfg",
                                                      tr("Текст (*.cfg)"));
        qDebug()<<"fileName"<<fileName;
        ui->lineEdit_selectConfigFile_2->setText(fileName);

        QFile loadTemplate(fileName);
        if(fileName.isEmpty()) {
            return;
        }
        if(!loadTemplate.open(QIODevice::ReadOnly | QIODevice::Text)) {
            box.setText("Не удалось открыть файл");
            box.exec();
            qDebug()<<"не удалось открыть файл";
            ui->toolButton_startCalibration->setEnabled(false);
            return;
        }
        //прочитываем файл в строку далее в лист
        QString fileToString = loadTemplate.readAll();
        qDebug()<<"fileToString"<<fileToString;
        QStringList fileToStringList;
        QString sym = "";
        for(int i=0; i<fileToString.size(); i++) {
            sym = sym + fileToString[i];
            if(fileToString[i+1] == "\n") {
     //           sym = sym + "\n";
                fileToStringList<<sym;
                sym = "";
     //           i=i+1;
            }
        }
        qDebug()<<"fileToStringList"<<fileToStringList;

        if( !fileToStringList[0].contains("R_Real1 ") || !fileToStringList[1].contains("R_Real2 ") ||
                !fileToStringList[2].contains("Temperature1_type0 ") || !fileToStringList[3].contains("Temperature2_type0 ") ||
                !fileToStringList[4].contains("Temperature1_type1 ") || !fileToStringList[5].contains("Temperature2_type1 ") ||
                !fileToStringList[6].contains("Temperature1_type2 ") || !fileToStringList[7].contains("Temperature2_type2 ") ||
                !fileToStringList[8].contains("Temperature1_type3 ") || !fileToStringList[9].contains("Temperature2_type3 ") ||
                !fileToStringList[10].contains("Acceptable_R_Ref1 ") || !fileToStringList[11].contains("Acceptable_R_Ref2 ") ||
                !fileToStringList[12].contains("Acceptable_TMeasDir ") || !fileToStringList[13].contains("Acceptable_TMeasRev ") ||
                !fileToStringList[14].contains("Error_R_Reff1 ") || !fileToStringList[15].contains("Error_R_Reff2 ") ||
                !fileToStringList[16].contains("Error_TMeasDir ") || !fileToStringList[17].contains("Error_TMeasRev ") ) {

            QMessageBox::information(this, "", "Неверный формат файла");
            ui->toolButton_startCalibration->setEnabled(false);
            return;

        }


        QString R_Real1String = fileToStringList[0];
        R_Real1String.remove("R_Real1 ");

        R_Real1ByteArray2 = on_lineEdit_R_Real1_2_textChanged(R_Real1String);
        calibrationMap["R_Real1ByteArray2"] = R_Real1ByteArray2;
        calibrationFloatMap["R_Real1Float2"] = R_Real1String.toFloat();

     //   ui->lineEdit_R_Real1_2->setText(R_Real1String);
        QString R_Real2String = fileToStringList[1];
        R_Real2String.remove("R_Real2 ");

        R_Real2ByteArray2 = on_lineEdit_R_Real1_2_textChanged(R_Real2String);
        calibrationMap["R_Real2ByteArray2"] = R_Real2ByteArray2;
        calibrationFloatMap["R_Real2Float2"] = R_Real2String.toFloat();

     //   ui->lineEdit_R_Real2_2->setText(R_Real2String);

        if(RTD_TypeInt == 0) {
            QString temperature1String = fileToStringList[2];
            temperature1String.remove("Temperature1_type0 ");

            //
    //        ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray2 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float2 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray2"] = temperature1ByteArray2;
            calibrationFloatMap["temperature1Float2"] = temperature1Float2;
            //

            QString temperature2String = fileToStringList[3];
            temperature2String.remove("Temperature2_type0 ");

            //
     //       ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray2 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float2 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray2"] = temperature2ByteArray2;
            calibrationFloatMap["temperature2Float2"] = temperature2Float2;
            //

        }
        if(RTD_TypeInt == 1) {
            QString temperature1String = fileToStringList[4];
            temperature1String.remove("Temperature1_type1 ");
            //
    //        ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray2 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float2 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray2"] = temperature1ByteArray2;
            calibrationFloatMap["temperature1Float2"] = temperature1Float2;
            //

            QString temperature2String = fileToStringList[5];
            temperature2String.remove("Temperature2_type1 ");
            //
    //        ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray2 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float2 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray2"] = temperature2ByteArray2;
            calibrationFloatMap["temperature2Float2"] = temperature2Float2;
            //
        }
        if(RTD_TypeInt == 2) {
            QString temperature1String = fileToStringList[6];
            temperature1String.remove("Temperature1_type2 ");
            //
    //        ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray2 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float2 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray2"] = temperature1ByteArray2;
            calibrationFloatMap["temperature1Float2"] = temperature1Float2;
            //

            QString temperature2String = fileToStringList[7];
            temperature2String.remove("Temperature2_type2 ");
            //
     //       ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray2 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float2 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray2"] = temperature2ByteArray2;
            calibrationFloatMap["temperature2Float2"] = temperature2Float2;
            //
        }
        if(RTD_TypeInt == 3) {
            QString temperature1String = fileToStringList[8];
            temperature1String.remove("Temperature1_type3 ");
            //
     //       ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray2 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float2 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray2"] = temperature1ByteArray2;
            calibrationFloatMap["temperature1Float2"] = temperature1Float2;
            //

            QString temperature2String = fileToStringList[9];
            temperature2String.remove("Temperature2_type3 ");
            //
     //       ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray2 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float2 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray2"] = temperature2ByteArray2;
            calibrationFloatMap["temperature2Float2"] = temperature2Float2;
            //
        }

        QStringList Acceptable_R_Ref1List = fileToStringList[10].split(' ');
        ui->lineEdit_Acceptable_R_Ref1_2->setText(Acceptable_R_Ref1List[1]);
        Acceptable_R_Ref1Float2 = Acceptable_R_Ref1List[1].toFloat();
        calibrationFloatMap["Acceptable_R_Ref1Float2"] = Acceptable_R_Ref1Float2;

        QStringList Acceptable_R_Ref2List = fileToStringList[11].split(' ');
        ui->lineEdit_Acceptable_R_Ref2_2->setText(Acceptable_R_Ref2List[1]);
        Acceptable_R_Ref2Float2 = Acceptable_R_Ref2List[1].toFloat();
        calibrationFloatMap["Acceptable_R_Ref2Float2"] = Acceptable_R_Ref2Float2;

        QStringList Acceptable_TMeasDirList = fileToStringList[12].split(' ');
        ui->lineEdit_Acceptable_TMeasDir_2->setText(Acceptable_TMeasDirList[1]);
        Acceptable_TMeasDirFloat2 = Acceptable_TMeasDirList[1].toFloat();
        calibrationFloatMap["Acceptable_TMeasDirFloat2"] = Acceptable_TMeasDirFloat2;

        QStringList Acceptable_TMeasRevList = fileToStringList[13].split(' ');
        ui->lineEdit_Acceptable_TMeasRev_2->setText(Acceptable_TMeasRevList[1]);
        Acceptable_TMeasRevFloat2 = Acceptable_TMeasRevList[1].toFloat();
        calibrationFloatMap["Acceptable_TMeasRevFloat2"] = Acceptable_TMeasRevFloat2;

        QStringList Error_R_Reff1List = fileToStringList[14].split(' ');
        ui->lineEdit_Error_R_Reff1_2->setText(Error_R_Reff1List[1]);
        Error_R_Reff1Float2 = Error_R_Reff1List[1].toFloat();
        calibrationFloatMap["Error_R_Reff1Float2"] = Error_R_Reff1Float2;

        QStringList Error_R_Reff2List = fileToStringList[15].split(' ');
        ui->lineEdit_Error_R_Reff2_2->setText(Error_R_Reff2List[1]);
        Error_R_Reff2Float2 = Error_R_Reff2List[1].toFloat();
        calibrationFloatMap["Error_R_Reff2Float2"] = Error_R_Reff2Float2;

        QStringList Error_TMeasDirList = fileToStringList[16].split(' ');
        ui->lineEdit_Error_TMeasDir_2->setText(Error_TMeasDirList[1]);
        Error_TMeasDirFloat2 = Error_TMeasDirList[1].toFloat();
        calibrationFloatMap["Error_TMeasDirFloat2"] = Error_TMeasDirFloat2;

        QStringList Error_TMeasRevList = fileToStringList[17].split(' ');
        ui->lineEdit_Error_TMeasRev_2->setText(Error_TMeasRevList[1]);
        Error_TMeasRevFloat2 = Error_TMeasRevList[1].toFloat();
        calibrationFloatMap["Error_TMeasRevFloat2"] = Error_TMeasRevFloat2;



        loadTemplate.close();

        ObjectThread2->setCalibrationMap(calibrationMap);
        ObjectThread2->setCalibrationFloatMap(calibrationFloatMap);

 //       ui->toolButton_startCalibration->setEnabled(true);

}


void MainWindow::on_toolButton_selectConfigFile_3_clicked()
{

        QMessageBox box;
        QFileDialog fileDialog;
        fileDialog.setFileMode(QFileDialog::Directory);
        QString fileName = fileDialog.getOpenFileName(this, tr("Open File"),
                                                      QDir::currentPath() + "/cfg",
                                                      tr("Текст (*.cfg)"));
        qDebug()<<"fileName"<<fileName;
        ui->lineEdit_selectConfigFile_3->setText(fileName);

        QFile loadTemplate(fileName);
        if(fileName.isEmpty()) {
            return;
        }
        if(!loadTemplate.open(QIODevice::ReadOnly | QIODevice::Text)) {
            box.setText("Не удалось открыть файл");
            box.exec();
            qDebug()<<"не удалось открыть файл";
            ui->toolButton_startCalibration->setEnabled(false);
            return;
        }
        //прочитываем файл в строку далее в лист
        QString fileToString = loadTemplate.readAll();
        qDebug()<<"fileToString"<<fileToString;
        QStringList fileToStringList;
        QString sym = "";
        for(int i=0; i<fileToString.size(); i++) {
            sym = sym + fileToString[i];
            if(fileToString[i+1] == "\n") {
     //           sym = sym + "\n";
                fileToStringList<<sym;
                sym = "";
     //           i=i+1;
            }
        }
        qDebug()<<"fileToStringList"<<fileToStringList;

        if( !fileToStringList[0].contains("R_Real1 ") || !fileToStringList[1].contains("R_Real2 ") ||
                !fileToStringList[2].contains("Temperature1_type0 ") || !fileToStringList[3].contains("Temperature2_type0 ") ||
                !fileToStringList[4].contains("Temperature1_type1 ") || !fileToStringList[5].contains("Temperature2_type1 ") ||
                !fileToStringList[6].contains("Temperature1_type2 ") || !fileToStringList[7].contains("Temperature2_type2 ") ||
                !fileToStringList[8].contains("Temperature1_type3 ") || !fileToStringList[9].contains("Temperature2_type3 ") ||
                !fileToStringList[10].contains("Acceptable_R_Ref1 ") || !fileToStringList[11].contains("Acceptable_R_Ref2 ") ||
                !fileToStringList[12].contains("Acceptable_TMeasDir ") || !fileToStringList[13].contains("Acceptable_TMeasRev ") ||
                !fileToStringList[14].contains("Error_R_Reff1 ") || !fileToStringList[15].contains("Error_R_Reff2 ") ||
                !fileToStringList[16].contains("Error_TMeasDir ") || !fileToStringList[17].contains("Error_TMeasRev ") ) {

            QMessageBox::information(this, "", "Неверный формат файла");
            ui->toolButton_startCalibration->setEnabled(false);
            return;

        }


        QString R_Real1String = fileToStringList[0];
        R_Real1String.remove("R_Real1 ");

        R_Real1ByteArray3 = on_lineEdit_R_Real1_2_textChanged(R_Real1String);
        calibrationMap["R_Real1ByteArray3"] = R_Real1ByteArray3;
        calibrationFloatMap["R_Real1Float3"] = R_Real1String.toFloat();

     //   ui->lineEdit_R_Real1_2->setText(R_Real1String);
        QString R_Real2String = fileToStringList[1];
        R_Real2String.remove("R_Real2 ");

        R_Real2ByteArray3 = on_lineEdit_R_Real1_2_textChanged(R_Real2String);
        calibrationMap["R_Real2ByteArray3"] = R_Real2ByteArray3;
        calibrationFloatMap["R_Real2Float3"] = R_Real2String.toFloat();

     //   ui->lineEdit_R_Real2_2->setText(R_Real2String);

        if(RTD_TypeInt == 0) {
            QString temperature1String = fileToStringList[2];
            temperature1String.remove("Temperature1_type0 ");

            //
    //        ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray3 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float3 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray3"] = temperature1ByteArray3;
            calibrationFloatMap["temperature1Float3"] = temperature1Float3;
            //

            QString temperature2String = fileToStringList[3];
            temperature2String.remove("Temperature2_type0 ");

            //
     //       ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray3 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float3 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray3"] = temperature2ByteArray3;
            calibrationFloatMap["temperature2Float3"] = temperature2Float3;
            //

        }
        if(RTD_TypeInt == 1) {
            QString temperature1String = fileToStringList[4];
            temperature1String.remove("Temperature1_type1 ");
            //
    //        ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray3 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float3 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray3"] = temperature1ByteArray3;
            calibrationFloatMap["temperature1Float3"] = temperature1Float3;
            //

            QString temperature2String = fileToStringList[5];
            temperature2String.remove("Temperature2_type1 ");
            //
    //        ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray3 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float3 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray3"] = temperature2ByteArray3;
            calibrationFloatMap["temperature2Float3"] = temperature2Float3;
            //
        }
        if(RTD_TypeInt == 2) {
            QString temperature1String = fileToStringList[6];
            temperature1String.remove("Temperature1_type2 ");
            //
    //        ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray3 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float3 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray3"] = temperature1ByteArray3;
            calibrationFloatMap["temperature1Float3"] = temperature1Float3;
            //

            QString temperature2String = fileToStringList[7];
            temperature2String.remove("Temperature2_type2 ");
            //
     //       ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray3 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float3 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray3"] = temperature2ByteArray3;
            calibrationFloatMap["temperature2Float3"] = temperature2Float3;
            //
        }
        if(RTD_TypeInt == 3) {
            QString temperature1String = fileToStringList[8];
            temperature1String.remove("Temperature1_type3 ");
            //
     //       ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray3 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float3 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray3"] = temperature1ByteArray3;
            calibrationFloatMap["temperature1Float3"] = temperature1Float3;
            //

            QString temperature2String = fileToStringList[9];
            temperature2String.remove("Temperature2_type3 ");
            //
     //       ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray3 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float3 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray3"] = temperature2ByteArray3;
            calibrationFloatMap["temperature2Float3"] = temperature2Float3;
            //
        }

        QStringList Acceptable_R_Ref1List = fileToStringList[10].split(' ');
        ui->lineEdit_Acceptable_R_Ref1_2->setText(Acceptable_R_Ref1List[1]);
        Acceptable_R_Ref1Float3 = Acceptable_R_Ref1List[1].toFloat();
        calibrationFloatMap["Acceptable_R_Ref1Float3"] = Acceptable_R_Ref1Float3;

        QStringList Acceptable_R_Ref2List = fileToStringList[11].split(' ');
        ui->lineEdit_Acceptable_R_Ref2_2->setText(Acceptable_R_Ref2List[1]);
        Acceptable_R_Ref2Float3 = Acceptable_R_Ref2List[1].toFloat();
        calibrationFloatMap["Acceptable_R_Ref2Float3"] = Acceptable_R_Ref2Float3;

        QStringList Acceptable_TMeasDirList = fileToStringList[12].split(' ');
        ui->lineEdit_Acceptable_TMeasDir_2->setText(Acceptable_TMeasDirList[1]);
        Acceptable_TMeasDirFloat3 = Acceptable_TMeasDirList[1].toFloat();
        calibrationFloatMap["Acceptable_TMeasDirFloat3"] = Acceptable_TMeasDirFloat3;

        QStringList Acceptable_TMeasRevList = fileToStringList[13].split(' ');
        ui->lineEdit_Acceptable_TMeasRev_2->setText(Acceptable_TMeasRevList[1]);
        Acceptable_TMeasRevFloat3 = Acceptable_TMeasRevList[1].toFloat();
        calibrationFloatMap["Acceptable_TMeasRevFloat3"] = Acceptable_TMeasRevFloat3;

        QStringList Error_R_Reff1List = fileToStringList[14].split(' ');
        ui->lineEdit_Error_R_Reff1_2->setText(Error_R_Reff1List[1]);
        Error_R_Reff1Float3 = Error_R_Reff1List[1].toFloat();
        calibrationFloatMap["Error_R_Reff1Float3"] = Error_R_Reff1Float3;

        QStringList Error_R_Reff2List = fileToStringList[15].split(' ');
        ui->lineEdit_Error_R_Reff2_2->setText(Error_R_Reff2List[1]);
        Error_R_Reff2Float3 = Error_R_Reff2List[1].toFloat();
        calibrationFloatMap["Error_R_Reff2Float3"] = Error_R_Reff2Float3;

        QStringList Error_TMeasDirList = fileToStringList[16].split(' ');
        ui->lineEdit_Error_TMeasDir_2->setText(Error_TMeasDirList[1]);
        Error_TMeasDirFloat3 = Error_TMeasDirList[1].toFloat();
        calibrationFloatMap["Error_TMeasDirFloat3"] = Error_TMeasDirFloat3;

        QStringList Error_TMeasRevList = fileToStringList[17].split(' ');
        ui->lineEdit_Error_TMeasRev_2->setText(Error_TMeasRevList[1]);
        Error_TMeasRevFloat3 = Error_TMeasRevList[1].toFloat();
        calibrationFloatMap["Error_TMeasRevFloat3"] = Error_TMeasRevFloat3;



        loadTemplate.close();

        ObjectThread3->setCalibrationMap(calibrationMap);
        ObjectThread3->setCalibrationFloatMap(calibrationFloatMap);

  //      ui->toolButton_startCalibration->setEnabled(true);

}

void MainWindow::on_toolButton_selectConfigFile_4_clicked()
{

        QMessageBox box;
        QFileDialog fileDialog;
        fileDialog.setFileMode(QFileDialog::Directory);
        QString fileName = fileDialog.getOpenFileName(this, tr("Open File"),
                                                      QDir::currentPath() + "/cfg",
                                                      tr("Текст (*.cfg)"));
        qDebug()<<"fileName"<<fileName;
        ui->lineEdit_selectConfigFile_4->setText(fileName);

        QFile loadTemplate(fileName);
        if(fileName.isEmpty()) {
            return;
        }
        if(!loadTemplate.open(QIODevice::ReadOnly | QIODevice::Text)) {
            box.setText("Не удалось открыть файл");
            box.exec();
            qDebug()<<"не удалось открыть файл";
            ui->toolButton_startCalibration->setEnabled(false);
            return;
        }
        //прочитываем файл в строку далее в лист
        QString fileToString = loadTemplate.readAll();
        qDebug()<<"fileToString"<<fileToString;
        QStringList fileToStringList;
        QString sym = "";
        for(int i=0; i<fileToString.size(); i++) {
            sym = sym + fileToString[i];
            if(fileToString[i+1] == "\n") {
     //           sym = sym + "\n";
                fileToStringList<<sym;
                sym = "";
     //           i=i+1;
            }
        }
        qDebug()<<"fileToStringList"<<fileToStringList;

        if( !fileToStringList[0].contains("R_Real1 ") || !fileToStringList[1].contains("R_Real2 ") ||
                !fileToStringList[2].contains("Temperature1_type0 ") || !fileToStringList[3].contains("Temperature2_type0 ") ||
                !fileToStringList[4].contains("Temperature1_type1 ") || !fileToStringList[5].contains("Temperature2_type1 ") ||
                !fileToStringList[6].contains("Temperature1_type2 ") || !fileToStringList[7].contains("Temperature2_type2 ") ||
                !fileToStringList[8].contains("Temperature1_type3 ") || !fileToStringList[9].contains("Temperature2_type3 ") ||
                !fileToStringList[10].contains("Acceptable_R_Ref1 ") || !fileToStringList[11].contains("Acceptable_R_Ref2 ") ||
                !fileToStringList[12].contains("Acceptable_TMeasDir ") || !fileToStringList[13].contains("Acceptable_TMeasRev ") ||
                !fileToStringList[14].contains("Error_R_Reff1 ") || !fileToStringList[15].contains("Error_R_Reff2 ") ||
                !fileToStringList[16].contains("Error_TMeasDir ") || !fileToStringList[17].contains("Error_TMeasRev ") ) {

            QMessageBox::information(this, "", "Неверный формат файла");
            ui->toolButton_startCalibration->setEnabled(false);
            return;

        }


        QString R_Real1String = fileToStringList[0];
        R_Real1String.remove("R_Real1 ");

        R_Real1ByteArray4 = on_lineEdit_R_Real1_2_textChanged(R_Real1String);
        calibrationMap["R_Real1ByteArray4"] = R_Real1ByteArray4;
        calibrationFloatMap["R_Real1Float4"] = R_Real1String.toFloat();

     //   ui->lineEdit_R_Real1_2->setText(R_Real1String);
        QString R_Real2String = fileToStringList[1];
        R_Real2String.remove("R_Real2 ");

        R_Real2ByteArray4 = on_lineEdit_R_Real1_2_textChanged(R_Real2String);
        calibrationMap["R_Real2ByteArray4"] = R_Real2ByteArray4;
        calibrationFloatMap["R_Real2Float4"] = R_Real2String.toFloat();

     //   ui->lineEdit_R_Real2_2->setText(R_Real2String);

        if(RTD_TypeInt == 0) {
            QString temperature1String = fileToStringList[2];
            temperature1String.remove("Temperature1_type0 ");

            //
    //        ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray4 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float4 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray4"] = temperature1ByteArray4;
            calibrationFloatMap["temperature1Float4"] = temperature1Float4;
            //

            QString temperature2String = fileToStringList[3];
            temperature2String.remove("Temperature2_type0 ");

            //
     //       ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray4 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float4 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray4"] = temperature2ByteArray4;
            calibrationFloatMap["temperature2Float4"] = temperature2Float4;
            //

        }
        if(RTD_TypeInt == 1) {
            QString temperature1String = fileToStringList[4];
            temperature1String.remove("Temperature1_type1 ");
            //
    //        ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray4 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float4 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray4"] = temperature1ByteArray4;
            calibrationFloatMap["temperature1Float4"] = temperature1Float4;
            //

            QString temperature2String = fileToStringList[5];
            temperature2String.remove("Temperature2_type1 ");
            //
    //        ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray4 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float4 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray4"] = temperature2ByteArray4;
            calibrationFloatMap["temperature2Float4"] = temperature2Float4;
            //
        }
        if(RTD_TypeInt == 2) {
            QString temperature1String = fileToStringList[6];
            temperature1String.remove("Temperature1_type2 ");
            //
    //        ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray4 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float4 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray4"] = temperature1ByteArray4;
            //

            QString temperature2String = fileToStringList[7];
            temperature2String.remove("Temperature2_type2 ");
            //
     //       ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray4 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float4 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray4"] = temperature2ByteArray4;
            calibrationFloatMap["temperature2Float4"] = temperature2Float4;
            //
        }
        if(RTD_TypeInt == 3) {
            QString temperature1String = fileToStringList[8];
            temperature1String.remove("Temperature1_type3 ");
            //
     //       ui->lineEdit_Temperature1_2->setText(temperature1String);

            temperature1ByteArray4 = on_lineEdit_Temperature1_2_textChanged(temperature1String);
            temperature1Float4 = temperature1String.toFloat();
            calibrationMap["temperature1ByteArray4"] = temperature1ByteArray4;
            calibrationFloatMap["temperature1Float4"] = temperature1Float4;
            //

            QString temperature2String = fileToStringList[9];
            temperature2String.remove("Temperature2_type3 ");
            //
     //       ui->lineEdit_Temperature2_2->setText(temperature2String);

            temperature2ByteArray4 = on_lineEdit_Temperature1_2_textChanged(temperature2String);
            temperature2Float4 = temperature2String.toFloat();
            calibrationMap["temperature2ByteArray4"] = temperature2ByteArray4;
            calibrationFloatMap["temperature2Float4"] = temperature2Float4;
            //
        }

        QStringList Acceptable_R_Ref1List = fileToStringList[10].split(' ');
        ui->lineEdit_Acceptable_R_Ref1_2->setText(Acceptable_R_Ref1List[1]);
        Acceptable_R_Ref1Float4 = Acceptable_R_Ref1List[1].toFloat();
        calibrationFloatMap["Acceptable_R_Ref1Float4"] = Acceptable_R_Ref1Float4;

        QStringList Acceptable_R_Ref2List = fileToStringList[11].split(' ');
        ui->lineEdit_Acceptable_R_Ref2_2->setText(Acceptable_R_Ref2List[1]);
        Acceptable_R_Ref2Float4 = Acceptable_R_Ref2List[1].toFloat();
        calibrationFloatMap["Acceptable_R_Ref2Float4"] = Acceptable_R_Ref2Float4;

        QStringList Acceptable_TMeasDirList = fileToStringList[12].split(' ');
        ui->lineEdit_Acceptable_TMeasDir_2->setText(Acceptable_TMeasDirList[1]);
        Acceptable_TMeasDirFloat4 = Acceptable_TMeasDirList[1].toFloat();
        calibrationFloatMap["Acceptable_TMeasDirFloat4"] = Acceptable_TMeasDirFloat4;

        QStringList Acceptable_TMeasRevList = fileToStringList[13].split(' ');
        ui->lineEdit_Acceptable_TMeasRev_2->setText(Acceptable_TMeasRevList[1]);
        Acceptable_TMeasRevFloat4 = Acceptable_TMeasRevList[1].toFloat();
        calibrationFloatMap["Acceptable_TMeasRevFloat4"] = Acceptable_TMeasRevFloat4;

        QStringList Error_R_Reff1List = fileToStringList[14].split(' ');
        ui->lineEdit_Error_R_Reff1_2->setText(Error_R_Reff1List[1]);
        Error_R_Reff1Float4 = Error_R_Reff1List[1].toFloat();
        calibrationFloatMap["Error_R_Reff1Float4"] = Error_R_Reff1Float4;

        QStringList Error_R_Reff2List = fileToStringList[15].split(' ');
        ui->lineEdit_Error_R_Reff2_2->setText(Error_R_Reff2List[1]);
        Error_R_Reff2Float4 = Error_R_Reff2List[1].toFloat();
        calibrationFloatMap["Error_R_Reff2Float4"] = Error_R_Reff2Float4;

        QStringList Error_TMeasDirList = fileToStringList[16].split(' ');
        ui->lineEdit_Error_TMeasDir_2->setText(Error_TMeasDirList[1]);
        Error_TMeasDirFloat4 = Error_TMeasDirList[1].toFloat();
        calibrationFloatMap["Error_TMeasDirFloat4"] = Error_TMeasDirFloat4;

        QStringList Error_TMeasRevList = fileToStringList[17].split(' ');
        ui->lineEdit_Error_TMeasRev_2->setText(Error_TMeasRevList[1]);
        Error_TMeasRevFloat4 = Error_TMeasRevList[1].toFloat();
        calibrationFloatMap["Error_TMeasRevFloat4"] = Error_TMeasRevFloat4;



        loadTemplate.close();

        ObjectThread4->setCalibrationMap(calibrationMap);
        ObjectThread4->setCalibrationFloatMap(calibrationFloatMap);

 //       ui->toolButton_startCalibration->setEnabled(true);

}

void MainWindow::on_comboBox_portListOptical_2_currentIndexChanged(const QString &arg1)
{
    portOptical2->close();
    portOptical2->setPortName(arg1);
    portNameOptical2 = arg1;

    qDebug()<<"portOptical2->portName()"<<portOptical2->portName();
}

void MainWindow::on_comboBox_portListOptical_3_currentIndexChanged(const QString &arg1)
{
    portOptical3->close();
    portOptical3->setPortName(arg1);
    portNameOptical3 = arg1;

    qDebug()<<"portOptical3->portName()"<<portOptical3->portName();
}

void MainWindow::on_comboBox_portListOptical_4_currentIndexChanged(const QString &arg1)
{
    portOptical4->close();
    portOptical4->setPortName(arg1);
    portNameOptical4 = arg1;

    qDebug()<<"portOptical4->portName()"<<portOptical4->portName();
}

void MainWindow::on_lineEdit_serial_2_textChanged(const QString &arg1)
{
    //проверка позиции курсора при вводе или удаление всех символов после него
    QString argStr = arg1;//= arg1.left(ui->lineEdit_serial_2->cursorPosition());

//    ui->lineEdit_serial_2->setText(argStr);

    //
    emit signalSendSerial2(argStr + ui->spinBox_serial_2->text());

//    manufacturerNumberResult2 = arg1;

 //   qDebug()<<"manufacturerNumberResult2 "<<manufacturerNumberResult2;
}

void MainWindow::on_lineEdit_serial_3_textChanged(const QString &arg1)
{
    //проверка позиции курсора при вводе или удаление всех символов после него
    QString argStr = arg1;//= arg1.left(ui->lineEdit_serial_3->cursorPosition());

 //   ui->lineEdit_serial_3->setText(argStr);

    //
    emit signalSendSerial3(argStr + ui->spinBox_serial_3->text());

//    manufacturerNumberResult3 = arg1;

 //   qDebug()<<"manufacturerNumberResult3 "<<manufacturerNumberResult3;
}

void MainWindow::on_lineEdit_serial_4_textChanged(const QString &arg1)
{
    //проверка позиции курсора при вводе или удаление всех символов после него
    QString argStr = arg1;// arg1.left(ui->lineEdit_serial_4->cursorPosition());

 //   ui->lineEdit_serial_4->setText(argStr);

    //
    emit signalSendSerial4(argStr + ui->spinBox_serial_4->text());

//    manufacturerNumberResult4 = arg1;

//    qDebug()<<"manufacturerNumberResult4 "<<manufacturerNumberResult4;
}

void MainWindow::on_lineEdit_selectConfigFile_textChanged(const QString &arg1)
{

}


void MainWindow::currentWorkPlaceCheckBoxOff(int workPlaceNumber)
{
    if(workPlaceNumber == 0)
        ui->checkBox_workPlace1->setChecked(false);

    if(workPlaceNumber == 1)
        ui->checkBox_workPlace2->setChecked(false);

    if(workPlaceNumber == 2)
        ui->checkBox_workPlace3->setChecked(false);

    if(workPlaceNumber == 3)
        ui->checkBox_workPlace4->setChecked(false);
}


void MainWindow::on_checkBox_workPlace1_clicked(bool checked)
{
    if(checked) {
        vectorIsWorkPlaceUse[0] = true;        
        ui->groupBox_workPlace1->setEnabled(true);
        ui->groupBox_workPlace1->setStyleSheet("QGroupBox {background-color: transparent}");
    }
    else {
        vectorIsWorkPlaceUse[0] = false;
        ui->groupBox_workPlace1->setStyleSheet("QGroupBox {background-color: lightGrey}");
        ui->groupBox_workPlace1->setEnabled(false);

        portOptical->close();        
    }
}

void MainWindow::on_checkBox_workPlace2_clicked(bool checked)
{
    if(checked) {
        vectorIsWorkPlaceUse[1] = true;
        ui->groupBox_workPlace2->setEnabled(true);
        ui->groupBox_workPlace2->setStyleSheet("QGroupBox {background-color: transparent}");
    }
    else {
        vectorIsWorkPlaceUse[1] = false;
        ui->groupBox_workPlace2->setStyleSheet("QGroupBox {background-color: lightGrey}");
        ui->groupBox_workPlace2->setEnabled(false);
        portOptical2->close();
    }
}

void MainWindow::on_checkBox_workPlace3_clicked(bool checked)
{
    if(checked) {
        vectorIsWorkPlaceUse[2] = true;
        ui->groupBox_workPlace3->setEnabled(true);
        ui->groupBox_workPlace3->setStyleSheet("QGroupBox {background-color: transparent}");
    }
    else {
        vectorIsWorkPlaceUse[2] = false;
        ui->groupBox_workPlace3->setStyleSheet("QGroupBox {background-color: lightGrey}");
        ui->groupBox_workPlace3->setEnabled(false);
        portOptical3->close();
    }
}

void MainWindow::on_checkBox_workPlace4_clicked(bool checked)
{
    if(checked) {
        vectorIsWorkPlaceUse[3] = true;
        ui->groupBox_workPlace4->setEnabled(true);
        ui->groupBox_workPlace4->setStyleSheet("QGroupBox {background-color: transparent}");
    }
    else {
        vectorIsWorkPlaceUse[3] = false;
        ui->groupBox_workPlace4->setEnabled(false);
        ui->groupBox_workPlace4->setStyleSheet("QGroupBox {background-color: lightGrey}");
        portOptical4->close();
    }
}
//
//
void MainWindow::on_checkBox_writeParamsUse_clicked(bool checked)
{
    if(checked) {
        vectorIsCommandUse[0] = true;
    }
    else {
        vectorIsCommandUse[0] = false;
    }
}


void MainWindow::on_checkBox_startCalibrationUse_clicked(bool checked)
{
    if(checked) {
        vectorIsCommandUse[1] = true;
    }
    else {
        vectorIsCommandUse[1] = false;
    }
}

void MainWindow::on_checkBox_pulsesOutputHeatUse_clicked(bool checked)
{
    if(checked) {
        vectorIsCommandUse[2] = true;
    }
    else {
        vectorIsCommandUse[2] = false;
    }
}

void MainWindow::on_checkBox_pulsesInputVolumeUse_clicked(bool checked)
{
    if(checked) {
        vectorIsCommandUse[3] = true;
    }
    else {
        vectorIsCommandUse[3] = false;
    }
}

void MainWindow::on_checkBox_pulsesOutputOffUse_clicked(bool checked)
{
    if(checked) {
        vectorIsCommandUse[4] = true;
    }
    else {
        vectorIsCommandUse[4] = false;
    }
}

void MainWindow::on_checkBox_MBusOnUse_clicked(bool checked)
{
    if(checked) {
        vectorIsCommandUse[5] = true;
    }
    else {
        vectorIsCommandUse[5] = false;
    }
}

void MainWindow::on_checkBox_CheckMbusUse_clicked(bool checked)
{
    if(checked) {
        vectorIsCommandUse[6] = true;
    }
    else {
        vectorIsCommandUse[6] = false;
    }
}

void MainWindow::on_checkBox_calibrationModeOffUse_clicked(bool checked)
{
    if(checked) {
        vectorIsCommandUse[9] = true;
    }
    else {
        vectorIsCommandUse[9] = false;
    }
}

void MainWindow::on_checkBox_digitalWireInterfaceCheckingUse_clicked(bool checked)
{
    if(checked) {
        vectorIsCommandUse[7] = true;
    }
    else {
        vectorIsCommandUse[7] = false;
    }
}

void MainWindow::on_checkBox_MBusOffUse_clicked(bool checked)
{
    if(checked) {
        vectorIsCommandUse[8] = true;
    }
    else {
        vectorIsCommandUse[8] = false;
    }
}

//
//
//
void MainWindow::on_toolButton_executeCommands_clicked()
{
 //   ui->groupBox_result->setVisible(false);

    if(ui->lineEdit_humanName->text().isEmpty()) {
        QMessageBox::information(this, "", tr("Не введено имя инженера-регулировщика"));
        return;
    }

    if(ui->lineEdit_loadParamsFile->text().isEmpty()) {
        QMessageBox::information(this, "", tr("Не выбран файл параметров"));
        return;
    }

//    this->grabKeyboard();

    isCommandsEnded = false;

    isPulsOutputHeatCmdStarted = false;
    isPulsInputVolumeCmdStarted = false;

    ui->label_StatusBar->clear();
    errorString.clear();

    portOptical->close();
    portOptical2->close();
    portOptical3->close();
    portOptical4->close();
    portDigitalInterfaceChecking->close();

//    portOptical->clear();
//    portOptical2->clear();
//    portOptical3->clear();
//    portOptical4->clear();
//    portDigitalInterfaceChecking->clear();

    ui->lineEdit_RMV_ErrorFlags->clear();
    ui->lineEdit_RMV_ErrorFlags_2->clear();
    ui->lineEdit_RMV_ErrorFlags_3->clear();
    ui->lineEdit_RMV_ErrorFlags_4->clear();

    QPalette pal = ui->lineEdit_RMV_ErrorFlags->palette();
    pal.setColor(QPalette::Base, Qt::white);
    ui->lineEdit_RMV_ErrorFlags->setPalette(pal);
    ui->lineEdit_RMV_ErrorFlags_2->setPalette(pal);
    ui->lineEdit_RMV_ErrorFlags_3->setPalette(pal);
    ui->lineEdit_RMV_ErrorFlags_4->setPalette(pal);

    ObjectThread1->moveToThread(&Thread1);
    ObjectThread2->moveToThread(&Thread2);
    ObjectThread3->moveToThread(&Thread3);
    ObjectThread4->moveToThread(&Thread4);

    Thread1.start();
    Thread2.start();
    Thread3.start();
    Thread4.start();

    ObjectThread1->setWorkPlace(0);
    ObjectThread2->setWorkPlace(1);
    ObjectThread3->setWorkPlace(2);
    ObjectThread4->setWorkPlace(3);


    if(repeatParameter == 0) {
       for(int r=0; r<vectorIndicatorStateMatrix.size(); r++) {
           vectorIndicatorStateMatrix[r].fill(false);
       }
    }

    if(repeatParameter == 1) {
       for(int r=1; r<vectorIndicatorStateMatrix.size(); r++) {
           vectorIndicatorStateMatrix[r].fill(false);
       }
    }

    if(repeatParameter == 2) {
       for(int r=7; r<vectorIndicatorStateMatrix.size(); r++) {
           vectorIndicatorStateMatrix[r].fill(false);
       }
    }


    ObjectThread1->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
    ObjectThread2->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
    ObjectThread3->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
    ObjectThread4->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);

    ObjectThread1->setParamsMap(paramsMapToThreads);
    ObjectThread2->setParamsMap(paramsMapToThreads);
    ObjectThread3->setParamsMap(paramsMapToThreads);
    ObjectThread4->setParamsMap(paramsMapToThreads);

//    ObjectThread1->setMapWrite(mapwrite);
//    ObjectThread2->setMapWrite(mapwrite);
//    ObjectThread3->setMapWrite(mapwrite);
//    ObjectThread4->setMapWrite(mapwrite);

//    ObjectThread1->setMapRead(mapRead);
//    ObjectThread2->setMapRead(mapRead);
//    ObjectThread3->setMapRead(mapRead);
//    ObjectThread4->setMapRead(mapRead);


//    ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
//    ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
//    ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
//    ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

    if(ui->checkBox_workPlace1->isChecked()) vectorIsWorkPlaceUse[0] = true;
    if(ui->checkBox_workPlace2->isChecked()) vectorIsWorkPlaceUse[1] = true;
    if(ui->checkBox_workPlace3->isChecked()) vectorIsWorkPlaceUse[2] = true;
    if(ui->checkBox_workPlace4->isChecked()) vectorIsWorkPlaceUse[3] = true;

    ui->textBrowser->clear();

    errorString.clear();

    if(repeatParameter == 0) {
        isWritingFinished1 = false;
        isWritingFinished2 = false;
        isWritingFinished3 = false;
        isWritingFinished4 = false;
    }

    if(repeatParameter == 0 || repeatParameter == 1) {

        isCalibrationFinished1 = false;
        isCalibrationFinished2 = false;
        isCalibrationFinished3 = false;
        isCalibrationFinished4 = false;

        isPulsesOutputHeat1 = false;
        isPulsesOutputHeat2 = false;
        isPulsesOutputHeat3 = false;
        isPulsesOutputHeat4 = false;

        isPulsesInputVolume1 = false;
        isPulsesInputVolume2 = false;
        isPulsesInputVolume3 = false;
        isPulsesInputVolume4 = false;

        isPulsesOutputDefault1 = false;
        isPulsesOutputDefault2 = false;
        isPulsesOutputDefault3 = false;
        isPulsesOutputDefault4 = false;

        isMBusOn1 = false;
        isMBusOn2 = false;
        isMBusOn3 = false;
        isMBusOn4 = false;

        isMBusCheck1 = false;
        isMBusCheck2 = false;
        isMBusCheck3 = false;
        isMBusCheck4 = false;

    }

    if(repeatParameter == 0 || repeatParameter == 1 || repeatParameter == 2) {

        isWireInterfaceChecking1 = false;
        isWireInterfaceChecking2 = false;
        isWireInterfaceChecking3 = false;
        isWireInterfaceChecking4 = false;

        isMBusOff1 = false;
        isMBusOff2 = false;
        isMBusOff3 = false;
        isMBusOff4 = false;

    }

    isCalibrationModeOff1 = false;
    isCalibrationModeOff2 = false;
    isCalibrationModeOff3 = false;
    isCalibrationModeOff4 = false;


    repaint();

    //для всех рабочих мест команды посылаются параллельно

    //запись    

    if(vectorIsCommandUse.at(0) && (repeatParameter == 0)) {

        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

        QPalette palettePrime = ui->toolButton_writeParams->palette();
        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

        QPalette palette = palettePrime;
        palette.setColor( QPalette::Button, QColor( Qt::red )  );

        QColor backgroundColor = palette.color(QPalette::Button);

        qDebug()<<"palette "<<palette
                <<"backgroundColor "<<backgroundColor.name()
                <<"backgroundColorPrime "<<backgroundColorPrime.name();

        ui->toolButton_writeParams->setAutoFillBackground(true);
        ui->toolButton_writeParams->setPalette( palette );


//      for(int l=0; l<4; l++) {

//        if(vectorIsWorkPlaceUse.at(l)) {
//            emit signalWriteParams(l);

//        }

//      }

//       emit signalWriteParams(1);

//        if(vectorIsWorkPlaceUse.at(0)) emit signalWriteParams(0);
//        if(vectorIsWorkPlaceUse.at(1)) emit signalWriteParams2(1);
//        if(vectorIsWorkPlaceUse.at(2)) emit signalWriteParams3(2);
//        if(vectorIsWorkPlaceUse.at(3)) emit signalWriteParams4(3);


          emit signalLog("<font color = \"#0000ff\">" + QString("Начало записи")  + '\n' + "</font>");

          emit signalWriteParamsToThread(portOptical, portOptical2, portOptical3, portOptical4);



//          if(vectorIsWorkPlaceUse.at(1)) emit signalWriteParamsToThread(portOptical2, 1, vectorIndicatorStateMatrix,
//                                                                        paramsMapToThreads, mapwrite, mapRead);
//          if(vectorIsWorkPlaceUse.at(2)) emit signalWriteParamsToThread(portOptical3, 2, vectorIndicatorStateMatrix,
//                                                                        paramsMapToThreads, mapwrite, mapRead);
//          if(vectorIsWorkPlaceUse.at(3)) emit signalWriteParamsToThread(portOptical4, 3, vectorIndicatorStateMatrix,
//                                                                        paramsMapToThreads, mapwrite, mapRead);



      //-------------------------Ждём завершения записи------------------

        bool isWritingFinishedTmp1 = true;
        bool isWritingFinishedTmp2 = true;
        bool isWritingFinishedTmp3 = true;
        bool isWritingFinishedTmp4 = true;

//        if(!vectorIsWorkPlaceUse.at(0)) isWritingFinishedTmp1 = true;
//        if(!vectorIsWorkPlaceUse.at(1)) isWritingFinishedTmp2 = true;
//        if(!vectorIsWorkPlaceUse.at(2)) isWritingFinishedTmp3 = true;
//        if(!vectorIsWorkPlaceUse.at(3)) isWritingFinishedTmp4 = true;

        for(int e=0; e<100; e++) { //10 sec
            global::pause(100);

//            if(vectorIsWorkPlaceUse.at(0)) isWritingFinishedTmp1 = isWritingFinished1;
//            if(vectorIsWorkPlaceUse.at(1)) isWritingFinishedTmp2 = isWritingFinished2;
//            if(vectorIsWorkPlaceUse.at(2)) isWritingFinishedTmp3 = isWritingFinished3;
//            if(vectorIsWorkPlaceUse.at(3)) isWritingFinishedTmp4 = isWritingFinished4;

            if(ui->checkBox_workPlace1->isChecked()) {
                isWritingFinishedTmp1 = isWritingFinished1;

                if(!vectorIsWorkPlaceUse.at(0)) isWritingFinishedTmp1 = true;
            }

            if(ui->checkBox_workPlace2->isChecked()) {
                isWritingFinishedTmp2 = isWritingFinished2;

                if(!vectorIsWorkPlaceUse.at(1)) isWritingFinishedTmp2 = true;
            }

            if(ui->checkBox_workPlace3->isChecked()) {
                isWritingFinishedTmp3 = isWritingFinished3;

                if(!vectorIsWorkPlaceUse.at(2)) isWritingFinishedTmp3 = true;
            }

            if(ui->checkBox_workPlace4->isChecked()) {
                isWritingFinishedTmp4 = isWritingFinished4;

                if(!vectorIsWorkPlaceUse.at(3)) isWritingFinishedTmp4 = true;
            }


            if(isWritingFinishedTmp1 && isWritingFinishedTmp2 && isWritingFinishedTmp3 && isWritingFinishedTmp4)
                break;
        }


      //-------------------------Ждём завершения записи------------------/

        ui->toolButton_writeParams->setPalette(palettePrime);


    }
    //запись/


//    global::pause(10000);


    //калибровка

    if(vectorIsCommandUse.at(1) && (repeatParameter == 0 || repeatParameter == 1) ) {

        ObjectThread1->setCalibrationMap(calibrationMap);
        ObjectThread2->setCalibrationMap(calibrationMap);
        ObjectThread3->setCalibrationMap(calibrationMap);
        ObjectThread4->setCalibrationMap(calibrationMap);

        ObjectThread1->setCalibrationFloatMap(calibrationFloatMap);
        ObjectThread2->setCalibrationFloatMap(calibrationFloatMap);
        ObjectThread3->setCalibrationFloatMap(calibrationFloatMap);
        ObjectThread4->setCalibrationFloatMap(calibrationFloatMap);

        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

        QPalette palettePrime = ui->toolButton_startCalibration->palette();
        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

        QPalette palette = palettePrime;
        palette.setColor( QPalette::Button, QColor( Qt::red )  );

        QColor backgroundColor = palette.color(QPalette::Button);

        qDebug()<<"palette "<<palette
                <<"backgroundColor "<<backgroundColor.name()
                <<"backgroundColorPrime "<<backgroundColorPrime.name();

        ui->toolButton_startCalibration->setAutoFillBackground(true);
        ui->toolButton_startCalibration->setPalette( palette );

//        for(int l=0; l<4; l++) {

//          if(vectorIsWorkPlaceUse.at(l)) {
//              emit signalCalibration(l);

//          }

//        }

        emit signalCalibrationToThread(portOptical, portOptical2, portOptical3, portOptical4);

        emit signalLog("<font color = \"#0000ff\">" + QString("Начало калибровки") + '\n' + "</font>");


        //-------------------------Ждём завершения калибровки------------------

          bool isCalibrationFinishedTmp1 = true;
          bool isCalibrationFinishedTmp2 = true;
          bool isCalibrationFinishedTmp3 = true;
          bool isCalibrationFinishedTmp4 = true;

//          if(!vectorIsWorkPlaceUse.at(0)) isCalibrationFinishedTmp1 = true;
//          if(!vectorIsWorkPlaceUse.at(1)) isCalibrationFinishedTmp2 = true;
//          if(!vectorIsWorkPlaceUse.at(2)) isCalibrationFinishedTmp3 = true;
//          if(!vectorIsWorkPlaceUse.at(3)) isCalibrationFinishedTmp4 = true;

          for(int e=0; e<200; e++) { //20 sec
              global::pause(100);

//              if(vectorIsWorkPlaceUse.at(0)) isCalibrationFinishedTmp1 = isCalibrationFinished1;
//              if(vectorIsWorkPlaceUse.at(1)) isCalibrationFinishedTmp2 = isCalibrationFinished2;
//              if(vectorIsWorkPlaceUse.at(2)) isCalibrationFinishedTmp3 = isCalibrationFinished3;
//              if(vectorIsWorkPlaceUse.at(3)) isCalibrationFinishedTmp4 = isCalibrationFinished4;

              if(ui->checkBox_workPlace1->isChecked()) {
                  isCalibrationFinishedTmp1 = isCalibrationFinished1;

                  if(!vectorIsWorkPlaceUse.at(0)) isCalibrationFinishedTmp1 = true;
              }

              if(ui->checkBox_workPlace2->isChecked()) {
                  isCalibrationFinishedTmp2 = isCalibrationFinished2;

                  if(!vectorIsWorkPlaceUse.at(1)) isCalibrationFinishedTmp2 = true;
              }

              if(ui->checkBox_workPlace3->isChecked()) {
                  isCalibrationFinishedTmp3 = isCalibrationFinished3;

                  if(!vectorIsWorkPlaceUse.at(2)) isCalibrationFinishedTmp3 = true;
              }

              if(ui->checkBox_workPlace4->isChecked()) {
                  isCalibrationFinishedTmp4 = isCalibrationFinished4;

                  if(!vectorIsWorkPlaceUse.at(3)) isCalibrationFinishedTmp4 = true;
              }


              if(isCalibrationFinishedTmp1 && isCalibrationFinishedTmp2 && isCalibrationFinishedTmp3 && isCalibrationFinishedTmp4)
                  break;
          }


        //-------------------------Ждём завершения калибровки------------------/

          ui->toolButton_startCalibration->setPalette(palettePrime);

    }
    //калибровка/


    //импульсный выход по теплу

    if(vectorIsCommandUse.at(2) && (repeatParameter == 0 || repeatParameter == 1) ) {

        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

        QPalette palettePrime = ui->toolButton_pulsesOutputHeat->palette();
        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

        QPalette palette = palettePrime;
        palette.setColor( QPalette::Button, QColor( Qt::red )  );

        QColor backgroundColor = palette.color(QPalette::Button);

        qDebug()<<"palette "<<palette
                <<"backgroundColor "<<backgroundColor.name()
                <<"backgroundColorPrime "<<backgroundColorPrime.name();

        ui->toolButton_pulsesOutputHeat->setAutoFillBackground(true);
        ui->toolButton_pulsesOutputHeat->setPalette( palette );

//      for(int l=0; l<4; l++) {

//        if(vectorIsWorkPlaceUse.at(l)) {
//            emit signalPulsesOutputHeat(l);

//        }

//      }

        isPulsOutputHeatCmdStarted = true;

        emit signalPulsesOutputHeatToThread(portOptical, portOptical2, portOptical3, portOptical4);

        emit signalLog("<font color = \"#0000ff\">" + QString("Начало: Импульсный выход по теплу")  + '\n' + "</font>");

        //-------------------------Ждём завершения импульсный выход по теплу------------------

        bool isPulsesOutputHeatTmp1 = true;
        bool isPulsesOutputHeatTmp2 = true;
        bool isPulsesOutputHeatTmp3 = true;
        bool isPulsesOutputHeatTmp4 = true;

//          if(!vectorIsWorkPlaceUse.at(0)) isPulsesOutputHeatTmp1 = true;
//          if(!vectorIsWorkPlaceUse.at(1)) isPulsesOutputHeatTmp2 = true;
//          if(!vectorIsWorkPlaceUse.at(2)) isPulsesOutputHeatTmp3 = true;
//          if(!vectorIsWorkPlaceUse.at(3)) isPulsesOutputHeatTmp4 = true;

          for(int e=0; e<30; e++) { //3 sec
              global::pause(100);

            if(ui->checkBox_workPlace1->isChecked()) {
              isPulsesOutputHeatTmp1 = isPulsesOutputHeat1;

              if(!vectorIsWorkPlaceUse.at(0)) isPulsesOutputHeatTmp1 = true;
            }

            if(ui->checkBox_workPlace2->isChecked()) {
              isPulsesOutputHeatTmp2 = isPulsesOutputHeat2;

              if(!vectorIsWorkPlaceUse.at(1)) isPulsesOutputHeatTmp2 = true;
            }

            if(ui->checkBox_workPlace3->isChecked()) {
              isPulsesOutputHeatTmp3 = isPulsesOutputHeat3;

              if(!vectorIsWorkPlaceUse.at(2)) isPulsesOutputHeatTmp3 = true;
            }

            if(ui->checkBox_workPlace4->isChecked()) {
              isPulsesOutputHeatTmp4 = isPulsesOutputHeat4;

              if(!vectorIsWorkPlaceUse.at(3)) isPulsesOutputHeatTmp4 = true;
            }


//              if(vectorIsWorkPlaceUse.at(1)) isPulsesOutputHeatTmp2 = isPulsesOutputHeat2;

//              if(vectorIsWorkPlaceUse.at(2)) isPulsesOutputHeatTmp3 = isPulsesOutputHeat3;

//              if(vectorIsWorkPlaceUse.at(3)) isPulsesOutputHeatTmp4 = isPulsesOutputHeat4;


              if(isPulsesOutputHeatTmp1 && isPulsesOutputHeatTmp2 &&
                      isPulsesOutputHeatTmp3 && isPulsesOutputHeatTmp4)
                  break;
          }


        //-------------------------Ждём завершения импульсный выход по теплу------------------/

      ui->toolButton_pulsesOutputHeat->setPalette(palettePrime);

    }

    //импульсный выход по теплу/



    //импульсный вход по объему

    if(vectorIsCommandUse.at(3) && (repeatParameter == 0 || repeatParameter == 1) ) {



   //     this->setFocusProxy(ui->lineEdit_programmingFile);
        ui->label_StatusBar->setFocus(Qt::MouseFocusReason);


        qDebug()<<"focusPolicy() "<<this->focusPolicy()
                 <<"focusProxy()"<<this->focusProxy()
                 <<"focusWidget()"<<this->focusWidget();

        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

        QPalette palettePrime = ui->toolButton_pulsesInputVolume->palette();
        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

        QPalette palette = palettePrime;
        palette.setColor( QPalette::Button, QColor( Qt::red )  );

        QColor backgroundColor = palette.color(QPalette::Button);

        qDebug()<<"palette "<<palette
                <<"backgroundColor "<<backgroundColor.name()
                <<"backgroundColorPrime "<<backgroundColorPrime.name();

        ui->toolButton_pulsesInputVolume->setAutoFillBackground(true);
        ui->toolButton_pulsesInputVolume->setPalette( palette );

//      for(int l=0; l<4; l++) {

//        if(vectorIsWorkPlaceUse.at(l)) {
//            emit signalPulsesInputVolume(l);

//        }

//      }

        //остановка на 10с или до нажатия клавиши

        KeyEventEnterBool = false;


//        ui->toolButton_pulsesInputVolume->setFocus();

        //если хотя бы одно рабочее место не слетело
        bool isWorkPlaceExists = false;
        if(vectorIsWorkPlaceUse.at(0)) isWorkPlaceExists = true;
        if(vectorIsWorkPlaceUse.at(1)) isWorkPlaceExists = true;
        if(vectorIsWorkPlaceUse.at(2)) isWorkPlaceExists = true;
        if(vectorIsWorkPlaceUse.at(3)) isWorkPlaceExists = true;

        //если хотя бы один кружок зелёный от команды pulsesOutputHeat
        bool isGreenExist = false;
        if(!vectorIndicatorStateMatrix.at(2).at(0)) isGreenExist = true;
        if(!vectorIndicatorStateMatrix.at(2).at(1)) isGreenExist = true;
        if(!vectorIndicatorStateMatrix.at(2).at(2)) isGreenExist = true;
        if(!vectorIndicatorStateMatrix.at(2).at(3)) isGreenExist = true;

       if(isPulsOutputHeatCmdStarted && isWorkPlaceExists && isGreenExist) {

          for(int s=0; s<100; s++) {

             ui->label_pulsesInputVolTimer->setText(QString::number((10000 - 100*s)/1000) + " сек");

              global::pause(100);

              if(KeyEventEnterBool == true)
                  break;

          }

          ui->label_pulsesInputVolTimer->setText("");

       }


        //остановка на 10с или до нажатия клавиши/

       isPulsInputVolumeCmdStarted = true;

        emit signalPulsesInputVolToThread(portOptical, portOptical2, portOptical3, portOptical4);

        emit signalLog("<font color = \"#0000ff\">" + QString("Начало: Импульсный вход по объему")  + '\n' + "</font>");

        //-------------------------Ждём завершения импульсный вход по объему------------------

        bool isPulsesInputVolumeTmp1 = true;
        bool isPulsesInputVolumeTmp2 = true;
        bool isPulsesInputVolumeTmp3 = true;
        bool isPulsesInputVolumeTmp4 = true;

//          if(!vectorIsWorkPlaceUse.at(0)) isPulsesInputVolumeTmp1 = true;
//          if(!vectorIsWorkPlaceUse.at(1)) isPulsesInputVolumeTmp2 = true;
//          if(!vectorIsWorkPlaceUse.at(2)) isPulsesInputVolumeTmp3 = true;
//          if(!vectorIsWorkPlaceUse.at(3)) isPulsesInputVolumeTmp4 = true;

          for(int e=0; e<30; e++) { //3 sec
              global::pause(100);

              if(ui->checkBox_workPlace1->isChecked()) {
                  isPulsesInputVolumeTmp1 = isPulsesInputVolume1;

                  if(!vectorIsWorkPlaceUse.at(0)) isPulsesInputVolumeTmp1 = true;
              }

              if(ui->checkBox_workPlace2->isChecked()) {
                  isPulsesInputVolumeTmp2 = isPulsesInputVolume2;

                  if(!vectorIsWorkPlaceUse.at(1)) isPulsesInputVolumeTmp2 = true;
              }

              if(ui->checkBox_workPlace3->isChecked()) {
                  isPulsesInputVolumeTmp3 = isPulsesInputVolume3;

                  if(!vectorIsWorkPlaceUse.at(2)) isPulsesInputVolumeTmp3 = true;
              }

              if(ui->checkBox_workPlace4->isChecked()) {
                  isPulsesInputVolumeTmp4 = isPulsesInputVolume4;

                  if(!vectorIsWorkPlaceUse.at(3)) isPulsesInputVolumeTmp4 = true;
              }
//              if(vectorIsWorkPlaceUse.at(0)) isPulsesInputVolumeTmp1 = isPulsesInputVolume1;
//              if(vectorIsWorkPlaceUse.at(1)) isPulsesInputVolumeTmp2 = isPulsesInputVolume2;
//              if(vectorIsWorkPlaceUse.at(2)) isPulsesInputVolumeTmp3 = isPulsesInputVolume3;
//              if(vectorIsWorkPlaceUse.at(3)) isPulsesInputVolumeTmp4 = isPulsesInputVolume4;

              if(isPulsesInputVolumeTmp1 && isPulsesInputVolumeTmp2 &&
                      isPulsesInputVolumeTmp3 && isPulsesInputVolumeTmp4)
                  break;
          }


        //-------------------------Ждём завершения импульсный вход по объему------------------/

      ui->toolButton_pulsesInputVolume->setPalette(palettePrime);

    }

    //импульсный вход по объему/


    //импульсный выход - по умолчанию

    if(vectorIsCommandUse.at(4) && (repeatParameter == 0 || repeatParameter == 1) ) {

        ui->label_StatusBar->setFocus(Qt::MouseFocusReason);

        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

        QPalette palettePrime = ui->toolButton_pulsesOutputOff->palette();
        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

        QPalette palette = palettePrime;
        palette.setColor( QPalette::Button, QColor( Qt::red )  );

        QColor backgroundColor = palette.color(QPalette::Button);

        qDebug()<<"palette "<<palette
                <<"backgroundColor "<<backgroundColor.name()
                <<"backgroundColorPrime "<<backgroundColorPrime.name();

        ui->toolButton_pulsesOutputOff->setAutoFillBackground(true);
        ui->toolButton_pulsesOutputOff->setPalette( palette );

//      for(int l=0; l<4; l++) {

//        if(vectorIsWorkPlaceUse.at(l)) {
//            emit signalPulsesOutputDefault(l);

//        }

//      }

        //остановка на 30с или до нажатия клавиши

        KeyEventEnterBool = false;


//        ui->toolButton_pulsesInputVolume->setFocus();

        //если хотя бы одно рабочее место не слетело
        bool isWorkPlaceExists = false;
        if(vectorIsWorkPlaceUse.at(0)) isWorkPlaceExists = true;
        if(vectorIsWorkPlaceUse.at(1)) isWorkPlaceExists = true;
        if(vectorIsWorkPlaceUse.at(2)) isWorkPlaceExists = true;
        if(vectorIsWorkPlaceUse.at(3)) isWorkPlaceExists = true;

        //если хотя бы один кружок зелёный от команды pulsesOutputHeat
        bool isGreenExist = false;
        if(!vectorIndicatorStateMatrix.at(3).at(0)) isGreenExist = true;
        if(!vectorIndicatorStateMatrix.at(3).at(1)) isGreenExist = true;
        if(!vectorIndicatorStateMatrix.at(3).at(2)) isGreenExist = true;
        if(!vectorIndicatorStateMatrix.at(3).at(3)) isGreenExist = true;

       if(isPulsInputVolumeCmdStarted && isWorkPlaceExists && isGreenExist) {

          for(int s=0; s<65000; s++) {

              global::pause(300);

              if(KeyEventEnterBool == true)
                  break;

          }

       }


        //остановка на 30с или до нажатия клавиши/

        emit signalPulsesOutputDefToThread(portOptical, portOptical2, portOptical3, portOptical4);

        emit signalLog("<font color = \"#0000ff\">" + QString("Начало: Импульсный выход по умолчанию")  + '\n' + "</font>");

        //-------------------------Ждём завершения Импульсный выход по умолчанию------------------

        bool isPulsesOutputDefaultTmp1 = true;
        bool isPulsesOutputDefaultTmp2 = true;
        bool isPulsesOutputDefaultTmp3 = true;
        bool isPulsesOutputDefaultTmp4 = true;

//          if(!vectorIsWorkPlaceUse.at(0)) isPulsesInputVolumeTmp1 = true;
//          if(!vectorIsWorkPlaceUse.at(1)) isPulsesInputVolumeTmp2 = true;
//          if(!vectorIsWorkPlaceUse.at(2)) isPulsesInputVolumeTmp3 = true;
//          if(!vectorIsWorkPlaceUse.at(3)) isPulsesInputVolumeTmp4 = true;

          for(int e=0; e<30; e++) { //3 sec
              global::pause(100);

              if(ui->checkBox_workPlace1->isChecked()) {
                  isPulsesOutputDefaultTmp1 = isPulsesOutputDefault1;

                  if(!vectorIsWorkPlaceUse.at(0)) isPulsesOutputDefaultTmp1 = true;
              }

              if(ui->checkBox_workPlace2->isChecked()) {
                  isPulsesOutputDefaultTmp2 = isPulsesOutputDefault2;

                  if(!vectorIsWorkPlaceUse.at(1)) isPulsesOutputDefaultTmp2 = true;
              }

              if(ui->checkBox_workPlace3->isChecked()) {
                  isPulsesOutputDefaultTmp3 = isPulsesOutputDefault3;

                  if(!vectorIsWorkPlaceUse.at(2)) isPulsesOutputDefaultTmp3 = true;
              }

              if(ui->checkBox_workPlace4->isChecked()) {
                  isPulsesOutputDefaultTmp4 = isPulsesOutputDefault4;

                  if(!vectorIsWorkPlaceUse.at(3)) isPulsesOutputDefaultTmp4 = true;
              }
//              if(vectorIsWorkPlaceUse.at(0)) isPulsesOutputDefaultTmp1 = isPulsesOutputDefault1;
//              if(vectorIsWorkPlaceUse.at(1)) isPulsesOutputDefaultTmp2 = isPulsesOutputDefault2;
//              if(vectorIsWorkPlaceUse.at(2)) isPulsesOutputDefaultTmp3 = isPulsesOutputDefault3;
//              if(vectorIsWorkPlaceUse.at(3)) isPulsesOutputDefaultTmp4 = isPulsesOutputDefault4;

              if(isPulsesOutputDefaultTmp1 && isPulsesOutputDefaultTmp2 &&
                      isPulsesOutputDefaultTmp3 && isPulsesOutputDefaultTmp4)
                  break;
          }


        //-------------------------Ждём завершения Импульсный выход по умолчанию------------------/

      ui->toolButton_pulsesOutputOff->setPalette(palettePrime);

    }

    //импульсный выход - по умолчанию/


    //включить протокол MBus

    if(vectorIsCommandUse.at(5) && (repeatParameter == 0 || repeatParameter == 1) ) {

        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

        QPalette palettePrime = ui->toolButton_MBusOn->palette();
        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

        QPalette palette = palettePrime;
        palette.setColor( QPalette::Button, QColor( Qt::red )  );

        QColor backgroundColor = palette.color(QPalette::Button);

        qDebug()<<"palette "<<palette
                <<"backgroundColor "<<backgroundColor.name()
                <<"backgroundColorPrime "<<backgroundColorPrime.name();

        ui->toolButton_MBusOn->setAutoFillBackground(true);
        ui->toolButton_MBusOn->setPalette( palette );

//      for(int l=0; l<4; l++) {

//        if(vectorIsWorkPlaceUse.at(l)) {
//            emit signalMBusOn(l);

//        }

//      }


        emit signalLog("<font color = \"#0000ff\">" + QString("Включение протокола MBus")  + '\n' + "</font>");

        emit signalMBusOnToThread(portOptical, portOptical2, portOptical3, portOptical4);

        //-------------------------Ждём завершения Включение протокола MBus------------------

        bool isMBusOnTmp1 = true;
        bool isMBusOnTmp2 = true;
        bool isMBusOnTmp3 = true;
        bool isMBusOnTmp4 = true;

//          if(!vectorIsWorkPlaceUse.at(0)) isPulsesInputVolumeTmp1 = true;
//          if(!vectorIsWorkPlaceUse.at(1)) isPulsesInputVolumeTmp2 = true;
//          if(!vectorIsWorkPlaceUse.at(2)) isPulsesInputVolumeTmp3 = true;
//          if(!vectorIsWorkPlaceUse.at(3)) isPulsesInputVolumeTmp4 = true;

          for(int e=0; e<30; e++) { //3 sec
              global::pause(100);

              if(ui->checkBox_workPlace1->isChecked()) {
                  isMBusOnTmp1 = isMBusOn1;

                  if(!vectorIsWorkPlaceUse.at(0)) isMBusOnTmp1 = true;
              }

              if(ui->checkBox_workPlace2->isChecked()) {
                  isMBusOnTmp2 = isMBusOn2;

                  if(!vectorIsWorkPlaceUse.at(1)) isMBusOnTmp2 = true;
              }

              if(ui->checkBox_workPlace3->isChecked()) {
                  isMBusOnTmp3 = isMBusOn3;

                  if(!vectorIsWorkPlaceUse.at(2)) isMBusOnTmp3 = true;
              }

              if(ui->checkBox_workPlace4->isChecked()) {
                  isMBusOnTmp4 = isMBusOn4;

                  if(!vectorIsWorkPlaceUse.at(3)) isMBusOnTmp4 = true;
              }
//              if(vectorIsWorkPlaceUse.at(0)) isMBusOnTmp1 = isMBusOn1;
//              if(vectorIsWorkPlaceUse.at(1)) isMBusOnTmp2 = isMBusOn2;
//              if(vectorIsWorkPlaceUse.at(2)) isMBusOnTmp3 = isMBusOn3;
//              if(vectorIsWorkPlaceUse.at(3)) isMBusOnTmp4 = isMBusOn4;

              if(isMBusOnTmp1 && isMBusOnTmp2 && isMBusOnTmp3 && isMBusOnTmp4)
                  break;
          }


        //-------------------------Ждём завершения Включение протокола MBus------------------/


      ui->toolButton_MBusOn->setPalette(palettePrime);

    }

    //включить протокол MBus/



    //проверить протокол MBus

    if(vectorIsCommandUse.at(6) && (repeatParameter == 0 || repeatParameter == 1) ) {

        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

        QPalette palettePrime = ui->toolButton_CheckMbus->palette();
        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

        QPalette palette = palettePrime;
        palette.setColor( QPalette::Button, QColor( Qt::red )  );

        QColor backgroundColor = palette.color(QPalette::Button);

        qDebug()<<"palette "<<palette
                <<"backgroundColor "<<backgroundColor.name()
                <<"backgroundColorPrime "<<backgroundColorPrime.name();

        ui->toolButton_CheckMbus->setAutoFillBackground(true);
        ui->toolButton_CheckMbus->setPalette( palette );

//      for(int l=0; l<4; l++) {

//        if(vectorIsWorkPlaceUse.at(l)) {
//            emit signalMBusCheck(l);

//        }

//      }

        emit signalLog("<font color = \"#0000ff\">" + QString("Проверка протокола MBus")  + '\n' + "</font>");

        emit signalCheckMBusToThread(portOptical, portOptical2, portOptical3, portOptical4);

        //-------------------------Ждём завершения Проверка протокола MBus------------------

        bool isMBusCheckTmp1 = true;
        bool isMBusCheckTmp2 = true;
        bool isMBusCheckTmp3 = true;
        bool isMBusCheckTmp4 = true;

//          if(!vectorIsWorkPlaceUse.at(0)) isPulsesInputVolumeTmp1 = true;
//          if(!vectorIsWorkPlaceUse.at(1)) isPulsesInputVolumeTmp2 = true;
//          if(!vectorIsWorkPlaceUse.at(2)) isPulsesInputVolumeTmp3 = true;
//          if(!vectorIsWorkPlaceUse.at(3)) isPulsesInputVolumeTmp4 = true;

          for(int e=0; e<30; e++) { //3 sec
              global::pause(100);

              if(ui->checkBox_workPlace1->isChecked()) {
                  isMBusCheckTmp1 = isMBusCheck1;

                  if(!vectorIsWorkPlaceUse.at(0)) isMBusCheckTmp1 = true;
              }

              if(ui->checkBox_workPlace2->isChecked()) {
                  isMBusCheckTmp2 = isMBusCheck2;

                  if(!vectorIsWorkPlaceUse.at(1)) isMBusCheckTmp2 = true;
              }

              if(ui->checkBox_workPlace3->isChecked()) {
                  isMBusCheckTmp3 = isMBusCheck3;

                  if(!vectorIsWorkPlaceUse.at(2)) isMBusCheckTmp3 = true;
              }

              if(ui->checkBox_workPlace4->isChecked()) {
                  isMBusCheckTmp4 = isMBusCheck4;

                  if(!vectorIsWorkPlaceUse.at(3)) isMBusCheckTmp4 = true;
              }

//              if(vectorIsWorkPlaceUse.at(0)) isMBusCheckTmp1 = isMBusCheck1;
//              if(vectorIsWorkPlaceUse.at(1)) isMBusCheckTmp2 = isMBusCheck2;
//              if(vectorIsWorkPlaceUse.at(2)) isMBusCheckTmp3 = isMBusCheck3;
//              if(vectorIsWorkPlaceUse.at(3)) isMBusCheckTmp4 = isMBusCheck4;

              if(isMBusCheckTmp1 && isMBusCheckTmp2 && isMBusCheckTmp3 && isMBusCheckTmp4)
                  break;
          }


        //-------------------------Ждём завершения Проверка протокола MBus------------------/

      ui->toolButton_CheckMbus->setPalette(palettePrime);

    }

    //проверить протокол MBus/


    //проверка проводных интерфейсов

    if(vectorIsCommandUse.at(7) && (repeatParameter == 0 || repeatParameter == 1 || repeatParameter == 2) ) {

        portOptical->close();
        portOptical2->close();
        portOptical3->close();
        portOptical4->close();
        portDigitalInterfaceChecking->close();
        portOptical->clear();
        portOptical2->clear();
        portOptical3->clear();
        portOptical4->clear();
        portDigitalInterfaceChecking->clear();

        ObjectThread1->moveToThread(&Thread1);
        ObjectThread2->moveToThread(&Thread2);
        ObjectThread3->moveToThread(&Thread3);
        ObjectThread4->moveToThread(&Thread4);

        Thread1.start();
        Thread2.start();
        Thread3.start();
        Thread4.start();

        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

        QPalette palettePrime = ui->toolButton_digitalWireInterfaceChecking->palette();
        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

        QPalette palette = palettePrime;
        palette.setColor( QPalette::Button, QColor( Qt::red )  );

        QColor backgroundColor = palette.color(QPalette::Button);

        qDebug()<<"palette "<<palette
                <<"backgroundColor "<<backgroundColor.name()
                <<"backgroundColorPrime "<<backgroundColorPrime.name();

        ui->toolButton_digitalWireInterfaceChecking->setAutoFillBackground(true);
        ui->toolButton_digitalWireInterfaceChecking->setPalette( palette );

 //       global::pause(10000);

        emit signalLog("<font color = \"#0000ff\">" + QString("Проверка проводных интерфейсов")  + '\n' + "</font>");

      for(int l=0; l<4; l++) {

        if(vectorIsWorkPlaceUse.at(l)) {
            emit signalWireInterfaceChecking(l);

        }

      }

      int u=0;

  //    repaint();

      //Ждём завершения
//      while(!isWireInterfaceChecking1 || !isWireInterfaceChecking2 || !isWireInterfaceChecking3 || !isWireInterfaceChecking4) {
//          global::pause(100);
//      }
      //Ждём завершения/


//                    if(!portDigitalInterfaceChecking->isOpen()) {
//                        if(!portDigitalInterfaceChecking->open(QIODevice::ReadWrite)) {
//             //               QMessageBox::information(this, "", "Не удалось открыть порт: Проводные интерфейсы");
//                            slotError(tr("Не удалось открыть порт: Проводные интерфейсы")  + '\n');
//         //                                                 ". Рабочее место: " + QString::number(workPlaceNumber+1));
//         //                   emit errorStringSignal(label_StatusBar + '\n');

//         //                   vectorIndicatorStateMatrix[currentBoxNumber][currentIndicatorNumber] = true;

//         //                   emit checkWireInterfaceChecking(currentIndicatorNumber);
//                            return;
//                        }
//                    }



//        emit signalLog("<font color = \"#0000ff\">" + QString("Проверка проводных интерфейсов")  + '\n' + "</font>");

//        emit signalDigitalInterfaceToThread(portOptical, portOptical2, portOptical3, portOptical4, portDigitalInterfaceChecking);

        //-------------------------Ждём завершения Проверка проводных интерфейсов------------------

//        bool isWireInterfaceCheckingTmp1 = true;
//        bool isWireInterfaceCheckingTmp2 = true;
//        bool isWireInterfaceCheckingTmp3 = true;
//        bool isWireInterfaceCheckingTmp4 = true;

// //          if(!vectorIsWorkPlaceUse.at(0)) isPulsesInputVolumeTmp1 = true;
// //          if(!vectorIsWorkPlaceUse.at(1)) isPulsesInputVolumeTmp2 = true;
// //          if(!vectorIsWorkPlaceUse.at(2)) isPulsesInputVolumeTmp3 = true;
// //          if(!vectorIsWorkPlaceUse.at(3)) isPulsesInputVolumeTmp4 = true;

//          for(int e=0; e<100; e++) { //10 sec
//              global::pause(100);

//              if(ui->checkBox_workPlace1->isChecked()) {
//                  isWireInterfaceCheckingTmp1 = isWireInterfaceChecking1;

//                  if(!vectorIsWorkPlaceUse.at(0)) isWireInterfaceCheckingTmp1 = true;
//              }

//              if(ui->checkBox_workPlace2->isChecked()) {
//                  isWireInterfaceCheckingTmp2 = isWireInterfaceChecking2;

//                  if(!vectorIsWorkPlaceUse.at(1)) isWireInterfaceCheckingTmp2 = true;
//              }

//              if(ui->checkBox_workPlace3->isChecked()) {
//                  isWireInterfaceCheckingTmp3 = isWireInterfaceChecking3;

//                  if(!vectorIsWorkPlaceUse.at(2)) isWireInterfaceCheckingTmp3 = true;
//              }

//              if(ui->checkBox_workPlace4->isChecked()) {
//                  isWireInterfaceCheckingTmp4 = isWireInterfaceChecking4;

//                  if(!vectorIsWorkPlaceUse.at(3)) isWireInterfaceCheckingTmp4 = true;
//              }
// //              if(vectorIsWorkPlaceUse.at(0)) isWireInterfaceCheckingTmp1 = isWireInterfaceChecking1;
// //              if(vectorIsWorkPlaceUse.at(1)) isWireInterfaceCheckingTmp2 = isWireInterfaceChecking2;
// //              if(vectorIsWorkPlaceUse.at(2)) isWireInterfaceCheckingTmp3 = isWireInterfaceChecking3;
// //              if(vectorIsWorkPlaceUse.at(3)) isWireInterfaceCheckingTmp4 = isWireInterfaceChecking4;

//              if(isWireInterfaceCheckingTmp1 && isWireInterfaceCheckingTmp2 &&
//                      isWireInterfaceCheckingTmp3 && isWireInterfaceCheckingTmp4)
//                  break;

//          }


        //-------------------------Ждём завершения Проверка проводных интерфейсов------------------/

      ui->toolButton_digitalWireInterfaceChecking->setPalette(palettePrime);

  //    portDigitalInterfaceChecking->close();

    }

    //проверка проводных интерфейсов/


    //включить протокол СЭТ

    if(vectorIsCommandUse.at(8) && (repeatParameter == 0 || repeatParameter == 1 || repeatParameter == 2) ) {

        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

        QPalette palettePrime = ui->toolButton_MBusOff->palette();
        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

        QPalette palette = palettePrime;
        palette.setColor( QPalette::Button, QColor( Qt::red )  );

        QColor backgroundColor = palette.color(QPalette::Button);

        qDebug()<<"palette "<<palette
                <<"backgroundColor "<<backgroundColor.name()
                <<"backgroundColorPrime "<<backgroundColorPrime.name();

        ui->toolButton_MBusOff->setAutoFillBackground(true);
        ui->toolButton_MBusOff->setPalette( palette );

//      for(int l=0; l<4; l++) {

//        if(vectorIsWorkPlaceUse.at(l)) {
//            emit signalMBusOff(l);

//        }

//      }

 //       global::pause(1000);


        emit signalLog("<font color = \"#0000ff\">" + QString("Включение протокола СЭТ")  + '\n' + "</font>");

        emit signalMBusOffToThread(portOptical, portOptical2, portOptical3, portOptical4);

        //-------------------------Ждём завершения включения СЭТ------------------

        bool isMBusOffTmp1 = true;
        bool isMBusOffTmp2 = true;
        bool isMBusOffTmp3 = true;
        bool isMBusOffTmp4 = true;


          for(int e=0; e<50; e++) { //5 sec
              global::pause(100);

              if(ui->checkBox_workPlace1->isChecked()) {
                 isMBusOffTmp1 = isMBusOff1;

                 if(!vectorIsWorkPlaceUse.at(0)) isMBusOffTmp1 = true;
              }

              if(ui->checkBox_workPlace2->isChecked()) {
                 isMBusOffTmp2 = isMBusOff2;

                 if(!vectorIsWorkPlaceUse.at(1)) isMBusOffTmp2 = true;
              }

              if(ui->checkBox_workPlace3->isChecked()) {
                 isMBusOffTmp3 = isMBusOff3;

                 if(!vectorIsWorkPlaceUse.at(2)) isMBusOffTmp3 = true;
              }

              if(ui->checkBox_workPlace4->isChecked()) {
                 isMBusOffTmp4 = isMBusOff4;

                 if(!vectorIsWorkPlaceUse.at(3)) isMBusOffTmp4 = true;
              }


            if(isMBusOffTmp1 && isMBusOffTmp2 &&
                      isMBusOffTmp3 && isMBusOffTmp4)
                  break;

          }


        //-------------------------Ждём завершения включения СЭТ------------------/

      ui->toolButton_MBusOff->setPalette(palettePrime);

    }

    //включить протокол СЭТ/

//    global::pause(5000);

    //выключение режима калибровки

    if(vectorIsCommandUse.at(9)) {

        portOptical->close();
        portOptical2->close();
        portOptical3->close();
        portOptical4->close();
        portDigitalInterfaceChecking->close();
        portOptical->clear();
        portOptical2->clear();
        portOptical3->clear();
        portOptical4->clear();
        portDigitalInterfaceChecking->clear();

        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

        QPalette palettePrime = ui->toolButton_calibrationModeOff->palette();
        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

        QPalette palette = palettePrime;
        palette.setColor( QPalette::Button, QColor( Qt::red )  );

        QColor backgroundColor = palette.color(QPalette::Button);

        qDebug()<<"palette "<<palette
                <<"backgroundColor "<<backgroundColor.name()
                <<"backgroundColorPrime "<<backgroundColorPrime.name();

        ui->toolButton_calibrationModeOff->setAutoFillBackground(true);
        ui->toolButton_calibrationModeOff->setPalette( palette );

//      for(int l=0; l<4; l++) {

//        if(vectorIsWorkPlaceUse.at(l)) {
//            emit signalCalibrationModeOff(l);

//        }

//      }

        emit signalLog("<font color = \"#0000ff\">" + QString("Выключение режима калибровки")  + '\n' + "</font>");

        emit signalCalibModeOffToThread(portOptical, portOptical2, portOptical3, portOptical4);

        //-------------------------Ждём завершения Выключение режима калибровки------------------

        bool isCalibrationModeOffTmp1 = true;
        bool isCalibrationModeOffTmp2 = true;
        bool isCalibrationModeOffTmp3 = true;
        bool isCalibrationModeOffTmp4 = true;

//          if(!vectorIsWorkPlaceUse.at(0)) isPulsesInputVolumeTmp1 = true;
//          if(!vectorIsWorkPlaceUse.at(1)) isPulsesInputVolumeTmp2 = true;
//          if(!vectorIsWorkPlaceUse.at(2)) isPulsesInputVolumeTmp3 = true;
//          if(!vectorIsWorkPlaceUse.at(3)) isPulsesInputVolumeTmp4 = true;

          for(int e=0; e<75; e++) { //5 sec
              global::pause(100);

              if(ui->checkBox_workPlace1->isChecked()) {
                 isCalibrationModeOffTmp1 = isCalibrationModeOff1;

                 if(!vectorIsWorkPlaceUse.at(0)) isCalibrationModeOffTmp1 = true;
              }

              if(ui->checkBox_workPlace2->isChecked()) {
                 isCalibrationModeOffTmp2 = isCalibrationModeOff2;

                 if(!vectorIsWorkPlaceUse.at(1)) isCalibrationModeOffTmp2 = true;
              }

              if(ui->checkBox_workPlace3->isChecked()) {
                 isCalibrationModeOffTmp3 = isCalibrationModeOff3;

                 if(!vectorIsWorkPlaceUse.at(2)) isCalibrationModeOffTmp3 = true;
              }

              if(ui->checkBox_workPlace4->isChecked()) {
                 isCalibrationModeOffTmp4 = isCalibrationModeOff4;

                 if(!vectorIsWorkPlaceUse.at(3)) isCalibrationModeOffTmp4 = true;
              }
//              if(vectorIsWorkPlaceUse.at(0)) isCalibrationModeOffTmp1 = isCalibrationModeOff1;
//              if(vectorIsWorkPlaceUse.at(1)) isCalibrationModeOffTmp2 = isCalibrationModeOff2;
//              if(vectorIsWorkPlaceUse.at(2)) isCalibrationModeOffTmp3 = isCalibrationModeOff3;
//              if(vectorIsWorkPlaceUse.at(3)) isCalibrationModeOffTmp4 = isCalibrationModeOff4;

              if(isCalibrationModeOffTmp1 && isCalibrationModeOffTmp2 &&
                      isCalibrationModeOffTmp3 && isCalibrationModeOffTmp4)
                  break;

          }


        //-------------------------Ждём завершения Выключение режима калибровки------------------/

      ui->toolButton_calibrationModeOff->setPalette(palettePrime);

    }

    //выключение режима калибровки/


    //ищем последние сообщения об ошибках для каждого рабочего места
    QStringList errorList = errorString.split('\n');

    QString lastError1;
    QString lastError2;
    QString lastError3;
    QString lastError4;

    for(int k=(errorList.size() -1); k>-1; k--) {
        if(errorList.at(k).contains("Рабочее место: 1"))
          lastError1 = errorList.at(k);
    }

    for(int k=(errorList.size() -1); k>-1; k--) {
        if(errorList.at(k).contains("Рабочее место: 2"))
          lastError2 = errorList.at(k);
    }

    for(int k=(errorList.size() -1); k>-1; k--) {
        if(errorList.at(k).contains("Рабочее место: 3"))
          lastError3 = errorList.at(k);
    }

    for(int k=(errorList.size() -1); k>-1; k--) {
        if(errorList.at(k).contains("Рабочее место: 4"))
          lastError4 = errorList.at(k);
    }

    ui->label_StatusBar->setText(lastError1 + '\n' +
                                    lastError2 + '\n' +
                                    lastError3 + '\n' +
                                    lastError4);

//    ui->label_StatusBar->setToolTip(lastError1 + '\n' +
//                                    lastError2 + '\n' +
//                                    lastError3 + '\n' +
//                                    lastError4);

 //   ui->label_StatusBar->setToolTip(errorString);


//    ui->groupBox_result->setVisible(true);

    isCommandsEnded = true;
    repaint();


    //возвращение фокуса ввода на младшее рабочее место из выбранных

    if(ui->checkBox_workPlace4->isChecked() &&
       !ui->checkBox_workPlace3->isChecked()) {

        ui->spinBox_serial_4->setFocus(Qt::MouseFocusReason);
 //       ui->spinBox_serial_4->selectAll();
    }

    if(ui->checkBox_workPlace3->isChecked() &&
       !ui->checkBox_workPlace2->isChecked()) {

        ui->spinBox_serial_3->setFocus(Qt::MouseFocusReason);
  //      ui->spinBox_serial_3->selectAll();
    }

    if(ui->checkBox_workPlace2->isChecked() &&
       !ui->checkBox_workPlace1->isChecked()) {

        ui->spinBox_serial_2->setFocus(Qt::MouseFocusReason);
 //       ui->spinBox_serial_2->selectAll();
    }

    if(ui->checkBox_workPlace1->isChecked()) {

        ui->spinBox_serial_->setFocus(Qt::MouseFocusReason);
 //       ui->spinBox_serial_->selectAll();
    }


    //возвращение фокуса ввода на младшее рабочее место из выбранных/

//    ui->spinBox_serial_->grabKeyboard();
//    ui->spinBox_serial_2->grabKeyboard();
//    ui->spinBox_serial_3->grabKeyboard();
//    ui->spinBox_serial_4->grabKeyboard();


    //изменение порядка табуляции

//      //вывести список табуляции

//       //количество используемых рабочих мест
//       int count = 0;

//       if(ui->checkBox_workPlace1->isChecked()) count = count + 1;
//       if(ui->checkBox_workPlace2->isChecked()) count = count + 1;
//       if(ui->checkBox_workPlace3->isChecked()) count = count + 1;
//       if(ui->checkBox_workPlace4->isChecked()) count = count + 1;

//       if(count == 4) {
//          this->setTabOrder(ui->spinBox_serial_, ui->spinBox_serial_2);
//          this->setTabOrder(ui->spinBox_serial_2, ui->spinBox_serial_3);
//          this->setTabOrder(ui->spinBox_serial_3, ui->spinBox_serial_4);
//       }

//       //
//       if(count == 3) {
//           if(ui->checkBox_workPlace1->isChecked() && ui->checkBox_workPlace2->isChecked() //1, 2, 3
//              && ui->checkBox_workPlace3->isChecked() && !ui->checkBox_workPlace4->isChecked()) {

//               this->setTabOrder(ui->spinBox_serial_, ui->spinBox_serial_2);
//               this->setTabOrder(ui->spinBox_serial_2, ui->spinBox_serial_3);
//           }

//           if(!ui->checkBox_workPlace1->isChecked() && ui->checkBox_workPlace2->isChecked() //2, 3, 4
//              && ui->checkBox_workPlace3->isChecked() && ui->checkBox_workPlace4->isChecked()) {

//               this->setTabOrder(ui->spinBox_serial_2, ui->spinBox_serial_3);
//               this->setTabOrder(ui->spinBox_serial_3, ui->spinBox_serial_4);
//           }


//           if(ui->checkBox_workPlace1->isChecked() && !ui->checkBox_workPlace2->isChecked() //1, 3, 4
//              && ui->checkBox_workPlace3->isChecked() && ui->checkBox_workPlace4->isChecked()) {

//               this->setTabOrder(ui->spinBox_serial_, ui->spinBox_serial_3);
//               this->setTabOrder(ui->spinBox_serial_3, ui->spinBox_serial_4);
//           }

//           if(ui->checkBox_workPlace1->isChecked() && ui->checkBox_workPlace2->isChecked() //1, 2, 4
//              && !ui->checkBox_workPlace3->isChecked() && ui->checkBox_workPlace4->isChecked()) {

//               this->setTabOrder(ui->spinBox_serial_, ui->spinBox_serial_2);
//               this->setTabOrder(ui->spinBox_serial_2, ui->spinBox_serial_4);
//           }


//       }

//       //
//       if(count == 2) {
//          if(ui->checkBox_workPlace1->isChecked() && ui->checkBox_workPlace2->isChecked() //1, 2
//             && !ui->checkBox_workPlace3->isChecked() && !ui->checkBox_workPlace4->isChecked()) {

//              this->setTabOrder(ui->spinBox_serial_, ui->spinBox_serial_2);
//          }

//          if(ui->checkBox_workPlace1->isChecked() && !ui->checkBox_workPlace2->isChecked()//1, 3
//             && ui->checkBox_workPlace3->isChecked() && !ui->checkBox_workPlace4->isChecked()) {

//              this->setTabOrder(ui->spinBox_serial_, ui->spinBox_serial_3);
//          }

//          if(ui->checkBox_workPlace1->isChecked() && !ui->checkBox_workPlace2->isChecked()//1, 4
//             && !ui->checkBox_workPlace3->isChecked() && ui->checkBox_workPlace4->isChecked()) {

//              this->setTabOrder(ui->spinBox_serial_, ui->spinBox_serial_4);
//          }

//          if(!ui->checkBox_workPlace1->isChecked() && ui->checkBox_workPlace2->isChecked()//2, 3
//             && ui->checkBox_workPlace3->isChecked() && !ui->checkBox_workPlace4->isChecked()) {

//              this->setTabOrder(ui->spinBox_serial_2, ui->spinBox_serial_3);
//          }

//          if(!ui->checkBox_workPlace1->isChecked() && ui->checkBox_workPlace2->isChecked()//2, 4
//             && !ui->checkBox_workPlace3->isChecked() && ui->checkBox_workPlace4->isChecked()) {

//              this->setTabOrder(ui->spinBox_serial_2, ui->spinBox_serial_4);
//          }

//          if(!ui->checkBox_workPlace1->isChecked() && !ui->checkBox_workPlace2->isChecked()//3, 4
//             && ui->checkBox_workPlace3->isChecked() && ui->checkBox_workPlace4->isChecked()) {

//              this->setTabOrder(ui->spinBox_serial_3, ui->spinBox_serial_4);
//          }

//       }


    repeatParameter = 0;

    //изменение порядка табуляции/

  if(!isRunWithoutConnect) {//если связь с сервером есть

    global::pause(500);

    //если хотя бы один результат Не годен, спрашиваем о необходимости записи в бд
    if(workPlace1ResultString == tr("Не годен") || workPlace2ResultString == tr("Не годен") ||
            workPlace3ResultString == tr("Не годен") || workPlace4ResultString == tr("Не годен")) {

        if(dialogWritingDB->exec() == QDialog::Accepted) {

            isNoteWriting = true;

            on_toolButton_externalServerConnect_clicked();

        }
        else {
            isNoteWriting = false;

            saveCounterCheckingResult(1, QString());
        }

    }
    else {

        isNoteWriting = true;

        on_toolButton_externalServerConnect_clicked();

    }


  }//if(!isRunWithoutConnect)


}


void MainWindow::on_checkBox_workPlace1_clicked()
{

}

void MainWindow::on_action_3_triggered()
{
    formLog->show();
}

void MainWindow::on_textBrowser_textChanged()
{
//    QString str = ui->textBrowser->toPlainText();

//    emit signalLog(str);
}

void MainWindow::on_toolButton_setAddressDefault_clicked()
{
    for(int u=0; u<4; u++) {
        setPrimeAddressDefault(u);
    }
}



void MainWindow::on_checkBox_OneWorkPlace_clicked(bool checked)
{
    if(checked) {
        ui->groupBox_workPlace2->setEnabled(false);
        ui->groupBox_workPlace3->setEnabled(false);
        ui->groupBox_workPlace4->setEnabled(false);

        ui->toolButton_executeCommands->setEnabled(false);

        ui->toolButton_writeParams->setEnabled(true);
        ui->toolButton_startCalibration->setEnabled(true);
        ui->toolButton_pulsesOutputHeat->setEnabled(true);
        ui->toolButton_pulsesInputVolume->setEnabled(true);
        ui->toolButton_pulsesOutputOff->setEnabled(true);
        ui->toolButton_MBusOn->setEnabled(true);
        ui->toolButton_CheckMbus->setEnabled(true);
        ui->toolButton_calibrationModeOff->setEnabled(true);
        ui->toolButton_digitalWireInterfaceChecking->setEnabled(true);
        ui->toolButton_MBusOff->setEnabled(true);
    }
    else {
        ui->groupBox_workPlace2->setEnabled(true);
        ui->groupBox_workPlace3->setEnabled(true);
        ui->groupBox_workPlace4->setEnabled(true);

        ui->toolButton_executeCommands->setEnabled(true);

        ui->toolButton_writeParams->setEnabled(false);
        ui->toolButton_startCalibration->setEnabled(false);
        ui->toolButton_pulsesOutputHeat->setEnabled(false);
        ui->toolButton_pulsesInputVolume->setEnabled(false);
        ui->toolButton_pulsesOutputOff->setEnabled(false);
        ui->toolButton_MBusOn->setEnabled(false);
        ui->toolButton_CheckMbus->setEnabled(false);
        ui->toolButton_calibrationModeOff->setEnabled(false);
        ui->toolButton_digitalWireInterfaceChecking->setEnabled(false);
        ui->toolButton_MBusOff->setEnabled(false);
    }
}



void MainWindow::workPlaceOff(int currentIndicatorNumber)
{

    switch (currentIndicatorNumber) {
    case 0:
//        ui->checkBox_workPlace1->setChecked(false);
        vectorIsWorkPlaceUse[0] = false;
        break;
    case 1:
//        ui->checkBox_workPlace2->setChecked(false);
        vectorIsWorkPlaceUse[1] = false;
        break;
    case 2:
 //       ui->checkBox_workPlace3->setChecked(false);
        vectorIsWorkPlaceUse[2] = false;
        break;
    case 3:
//        ui->checkBox_workPlace4->setChecked(false);
        vectorIsWorkPlaceUse[3] = false;
        break;
    default:
        break;
    }

   qDebug()<<"MainWindow::workPlaceOff vectorIsWorkPlaceUse "<<vectorIsWorkPlaceUse;

}







void MainWindow::on_checkBox_OneWorkPlace_clicked()
{

}

//void MainWindow::slotNewThreadOne()
//{


//    int arg = 0;
//    QThread *thread = QThread::create(&MainWindow::writeParams(0));
//    thread->start();
//}

void MainWindow::slotGetLog(QString message)
{
  //  emit signalLog(message);

    ui->textBrowser->append(message);

    emit signalLog(QTime::currentTime().toString("hh:mm:ss") + " " + message);
}

void MainWindow::slotGetLogFromGefest(LogType type, QString str)
{
//    ui->textBrowser->append(str);
}


void MainWindow::on_toolButton_stopThreads_clicked()
{
    Thread1.exit();
    Thread2.exit();
    Thread3.exit();
    Thread4.exit();
}

void MainWindow::slotWorkPlaceOff(int currentIndicator)
{
    workPlaceOff(currentIndicator);
}

void MainWindow::slotError(QString errorStr)
{

  //  errorString.append(errorStr);

    ui->textBrowser->append("<font color = \"#ff0000\">" + errorStr + "</font>");

    emit signalLog("<font color = \"#ff0000\">" + QTime::currentTime().toString("hh:mm:ss") + " " + errorStr + "</font>");

    errorString.append(errorStr);

    ui->label_StatusBar->setText(errorStr);
}

void MainWindow::slotCheckWritingError(int currentIndicator)
{

    updateVectorStateMatrix(currentIndicator);

    checkWritingError(currentIndicator);

}


void MainWindow::slotCheckCalibrationError(int currentIndicator)
{

    updateVectorStateMatrix(currentIndicator);

    checkCalibrationError(currentIndicator);
}

void MainWindow::slotGetRMV(int color, QString str, int currentIndicator)
{
    if(currentIndicator == 0) {
        if(color == 0) {
          QPalette pal = ui->lineEdit_RMV_ErrorFlags->palette();
          pal.setColor(QPalette::Text, Qt::darkGreen); // assuming Mid is the color you want to change.
          ui->lineEdit_RMV_ErrorFlags->setPalette(pal);
          ui->lineEdit_RMV_ErrorFlags->setText(str);
//          ui->lineEdit_RMV_ErrorFlags->setText("<font color = \"#00ff00\">" + str + '\n' + "</font>");
        }
        if(color == 1) {
            QPalette pal = ui->lineEdit_RMV_ErrorFlags->palette();
            pal.setColor(QPalette::Text, Qt::black); // assuming Mid is the color you want to change.
            pal.setColor(QPalette::Base, Qt::red);
            ui->lineEdit_RMV_ErrorFlags->setPalette(pal);
            ui->lineEdit_RMV_ErrorFlags->setText(str);
  //        ui->lineEdit_RMV_ErrorFlags->setText("<font color = \"#000000\">" + str + '\n' + "</font>");
        }
    }

    if(currentIndicator == 1) {
        if(color == 0) {
          QPalette pal = ui->lineEdit_RMV_ErrorFlags_2->palette();
          pal.setColor(QPalette::Text, Qt::darkGreen); // assuming Mid is the color you want to change.
          ui->lineEdit_RMV_ErrorFlags_2->setPalette(pal);
          ui->lineEdit_RMV_ErrorFlags_2->setText(str);
//          ui->lineEdit_RMV_ErrorFlags->setText("<font color = \"#00ff00\">" + str + '\n' + "</font>");
        }
        if(color == 1) {
            QPalette pal = ui->lineEdit_RMV_ErrorFlags_2->palette();
            pal.setColor(QPalette::Text, Qt::black); // assuming Mid is the color you want to change.
            pal.setColor(QPalette::Base, Qt::red);
            ui->lineEdit_RMV_ErrorFlags_2->setPalette(pal);
            ui->lineEdit_RMV_ErrorFlags_2->setText(str);
  //        ui->lineEdit_RMV_ErrorFlags->setText("<font color = \"#000000\">" + str + '\n' + "</font>");
        }
//        if(color == 0)
//          ui->lineEdit_RMV_ErrorFlags_2->setText("<font color = \"#00ff00\">" + str  + '\n' + "</font>");
//        if(color == 1)
//          ui->lineEdit_RMV_ErrorFlags_2->setText("<font color = \"#000000\">" + str  + '\n' + "</font>");
    }

    if(currentIndicator == 2) {
        if(color == 0) {
          QPalette pal = ui->lineEdit_RMV_ErrorFlags_3->palette();
          pal.setColor(QPalette::Text, Qt::darkGreen); // assuming Mid is the color you want to change.
          ui->lineEdit_RMV_ErrorFlags_3->setPalette(pal);
          ui->lineEdit_RMV_ErrorFlags_3->setText(str);
//          ui->lineEdit_RMV_ErrorFlags->setText("<font color = \"#00ff00\">" + str + '\n' + "</font>");
        }
        if(color == 1) {
            QPalette pal = ui->lineEdit_RMV_ErrorFlags_3->palette();
            pal.setColor(QPalette::Text, Qt::black); // assuming Mid is the color you want to change.
            pal.setColor(QPalette::Base, Qt::red);
            ui->lineEdit_RMV_ErrorFlags_3->setPalette(pal);
            ui->lineEdit_RMV_ErrorFlags_3->setText(str);
  //        ui->lineEdit_RMV_ErrorFlags->setText("<font color = \"#000000\">" + str + '\n' + "</font>");
        }
//        if(color == 0)
//          ui->lineEdit_RMV_ErrorFlags_3->setText("<font color = \"#00ff00\">" + str  + '\n' + "</font>");
//        if(color == 1)
//          ui->lineEdit_RMV_ErrorFlags_3->setText("<font color = \"#000000\">" + str  + '\n' + "</font>");
    }

    if(currentIndicator == 3) {
        if(color == 0) {
          QPalette pal = ui->lineEdit_RMV_ErrorFlags_4->palette();
          pal.setColor(QPalette::Text, Qt::darkGreen); // assuming Mid is the color you want to change.
          ui->lineEdit_RMV_ErrorFlags_4->setPalette(pal);
          ui->lineEdit_RMV_ErrorFlags_4->setText(str);
//          ui->lineEdit_RMV_ErrorFlags->setText("<font color = \"#00ff00\">" + str + '\n' + "</font>");
        }
        if(color == 1) {
            QPalette pal = ui->lineEdit_RMV_ErrorFlags_4->palette();
            pal.setColor(QPalette::Text, Qt::black); // assuming Mid is the color you want to change.
            pal.setColor(QPalette::Base, Qt::red);
            ui->lineEdit_RMV_ErrorFlags_4->setPalette(pal);
            ui->lineEdit_RMV_ErrorFlags_4->setText(str);
  //        ui->lineEdit_RMV_ErrorFlags->setText("<font color = \"#000000\">" + str + '\n' + "</font>");
        }
//        if(color == 0)
//          ui->lineEdit_RMV_ErrorFlags_4->setText("<font color = \"#00ff00\">" + str  + '\n' + "</font>");
//        if(color == 1)
//          ui->lineEdit_RMV_ErrorFlags_4->setText("<font color = \"#000000\">" + str  + '\n' + "</font>");
    }
}

void MainWindow::slotCheckPulsesOutputHeatError(int currentIndicator)
{

    updateVectorStateMatrix(currentIndicator);

    checkPulsesOutputHeat(currentIndicator);
}

void MainWindow::slotCheckPulsesInputVolumeError(int currentIndicator)
{

    updateVectorStateMatrix(currentIndicator);

    checkPulsesInputVolume(currentIndicator);
}

void MainWindow::slotCheckPulsesOutputDefError(int currentIndicator)
{

    updateVectorStateMatrix(currentIndicator);

    checkPulsesOutputDefault(currentIndicator);
}

void MainWindow::slotCheckMBusOnError(int currentIndicator)
{
    updateVectorStateMatrix(currentIndicator);

    checkMbusOn(currentIndicator);
}

void MainWindow::slotCheckMBusCheckError(int currentIndicator)
{
    updateVectorStateMatrix(currentIndicator);

    checkMbusCheck(currentIndicator);
}

void MainWindow::slotCheckCalibModeOffError(int currentIndicator)
{
    updateVectorStateMatrix(currentIndicator);

    checkCalibrationModeOff(currentIndicator);
}

void MainWindow::slotCheckWireInterfaceChecking(int currentIndicator)
{
    updateVectorStateMatrix(currentIndicator);

    checkWireInterfaceChecking(currentIndicator);
}

void MainWindow::slotCheckMBusOffError(int currentIndicator)
{
    updateVectorStateMatrix(currentIndicator);

    checkMbusOff(currentIndicator);
}

void MainWindow::updateVectorStateMatrix(int currentIndicator)
{
    QVector<QVector<bool>> vectorMatrixFromObject;

    switch (currentIndicator) {
    case 0:
        vectorMatrixFromObject = ObjectThread1->getVectorMatrix();
        qDebug()<<"MainWindow::slotCheckWritingError. ObjectThread1->getVectorMatrix()";
        break;
    case 1:
        vectorMatrixFromObject = ObjectThread2->getVectorMatrix();
        qDebug()<<"MainWindow::slotCheckWritingError. ObjectThread2->getVectorMatrix()";
        break;
    case 2:
        vectorMatrixFromObject = ObjectThread3->getVectorMatrix();
        qDebug()<<"MainWindow::slotCheckWritingError. ObjectThread3->getVectorMatrix()";
        break;
    case 3:
        vectorMatrixFromObject = ObjectThread4->getVectorMatrix();
        qDebug()<<"MainWindow::slotCheckWritingError. ObjectThread4->getVectorMatrix()";
        break;
    default:
        break;
    }

    for(int r=0; r<vectorMatrixFromObject.size(); r++) {
        for(int u=0; u<4; u++) {

            if(vectorMatrixFromObject.at(r).at(u)) {
                vectorIndicatorStateMatrix[r][u] = true;
            }

        }
    }

//    //если какой-то кружок красный(true) , то остальные под ним тоже делаем красными
//    bool isErrorOccured1 = false;
//    bool isErrorOccured2 = false;
//    bool isErrorOccured3 = false;
//    bool isErrorOccured4 = false;

//    int fistRowError1; int fistRowError2; int fistRowError3; int fistRowError4;//номер команды, в которой есть ошибка

//    for(int m=0; m<vectorIndicatorStateMatrix.size(); m++) {
//        if(vectorIndicatorStateMatrix.at(m).at(0) == true) {
//            isErrorOccured1 = true;
//            fistRowError1 = m;
//            break;
//        }
//    }

//    for(int m=0; m<vectorIndicatorStateMatrix.size(); m++) {
//        if(vectorIndicatorStateMatrix.at(m).at(1) == true) {
//            isErrorOccured2 = true;
//            fistRowError2 = m;
//            break;
//        }
//    }

//    for(int m=0; m<vectorIndicatorStateMatrix.size(); m++) {
//        if(vectorIndicatorStateMatrix.at(m).at(2) == true) {
//            isErrorOccured3 = true;
//            fistRowError3 = m;
//            break;
//        }
//    }

//    for(int m=0; m<vectorIndicatorStateMatrix.size(); m++) {
//        if(vectorIndicatorStateMatrix.at(m).at(3) == true) {
//            isErrorOccured4 = true;
//            fistRowError4 = m;
//            break;
//        }
//    }

//    //ниже команды, в которой есть ошибка, забраковываем все кружки
//    if(isErrorOccured1) {

//       for(int r=fistRowError1+1; r<vectorIndicatorStateMatrix.size(); r++) {
//           vectorIndicatorStateMatrix[r][0] = true;
//       }
//    }
//    //

//    if(isErrorOccured2) {

//       for(int r=fistRowError2+1; r<vectorIndicatorStateMatrix.size(); r++) {
//           vectorIndicatorStateMatrix[r][1] = true;
//       }
//    }
//    //

//    if(isErrorOccured3) {

//       for(int r=fistRowError3+1; r<vectorIndicatorStateMatrix.size(); r++) {
//           vectorIndicatorStateMatrix[r][2] = true;
//       }
//    }
//    //

//    if(isErrorOccured4) {

//       for(int r=fistRowError4+1; r<vectorIndicatorStateMatrix.size(); r++) {
//           vectorIndicatorStateMatrix[r][3] = true;
//       }
//    }

//    qDebug()<<"";


}

void MainWindow::on_spinBox_serial__valueChanged(const QString &arg1)
{
    QString argStr = arg1;// = arg1.left(ui->lineEdit_serial->cursorPosition());

    emit signalSendSerial(ui->lineEdit_serial->text() + argStr);
}

void MainWindow::on_spinBox_serial_2_valueChanged(const QString &arg1)
{
    QString argStr = arg1;// = arg1.left(ui->lineEdit_serial->cursorPosition());

    emit signalSendSerial2(ui->lineEdit_serial_2->text() + argStr);
}

void MainWindow::on_spinBox_serial_3_valueChanged(const QString &arg1)
{
    QString argStr = arg1;// = arg1.left(ui->lineEdit_serial->cursorPosition());

    emit signalSendSerial3(ui->lineEdit_serial_3->text() + argStr);
}

void MainWindow::on_spinBox_serial_4_valueChanged(const QString &arg1)
{
    QString argStr = arg1;// = arg1.left(ui->lineEdit_serial->cursorPosition());

    emit signalSendSerial4(ui->lineEdit_serial_4->text() + argStr);
}


void MainWindow::setCurrentDateToSerial()
{
    QDate curDate = QDate::currentDate();

    int curYear = curDate.year();
    int curMonth = curDate.month();

    QString yearStr = QString::number(curYear);
    QString monthStr = QString::number(curMonth);

    if(monthStr.length()<2) monthStr.insert(0, '0');

    ui->lineEdit_serial->setText(yearStr.right(1) + monthStr);
    ui->lineEdit_serial_2->setText(yearStr.right(1) + monthStr);
    ui->lineEdit_serial_3->setText(yearStr.right(1) + monthStr);
    ui->lineEdit_serial_4->setText(yearStr.right(1) + monthStr);
}





void MainWindow::on_checkBox_MBusOffUse_clicked()
{

}

void MainWindow::keyPressEvent(QKeyEvent *event)
{
       qDebug()<<"MainWindow::keyPressEvent(QKeyEvent *event)"<<event->key();
       qDebug()<<"this->focusWidget() "<<this->focusWidget();

    if(isCommandsEnded) { //принудительная табуляция

     if(  (this->focusWidget()->objectName() == "spinBox_serial_") ||
         (this->focusWidget()->objectName() == "spinBox_serial_2") ||
         (this->focusWidget()->objectName() == "spinBox_serial_3") ||
          (this->focusWidget()->objectName() == "spinBox_serial_4") ) {

         //количество используемых рабочих мест
         int count = 0;

         if(ui->checkBox_workPlace1->isChecked()) count = count + 1;
         if(ui->checkBox_workPlace2->isChecked()) count = count + 1;
         if(ui->checkBox_workPlace3->isChecked()) count = count + 1;
         if(ui->checkBox_workPlace4->isChecked()) count = count + 1;

  //       if(count == 4) {

         int placeFocus;

         if(this->focusWidget()->objectName() == "spinBox_serial_") placeFocus = 1;
         if(this->focusWidget()->objectName() == "spinBox_serial_2") placeFocus = 2;
         if(this->focusWidget()->objectName() == "spinBox_serial_3") placeFocus = 3;
         if(this->focusWidget()->objectName() == "spinBox_serial_4") placeFocus = 4;


      if(event->key() == 16777220) {

        switch (placeFocus) {
        case 1:
             if(ui->checkBox_workPlace2->isChecked()) {
                 ui->spinBox_serial_2->setFocus(Qt::MouseFocusReason);
    //             ui->spinBox_serial_2->selectAll();
             }

             if(!ui->checkBox_workPlace2->isChecked() && ui->checkBox_workPlace3->isChecked()) {
                 ui->spinBox_serial_3->setFocus(Qt::MouseFocusReason);
    //             ui->spinBox_serial_3->selectAll();
             }

             if(!ui->checkBox_workPlace2->isChecked() && !ui->checkBox_workPlace3->isChecked() && ui->checkBox_workPlace4->isChecked()) {
                 ui->spinBox_serial_4->setFocus(Qt::MouseFocusReason);
     //            ui->spinBox_serial_4->selectAll();
             }

            break;
        case 2:
             if(ui->checkBox_workPlace3->isChecked()) {
                 ui->spinBox_serial_3->setFocus(Qt::MouseFocusReason);
   //              ui->spinBox_serial_3->selectAll();
             }

             if(!ui->checkBox_workPlace3->isChecked() && ui->checkBox_workPlace4->isChecked()) {
                 ui->spinBox_serial_4->setFocus(Qt::MouseFocusReason);
    //             ui->spinBox_serial_4->selectAll();
             }

             if(!ui->checkBox_workPlace3->isChecked() && !ui->checkBox_workPlace4->isChecked() && ui->checkBox_workPlace1->isChecked()) {
                 ui->spinBox_serial_->setFocus(Qt::MouseFocusReason);
    //             ui->spinBox_serial_->selectAll();
             }

            break;
        case 3:
            if(ui->checkBox_workPlace4->isChecked()) {
                ui->spinBox_serial_4->setFocus(Qt::MouseFocusReason);
    //            ui->spinBox_serial_4->selectAll();
            }

            if(!ui->checkBox_workPlace4->isChecked() && ui->checkBox_workPlace1->isChecked()) {
                ui->spinBox_serial_->setFocus(Qt::MouseFocusReason);
   //             ui->spinBox_serial_->selectAll();
            }

            if(!ui->checkBox_workPlace4->isChecked() && !ui->checkBox_workPlace1->isChecked() && ui->checkBox_workPlace2->isChecked()) {
                ui->spinBox_serial_2->setFocus(Qt::MouseFocusReason);
    //            ui->spinBox_serial_2->selectAll();
            }
            break;
        case 4:
            if(ui->checkBox_workPlace1->isChecked()) {
                ui->spinBox_serial_->setFocus(Qt::MouseFocusReason);
   //             ui->spinBox_serial_->selectAll();
            }

            if(!ui->checkBox_workPlace1->isChecked() && ui->checkBox_workPlace2->isChecked()) {
                ui->spinBox_serial_2->setFocus(Qt::MouseFocusReason);
    //            ui->spinBox_serial_2->selectAll();
            }

            if(!ui->checkBox_workPlace1->isChecked() && !ui->checkBox_workPlace2->isChecked() && ui->checkBox_workPlace3->isChecked()) {
                ui->spinBox_serial_3->setFocus(Qt::MouseFocusReason);
    //            ui->spinBox_serial_3->selectAll();
            }
            break;

        default:
            break;
        }


      } //if(event->key() == Qt::Key_Right) {  /


     }
//     if(  (this->focusWidget()->objectName() == "spinBox_serial_") ||
//         (this->focusWidget()->objectName() == "spinBox_serial_2") ||
//         (this->focusWidget()->objectName() == "spinBox_serial_3") ||
//          (this->focusWidget()->objectName() == "spinBox_serial_4") ) {  /



    } //принудительная табуляция/

    else {

       if( (event->key() == 16777220) || (event->key() ==0x20) || (event->key() ==0x0D) ) {
           KeyEventEnterBool = true;
       }

    }

}

void MainWindow::on_toolButton_wireInterfaceCheckRepeat_clicked()
{

    repeatParameter = 2;

    on_toolButton_executeCommands_clicked();

//    ui->label_StatusBar->clear();

//    isCommandsEnded = false;

//    if(ui->checkBox_workPlace1->isChecked()) vectorIsWorkPlaceUse[0] = true;
//    if(ui->checkBox_workPlace2->isChecked()) vectorIsWorkPlaceUse[1] = true;
//    if(ui->checkBox_workPlace3->isChecked()) vectorIsWorkPlaceUse[2] = true;
//    if(ui->checkBox_workPlace4->isChecked()) vectorIsWorkPlaceUse[3] = true;

//    isWireInterfaceChecking1 = false;
//    isWireInterfaceChecking2 = false;
//    isWireInterfaceChecking3 = false;
//    isWireInterfaceChecking4 = false;

//    vectorIndicatorStateMatrix[7].fill(false);

//    ObjectThread1->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
//    ObjectThread2->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
//    ObjectThread3->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
//    ObjectThread4->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);

//    repaint();

//    //проверка проводных интерфейсов

//    if(vectorIsCommandUse.at(7)) {

//        portOptical->close();
//        portOptical2->close();
//        portOptical3->close();
//        portOptical4->close();
//        portDigitalInterfaceChecking->close();
//        portOptical->clear();
//        portOptical2->clear();
//        portOptical3->clear();
//        portOptical4->clear();
//        portDigitalInterfaceChecking->clear();

//        ObjectThread1->moveToThread(&Thread1);
//        ObjectThread2->moveToThread(&Thread2);
//        ObjectThread3->moveToThread(&Thread3);
//        ObjectThread4->moveToThread(&Thread4);

//        Thread1.start();
//        Thread2.start();
//        Thread3.start();
//        Thread4.start();

//        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
//        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
//        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
//        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

//        QPalette palettePrime = ui->toolButton_digitalWireInterfaceChecking->palette();
//        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

//        QPalette palette = palettePrime;
//        palette.setColor( QPalette::Button, QColor( Qt::red )  );

//        QColor backgroundColor = palette.color(QPalette::Button);

//        qDebug()<<"palette "<<palette
//                <<"backgroundColor "<<backgroundColor.name()
//                <<"backgroundColorPrime "<<backgroundColorPrime.name();

//        ui->toolButton_digitalWireInterfaceChecking->setAutoFillBackground(true);
//        ui->toolButton_digitalWireInterfaceChecking->setPalette( palette );

// //       global::pause(10000);

//        emit signalLog("<font color = \"#0000ff\">" + QString("Проверка проводных интерфейсов")  + '\n' + "</font>");

//      for(int l=0; l<4; l++) {

//        if(vectorIsWorkPlaceUse.at(l)) {
//            emit signalWireInterfaceChecking(l);

//        }

//      }

//        //-------------------------Ждём завершения Проверка проводных интерфейсов------------------


//        //-------------------------Ждём завершения Проверка проводных интерфейсов------------------/

//      ui->toolButton_digitalWireInterfaceChecking->setPalette(palettePrime);

//    }


//    isCommandsEnded = true;
//    repaint();

//    //проверка проводных интерфейсов/

//    global::pause(500);

//    //если хотя бы один результат Не годен, спрашиваем о необходимости записи в бд
//    if(workPlace1ResultString == tr("Не годен") || workPlace2ResultString == tr("Не годен") ||
//            workPlace3ResultString == tr("Не годен") || workPlace4ResultString == tr("Не годен")) {

//        if(dialogWritingDB->exec() == QDialog::Accepted) {

//            isNoteWriting = true;

//            on_toolButton_externalServerConnect_clicked();

//        }
//        else {
//            isNoteWriting = false;

//            saveCounterCheckingResult(1, QString());
//        }

//    }
//    else {

//        isNoteWriting = true;

//        on_toolButton_externalServerConnect_clicked();

//    }


}

//bool MainWindow::event(QEvent *event)
//{
//    qDebug()<<"MainWindow::event";

//    if(event->type() == QEvent::KeyPress) {
//        qDebug()<<"event->type() == QEvent::KeyPress "<<event->KeyPress;
//    }

//    event->accept();
//}

//bool MainWindow::eventFilter(QObject *watched, QEvent *event)
//{

//    if (watched == ui->spinBox_serial_ && event->type() == QEvent::KeyPress) {

//       qDebug()<<"MainWindow::eventFilter(QObject *watched, QEvent *event)";

//        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);
//        if (keyEvent->key() == Qt::Key_Tab) {
//            // Special tab handling
//            return true;
//        } else
//            return false;
//    }

//    return false;
//}

bool MainWindow::serverConnection()
{
//    БД на сервере.
//    адрес: 192.168.100.1
//    Порт: 5432
//    База: gefest
//    Пользователь: gefest
//    Пароль: gefest

//    В таблице "device" поля
//    id: integer автоинкрементный идентификатор
//    serial: integer - для серийного номера
//    eb: jsonb - данные электронного блока
//    eb_result: jsonb - результаты проверки электронного блока
//    eb_date: timestamp - дата и время записи результатов

    dataBase = QSqlDatabase::addDatabase("QPSQL");

//    dataBase.setHostName("192.168.100.1");
//    dataBase.setDatabaseName("gefest");
//    dataBase.setUserName("gefest");
//    dataBase.setPassword("gefest");
//    dataBase.setPort(5432);

        dataBase.setHostName("localhost");
        dataBase.setDatabaseName("postgres");
        dataBase.setUserName("postgres");
        dataBase.setPassword("1");
        dataBase.setPort(5432);

    QStringList driversList = QSqlDatabase::drivers();

    bool connected = dataBase.open();

    QStringList tableList = dataBase.tables(QSql::Tables);

    if(!connected) {
        QMessageBox::information(this, "", tr("Не удалось подключиться к серверу. Ошибка: ") + dataBase.lastError().text());
        return false;
    }


    return true;

}

bool MainWindow::serverConnectWithPasswordExtServ(QString username, QString password)
{
        dataBase = QSqlDatabase::addDatabase("QPSQL");

        dataBase.setHostName(hostName);//("192.168.100.1"); //LISA "192.168.10.1", BART "192.168.100.1"
        dataBase.setDatabaseName(dataBaseName);//("gefest");
        dataBase.setUserName(dataBaseUserName);//(username);//("gefest");
        dataBase.setPassword(dataBasePassword);//(password);//("gefest");
        dataBase.setPort(5432);

        QStringList driversList = QSqlDatabase::drivers();

        for(int m=0; m<driversList.size(); m++) {
           ui->textBrowser->append(driversList.at(m));
        }

        bool connected = dataBase.open();

        connectCondition = connected;

        QStringList tableList = dataBase.tables(QSql::Tables);

        if(!connected) {

            dialogIsRunWithoutConnect->setText(tr("Не удалось подключиться к серверу. Ошибка: ") + dataBase.lastError().text());

            //установить текс на диалог tr("Не удалось подключиться к серверу. Ошибка: ") + dataBase.lastError().text()

            if(dialogIsRunWithoutConnect->exec() == QDialog::Accepted) {
                isRunWithoutConnect = true;
                isLoginPasswordOk = true;
                dialogLoginDataBase->close();
                dialogIsRunWithoutConnect->close();
                this->show();

                ui->ResultTable->setEnabled(false);
                ui->action_users->setEnabled(false);
            }
     //       QMessageBox::information(this, "", tr("Не удалось подключиться к серверу. Ошибка: ") + dataBase.lastError().text());
            ui->label_messageBar->setText(/*"<font color = \"#ff0000\">" +*/ tr("Соединение с базой данных не установлено") /*+ "</font>"*/);
            return false;
        }

        ui->label_messageBar->clear();


        return true;
}

bool MainWindow::serverConnectionWithPassword(QString username, QString password)
{
    dataBase = QSqlDatabase::addDatabase("QPSQL");

//    dataBase.setHostName("192.168.100.1");
//    dataBase.setDatabaseName("gefest");
//    dataBase.setUserName("gefest");
//    dataBase.setPassword("gefest");
//    dataBase.setPort(5432);

        dataBase.setHostName("localhost");
        dataBase.setDatabaseName("postgres");//("device");
        dataBase.setUserName(username);//("postgres");
        dataBase.setPassword(password);
        dataBase.setPort(5432);

    QStringList driversList = QSqlDatabase::drivers();

    bool connected = dataBase.open();

    QStringList tableList = dataBase.tables(QSql::Tables);

    if(!connected) {
        QMessageBox::information(this, "", tr("Не удалось подключиться к серверу. Ошибка: ") + dataBase.lastError().text());
        return false;
    }


    return true;
}

void MainWindow::on_toolButton_serverConnect_clicked()
{
    bool serverCon = serverConnectionWithPassword(ui->lineEdit_userDB->text(), ui->lineEdit_userPassword->text());//serverConnection();

    if(serverCon) {
//        QMessageBox::information(this, "", tr("Подключение установлено"));
//        dialogLoginDataBase->close();
    }

//    if(serverCon) {
//        SelectQuery(QString());
//    }
}

bool MainWindow::SelectQuery(QString str)
{

    QString kavichka = QString('"');
    QString tab = "table2";
    QString queryString = "Select * From " + kavichka + tab + kavichka + ";";

    QSqlQuery sqlQuery(dataBase);

    if(!sqlQuery.exec(queryString)) {
       QString lastOkQuery = sqlQuery.lastError().text();
       emit slotError(lastOkQuery + '\n');
       return false;
    }

    //разбираем результат запроса
    while (sqlQuery.next()) {
      QString name = sqlQuery.value(0).toString();
      int number = sqlQuery.value(1).toInt();
      bool bool3 = sqlQuery.value(2).toBool();
      qDebug() << name << number << bool3;
    }

    return true;

}

bool MainWindow::execQuery(QString queryString)
{

//    QString kavichka = QString('"');
//    QString tab = "table2";
//    queryString = "Select * From " + kavichka + tab + kavichka + ";";

    dataBase.transaction();

    QSqlQuery sqlQuery(dataBase);

    if(!sqlQuery.exec(queryString)) {
       QString lastErrorQuery = sqlQuery.lastError().text();
       dataBase.rollback();
 //      emit slotError(lastErrorQuery + '\n');
       QMessageBox::information(this, "", lastErrorQuery);
       return false;
    }

    //разбираем результат запроса
//    while (sqlQuery.next()) {
//      QString name = sqlQuery.value(0).toString();
//      int number = sqlQuery.value(1).toInt();
//      bool bool3 = sqlQuery.value(2).toBool();
//      qDebug() << name << number << bool3;
//    }

    currentQueryResult = sqlQuery;


//    qDebug()<<"sqlQuery "<<sqlQuery;

    dataBase.commit();

    return true;
}

void MainWindow::makeJsonDoc(QString PCB_SN, QString Rref1,
                             QString Rref2, QString usable) //аргументы не используются
{
//    QJsonArray arr;
//    QJsonValue valPCB_SN = QJsonValue(PCB_SN);
//    QJsonValue valRref1 = QJsonValue(Rref1);
//    QJsonValue valRref2 = QJsonValue(Rref2);
//    QJsonValue valUsable = QJsonValue(usable);

    QString pcb1 = paramsMapToThreads["PCB_SN_ByteArray"].toByteArray().toHex();

    QJsonObject object1
    {
  //      {"PCB_SN", pcb1},
        {"Rref1", ObjectThread1->getR_Ref1_1()},//Rref1
        {"Rref2", ObjectThread1->getR_Ref2_1()}//Rref2
  //      {"Usable", workPlace1ResultString}
  //      {"Engineer", humanNameResult}
    };

    currentJsonObject1 = object1;
    //
    QString pcb2 = paramsMapToThreads["PCB_SN_ByteArray2"].toByteArray().toHex();

    QJsonObject object2
    {
//        {"PCB_SN", pcb2},
        {"Rref1", ObjectThread2->getR_Ref1_2()},
        {"Rref2", ObjectThread2->getR_Ref2_2()}
  //      {"Usable", workPlace2ResultString}
  //      {"Engineer", humanNameResult}
    };

    currentJsonObject2 = object2;
    //
    QString pcb3 = paramsMapToThreads["PCB_SN_ByteArray3"].toByteArray().toHex();

    QJsonObject object3
    {
 //       {"PCB_SN", pcb3},
        {"Rref1", ObjectThread3->getR_Ref1_3()},
        {"Rref2", ObjectThread3->getR_Ref2_3()}
  //      {"Usable", workPlace3ResultString}
  //      {"Engineer", humanNameResult}
    };

    currentJsonObject3 = object3;
    //
    QString pcb4 = paramsMapToThreads["PCB_SN_ByteArray4"].toByteArray().toHex();

    QJsonObject object4
    {
//        {"PCB_SN", pcb4},
        {"Rref1", ObjectThread4->getR_Ref1_4()},
        {"Rref2", ObjectThread4->getR_Ref2_4()}
  //      {"Usable", workPlace4ResultString}
  //      {"Engineer", humanNameResult}
    };

    currentJsonObject4 = object4;
    //

    qDebug()<<"object1 "<<object1
            <<"object2 "<<object2
            <<"object3 "<<object3
            <<"object4 "<<object4;


}

void MainWindow::on_toolButton_createJson_clicked()
{
    makeJsonDoc("1", "2", "3", "4");
}

void MainWindow::on_toolButton_execSql_clicked()
{
    execQuery(ui->lineEdit_SqlQuery->text());
}

bool MainWindow::dublicatNumberCheckExtServ()
{
    isDublExist1 = false;
    isDublExist2 = false;
    isDublExist3 = false;
    isDublExist4 = false;

    jsonByteArray1.clear();
    jsonByteArray2.clear();
    jsonByteArray3.clear();
    jsonByteArray4.clear();

   //запрашиваем колонку pcb, eb_id таблицы dev, проверяем уникальность номера

    QString queryStringDev = "Select \"pcb\", \"eb_id\" From dev;";

    QSqlQuery sqlQueryDev(dataBase);

    if(!sqlQueryDev.exec(queryStringDev)) {
       QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryDev.lastError().text();
       QMessageBox::information(this, "", lastErrorQuery);
       return false;
    }

    //запрашиваем колонку pcb, eb_id таблицы dev, проверяем уникальность номера/

    //

    //разбираем результат запроса
    while (sqlQueryDev.next()) {
      QString PCBNum = sqlQueryDev.value(0).toString();
      int ebIdInt = sqlQueryDev.value(1).toInt();

      //запрашиваем колонку id, date, result, count таблицы eb_test, для которой id = ebIdInt

       QString queryStringEbTest = "Select \"id\", \"date\", \"result\", \"count\" From eb_test WHERE \"id\" = " +
               QString::number(ebIdInt) + ";";

       QSqlQuery sqlQueryEbTest(dataBase);

       if(!sqlQueryEbTest.exec(queryStringEbTest)) {
          QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryEbTest.lastError().text();
          QMessageBox::information(this, "", lastErrorQuery);
          return false;
       }

       sqlQueryEbTest.first();

       //запрашиваем колонку id, date, result таблицы eb_test, для которой id = ebIdInt/

       //

 //     sqlQueryEbTest.seek(ebIdInt);

      QVariantMap jsonMap;
      QJsonDocument jsonDoc;
//      "Rref1": "",
//        "Rref2": "",
//        "PCB_SN": "9030000090311111",
//        "usable":
      QByteArray jsonByteArrayTmp1;

      if(PCBNum == PCB_SN_ByteArray.toHex() /*serialNumber.toHex()*//*curSerNum*/  && ui->checkBox_workPlace1->isChecked()) {
  //        QMessageBox::information(this, "", tr("Данный серийный номер уже существует в базе данных: Рабочее место 1"));
//          jsonMap = sqlQueryDev.value(3).toJsonObject().toVariantMap();
//          jsonDoc = sqlQueryDev.value(3).toJsonDocument();

          jsonByteArrayTmp1 = sqlQueryEbTest.value(2).toByteArray();//

          isDublExist1 = true;
          currentDublicatTime1 = sqlQueryEbTest.value(1).toString();

          currentDublicatUsable1 = sqlQueryEbTest.value(3).toInt();

          jsonByteArray1 = jsonByteArrayTmp1;

      }


      //

      QByteArray jsonByteArrayTmp2;

      if(PCBNum == PCB_SN_ByteArray2.toHex() /*serialNumber2.toHex()*//*curSerNum*/ && ui->checkBox_workPlace2->isChecked()) {
   //       QMessageBox::information(this, "", tr("Данный серийный номер уже существует в базе данных: Рабочее место 2"));
//          jsonMap = sqlQueryDev.value(3).toJsonObject().toVariantMap();
//          jsonDoc = sqlQueryDev.value(3).toJsonDocument();

          jsonByteArrayTmp2 = sqlQueryEbTest.value(2).toByteArray();

          isDublExist2 = true;
          currentDublicatTime2 = sqlQueryEbTest.value(1).toString();

          currentDublicatUsable2 = sqlQueryEbTest.value(3).toInt();

          jsonByteArray2 = jsonByteArrayTmp2;

      }


      //

      QByteArray jsonByteArrayTmp3;

      if(PCBNum == PCB_SN_ByteArray3.toHex() /*curSerNum*/ && ui->checkBox_workPlace3->isChecked()) {
   //       QMessageBox::information(this, "", tr("Данный серийный номер уже существует в базе данных: Рабочее место 3"));
//          jsonMap = sqlQueryDev.value(3).toJsonObject().toVariantMap();
//          jsonDoc = sqlQueryDev.value(3).toJsonDocument();

          jsonByteArrayTmp3 = sqlQueryEbTest.value(2).toByteArray();

          isDublExist3 = true;
          currentDublicatTime3 = sqlQueryEbTest.value(1).toString();

          currentDublicatUsable3 = sqlQueryEbTest.value(3).toInt();

          jsonByteArray3 = jsonByteArrayTmp3;

      }


      //

      QByteArray jsonByteArrayTmp4;

      if(PCBNum == PCB_SN_ByteArray4.toHex() /*curSerNum*/ && ui->checkBox_workPlace4->isChecked()) {
   //       QMessageBox::information(this, "", tr("Данный серийный номер уже существует в базе данных: Рабочее место 4"));
//          jsonMap = sqlQueryDev.value(3).toJsonObject().toVariantMap();
//          jsonDoc = sqlQueryDev.value(3).toJsonDocument();

          jsonByteArrayTmp4 = sqlQueryEbTest.value(2).toByteArray();

          isDublExist4 = true;
          currentDublicatTime4 = sqlQueryEbTest.value(1).toString();

          currentDublicatUsable4 = sqlQueryEbTest.value(3).toInt();

          jsonByteArray4 = jsonByteArrayTmp4;

      }



      qDebug()<<"serNum "<<PCBNum;
    }

    return true;
}

bool MainWindow::dublicatNumberCheck(QString number) //аргумент не используется
{
    isDublExist1 = false;
    isDublExist2 = false;
    isDublExist3 = false;
    isDublExist4 = false;

   //запрашиваем всю таблицу, проверяем уникальность номера

 //   QString curSerNum = number;

    QString queryString = "Select * From table3;";

    QSqlQuery sqlQuery(dataBase);

    if(!sqlQuery.exec(queryString)) {
       QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQuery.lastError().text();
   //    emit slotError(lastErrorQuery + '\n');
       QMessageBox::information(this, "", lastErrorQuery);
       return false;
    }

    //разбираем результат запроса
    while (sqlQuery.next()) {
      QString serNum = sqlQuery.value(0).toString();
      QVariantMap jsonMap;
      QJsonDocument jsonDoc;
//      "Rref1": "",
//        "Rref2": "",
//        "PCB_SN": "9030000090311111",
//        "usable":

      if(serNum == serialNumber.toHex()/*curSerNum*/  && ui->checkBox_workPlace1->isChecked()) {
  //        QMessageBox::information(this, "", tr("Данный серийный номер уже существует в базе данных: Рабочее место 1"));
          jsonMap = sqlQuery.value(1).toJsonObject().toVariantMap();
          jsonDoc = sqlQuery.value(1).toJsonDocument();
          QByteArray jsonByteArray = sqlQuery.value(1).toByteArray();
 //         emit sendNoteDataToDialofForm(serNum, QString::fromUtf8(jsonByteArray), 1);

          isDublExist1 = true;
      }
      if(serNum == serialNumber2.toHex()/*curSerNum*/ && ui->checkBox_workPlace2->isChecked()) {
   //       QMessageBox::information(this, "", tr("Данный серийный номер уже существует в базе данных: Рабочее место 2"));
          jsonMap = sqlQuery.value(1).toJsonObject().toVariantMap();
          jsonDoc = sqlQuery.value(1).toJsonDocument();
          QByteArray jsonByteArray = sqlQuery.value(1).toByteArray();
 //         emit sendNoteDataToDialofForm(serNum, QString::fromUtf8(jsonByteArray), 2);

          isDublExist2 = true;
      }
      if(serNum == serialNumber3.toHex()/*curSerNum*/ && ui->checkBox_workPlace3->isChecked()) {
   //       QMessageBox::information(this, "", tr("Данный серийный номер уже существует в базе данных: Рабочее место 3"));
          jsonMap = sqlQuery.value(1).toJsonObject().toVariantMap();
          jsonDoc = sqlQuery.value(1).toJsonDocument();
          QByteArray jsonByteArray = sqlQuery.value(1).toByteArray();
 //         emit sendNoteDataToDialofForm(serNum, QString::fromUtf8(jsonByteArray), 3);

          isDublExist3 = true;
      }
      if(serNum == serialNumber4.toHex()/*curSerNum*/ && ui->checkBox_workPlace4->isChecked()) {
   //       QMessageBox::information(this, "", tr("Данный серийный номер уже существует в базе данных: Рабочее место 4"));
          jsonMap = sqlQuery.value(1).toJsonObject().toVariantMap();
          jsonDoc = sqlQuery.value(1).toJsonDocument();
          QByteArray jsonByteArray = sqlQuery.value(1).toByteArray();
  //        emit sendNoteDataToDialofForm(serNum, QString::fromUtf8(jsonByteArray), 4);

          isDublExist4 = true;
      }

      qDebug()<<"serNum "<<serNum;
    }

    return true;

}

void MainWindow::on_toolButton_uniqNumChecking_clicked()
{
    bool dublCheck = dublicatNumberCheck(ui->lineEdit_serNum->text());
}

void MainWindow::insertNewNote()
{

}

void MainWindow::on_toolButton_addNoteToTable_clicked()
{
    //подключение к серверу
//    if(!serverConnection()) {
//        return;
//    }

    if(!dataBase.isOpen()) {
        if(!serverConnectionWithPassword(loginDB, passwordDB)) {
            return; //не удалось установить соендинение
        }
    }

    //проверяем наличие дубликатов
    dublicatNumberCheck(QString()); //аргумент не используется. устанавливаются значения bool для каждого сер. номера

    //создать объект Json
    makeJsonDoc(QString(), QString(), QString(), QString()); //аргументы не используются

    // INSERT INTO название_таблицы (поле1, поле2 ... ) VALUES (значение1, значение2 ...)

    QString kav = QString('"');
    QString kavOne = QString("'");

   //
   if(!isDublExist1 && ui->checkBox_workPlace1->isChecked()) {

      QString queryString = "INSERT INTO table3 (" + kav + "SerialNumber" + kav + "," +
                          kav + "checkEB_Result" + kav + ") VALUES (" +
                          kavOne + serialNumber.toHex() + kavOne + "," + kavOne +
                          QString(QJsonDocument(currentJsonObject1).toJson(QJsonDocument::Compact)) + kavOne + ");";

      bool que = execQuery(queryString);
   }

   //если этот номер уже присутствует, тогда задаём вопрос оператору о перезаписи
   if(isDublExist1 && ui->checkBox_workPlace1->isChecked()) {

      //перезаписать?

      if(dialogUpdateNote->exec() == QDialog::Accepted) {

          qDebug()<<"Dialog Accepted";

          updateDataBaseNote(serialNumber.toHex(), 0);

      }
      else {
          qDebug()<<"Dialog Rejected";
      }

      //перезаписать?/


   }
   //если этот номер уже присутствует, тогда задаём вопрос оператору о перезаписи/

   //
   if(!isDublExist2 && ui->checkBox_workPlace2->isChecked()) {

      QString queryString = "INSERT INTO table3 (" + kav + "SerialNumber" + kav + "," +
                          kav + "checkEB_Result" + kav + ") VALUES (" +
                          kavOne + serialNumber2.toHex() + kavOne + "," + kavOne +
                          QString(QJsonDocument(currentJsonObject2).toJson(QJsonDocument::Compact)) + kavOne + ");";

      bool que = execQuery(queryString);
   }

   if(isDublExist2 && ui->checkBox_workPlace2->isChecked()) {

       //перезаписать?

       if(dialogUpdateNote->exec() == QDialog::Accepted) {

           qDebug()<<"Dialog Accepted";

           updateDataBaseNote(serialNumber2.toHex(), 1);

       }
       else {
           qDebug()<<"Dialog Rejected";
       }

       //перезаписать?/
   }

   //
   if(!isDublExist3 && ui->checkBox_workPlace3->isChecked()) {

      QString queryString = "INSERT INTO table3 (" + kav + "SerialNumber" + kav + "," +
                          kav + "checkEB_Result" + kav + ") VALUES (" +
                          kavOne + serialNumber3.toHex() + kavOne + "," + kavOne +
                          QString(QJsonDocument(currentJsonObject3).toJson(QJsonDocument::Compact)) + kavOne + ");";

      bool que = execQuery(queryString);
   }

   if(isDublExist3 && ui->checkBox_workPlace3->isChecked()) {

       //перезаписать?

       if(dialogUpdateNote->exec() == QDialog::Accepted) {

           qDebug()<<"Dialog Accepted";

           updateDataBaseNote(serialNumber3.toHex(), 2);

       }
       else {
           qDebug()<<"Dialog Rejected";
       }

       //перезаписать?/
   }

   //
   if(!isDublExist4 && ui->checkBox_workPlace4->isChecked()) {

      QString queryString = "INSERT INTO table3 (" + kav + "SerialNumber" + kav + "," +
                          kav + "checkEB_Result" + kav + ") VALUES (" +
                          kavOne + serialNumber4.toHex() + kavOne + "," + kavOne +
                          QString(QJsonDocument(currentJsonObject4).toJson(QJsonDocument::Compact)) + kavOne + ");";

      bool que = execQuery(queryString);
   }

   if(isDublExist4 && ui->checkBox_workPlace4->isChecked()) {

       //перезаписать?

       if(dialogUpdateNote->exec() == QDialog::Accepted) {

           qDebug()<<"Dialog Accepted";

           updateDataBaseNote(serialNumber4.toHex(), 3);

       }
       else {
           qDebug()<<"Dialog Rejected";
       }

       //перезаписать?/
   }



}

void MainWindow::updateDataBaseNoteExtServ(QString pcbStr, int workPlace)
{

    QString kav = QString('"');
    QString kavOne = QString("'");

    int workPlace1ResultInt;
    int workPlace2ResultInt;
    int workPlace3ResultInt;
    int workPlace4ResultInt;

    int workPlaceResultTmp;

    //
    //вынесли параметр "Usable" в отдельный столбец б.д. в виде значения int
    if(workPlace1ResultString == tr("Годен")) {
        workPlace1ResultInt = 1;
    }
    else {
        workPlace1ResultInt = 0;
    }
    //
    if(workPlace2ResultString == tr("Годен")) {
        workPlace2ResultInt = 1;
    }
    else {
        workPlace2ResultInt = 0;
    }
    //
    if(workPlace3ResultString == tr("Годен")) {
        workPlace3ResultInt = 1;
    }
    else {
        workPlace3ResultInt = 0;
    }
    //
    if(workPlace4ResultString == tr("Годен")) {
        workPlace4ResultInt = 1;
    }
    else {
        workPlace4ResultInt = 0;
    }
    //
    //вынесли параметр "Usable" в отдельный столбец б.д. в виде значения int/


       // UPDATE device SET "SerialNumber" = '55555555', "checkEB_Result" = '{}'  WHERE "SerialNumber" = '90311111';

        QJsonObject curJsonObject;

        switch (workPlace) {
        case 0:
            curJsonObject = currentJsonObject1;
            workPlaceResultTmp = workPlace1ResultInt;
            break;
        case 1:
            curJsonObject = currentJsonObject2;
            workPlaceResultTmp = workPlace2ResultInt;
            break;
        case 2:
            curJsonObject = currentJsonObject3;
            workPlaceResultTmp = workPlace3ResultInt;
            break;
        case 3:
            curJsonObject = currentJsonObject4;
            workPlaceResultTmp = workPlace4ResultInt;
            break;
        default:
            break;
        }

        //прочитываем запись таблицы dev, соответствующую pcb, узнаём поле eb_id

        QString queryStringDevFirst = "SELECT \"eb_id\" from \"dev\" WHERE \"pcb\" = " + kavOne + pcbStr + kavOne + ";";

   //     dataBase.transaction();

        QSqlQuery sqlQueryDevFirst(dataBase);

        if(!sqlQueryDevFirst.exec(queryStringDevFirst)) {
           QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryDevFirst.lastError().text();
  //         dataBase.rollback();
           QMessageBox::information(this, "", lastErrorQuery);
           return;
        }

 //       dataBase.commit();

        sqlQueryDevFirst.first();

        int ebIdInt = sqlQueryDevFirst.value(0).toInt();

        //прочитываем запись таблицы dev, соответствующую pcb, узнаём поле eb_id/

        //

        //сначала обновляется запись в таблице eb_test

        QString queryStringEbTest = "UPDATE eb_test SET " +
                kav + "date" + kav + " = " + "current_timestamp(0)" + "," +
                kav + "result" + kav + " = " +
                kavOne + QString(QJsonDocument(curJsonObject).toJson(QJsonDocument::Compact)) + kavOne + ", " +
                kav + "work_user_id" + kav + " = " + QString::number(userId) + "," +
                kav + "count" + kav + " = " + QString::number(workPlaceResultTmp) +
                " WHERE " + kav + "id" + kav + " = " + kavOne + QString::number(ebIdInt) + kavOne +

                " returning \"id\";";


        dataBase.transaction();

        QSqlQuery sqlQueryEbTest(dataBase);

        if(!sqlQueryEbTest.exec(queryStringEbTest)) {
           QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryEbTest.lastError().text();
           dataBase.rollback();
           QMessageBox::information(this, "", lastErrorQuery);
           return;
        }

        dataBase.commit();

//        sqlQueryEbTest.first();

//        ebIdInt = sqlQueryEbTest.value(0).toInt();

        //сначала обновляется запись в таблице eb_test/

        //

        //затем обновляется запись в таблице dev



        //затем обновляется запись в таблице dev/

//        QString queryString = "UPDATE device SET " +
//                            kav + "eb_result" + kav + " = " +
//                            kavOne + QString(QJsonDocument(curJsonObject).toJson(QJsonDocument::Compact)) + kavOne + ", " +
//                            kav + "eb_date" + kav + " = " + "current_timestamp(0)" +
//                            " WHERE " + kav + "serial" + kav + " = " + kavOne + numberStr + kavOne +  ";";

//        qDebug()<<"queryString "<<queryString;

//        bool que = execQuery(queryString);

}

void MainWindow::updateDataBaseNote(QString numberStr, int workPlace)
{
   // UPDATE table3 SET "SerialNumber" = '55555555', "checkEB_Result" = '{}'  WHERE "SerialNumber" = '90311111';

    QJsonObject curJsonObject;

    switch (workPlace) {
    case 0:
        curJsonObject = currentJsonObject1;
        break;
    case 1:
        curJsonObject = currentJsonObject2;
        break;
    case 2:
        curJsonObject = currentJsonObject3;
        break;
    case 3:
        curJsonObject = currentJsonObject4;
        break;
    default:
        break;
    }

    QString kav = QString('"');
    QString kavOne = QString("'");

    QString queryString = "UPDATE table3 SET " + kav + "SerialNumber" + kav + " = " + kavOne + numberStr + kavOne + "," +
                        kav + "checkEB_Result" + kav + " = " +
                        kavOne + QString(QJsonDocument(curJsonObject).toJson(QJsonDocument::Compact)) + kavOne +
                        " WHERE " + kav + "SerialNumber" + kav + " = " + kavOne + numberStr + kavOne +  ";";

    qDebug()<<"queryString "<<queryString;

    bool que = execQuery(queryString);

}

void MainWindow::slotGetSignalShowConnPar()
{
    formConnectionParams->show();
}

void MainWindow::slotGetParamsConnection(QStringList paramsList)
{
    dataBase.close();

    hostName = paramsList.at(0);
    dataBaseName = paramsList.at(1);
    dataBaseUserName = paramsList.at(2);
    dataBasePassword = paramsList.at(3);

    //соединение с сервером
    serverConnectWithPasswordExtServ("", "");

//    isLoginPasswordOk = false;

    QStringList userList = readUserTable();

    emit sendUserList(userList);

    emit sendLogPasFromSettings(ui->lineEdit_humanName->text(), QString());
}

void MainWindow::slotGetLoginPassword(QString login, QString password, bool isRememberLogin)
{
    loginDB = login;
    passwordDB = password;
    isRememberLogPas = isRememberLogin;

 //   serverConnect = serverConnectionWithPassword(login, password);//serverConnection();

//    serverConnect = serverConnectWithPasswordExtServ(login, password);//serverConnection();

    if(userPasswordChecking(login, password)/*serverConnect*/) {

        isLoginPasswordOk = true;
        ui->lineEdit_humanName->setText(login);
        dialogLoginDataBase->close();
        this->show();//setVisible(true);

//        QMessageBox::information(this, "", tr("Подключение установлено"));
    }

    if(!isLoginPasswordOk) return;

   //проверяем по таблице work_user, есть ли там такой пользователь, запоминаем id,
   //если польз. нет, то добавляем его имя в таблицу и запоминаем id

    //прочитать таблицу work_user
    QString queryString = "Select * From \"work_user\";";

    QSqlQuery sqlQuery(dataBase);

    if(!sqlQuery.exec(queryString)) {
       QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQuery.lastError().text();
   //    emit slotError(lastErrorQuery + '\n');
       QMessageBox::information(this, "", lastErrorQuery);
       return;
    }

    bool isWorkUserExist = false;
    QByteArray userIdByteArray;
 //   int workUserId;

    while (sqlQuery.next()) {
      QString logFromTable = sqlQuery.value(1).toString();

      if(logFromTable == login) {

          isWorkUserExist = true;

          userId = sqlQuery.value(0).toInt();

      }

    }

    //если не нашли, тогда вставляем пользователя и берём полученный id
     if(!isWorkUserExist) {

       queryString = "INSERT INTO work_user (\"name\") VALUES ('" + login + "') returning \"id\";";

       if(!sqlQuery.exec(queryString)) {
          QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQuery.lastError().text();
          QMessageBox::information(this, "", lastErrorQuery);
          return;
       }

       sqlQuery.first();

       userId = sqlQuery.value(0).toInt();

     }


}

void MainWindow::slotGetSignalCloseLogin()
{
    qDebug()<<"MainWindow::slotGetSignalCloseLogin()";

    if(!isLoginPasswordOk/*!serverConnect*/) {
        QApplication::exit();
    }
    else {

    }

}



void MainWindow::on_toolButton_externalServerConnect_clicked()
{

    if(!connectCondition) return;

    //запись результата в текстовый файл result_
    saveCounterCheckingResult(1, QString());

    isDublExist1 = false;
    isDublExist2 = false;
    isDublExist3 = false;
    isDublExist4 = false;

    //перед записью в базу данных (или не записью) записываем результат проверки в текстовый файл

        //подключение к серверу
    //    if(!serverConnection()) {
    //        return;
    //    }

        if(!dataBase.isOpen()) {
            if(!serverConnectWithPasswordExtServ("gefest" /*loginDB*/, "gefest" /*passwordDB*/)) {
                return; //не удалось установить соединение
            }
        }

        //проверяем наличие дубликатов
        dublicatNumberCheckExtServ(); //аргумент не используется. устанавливаются значения bool для каждого сер. номера

        //создать объект Json
        makeJsonDoc(QString(), QString(), QString(), QString()); //аргументы не используются

        // INSERT INTO название_таблицы (поле1, поле2 ... ) VALUES (значение1, значение2 ...)

        QString kav = QString('"');
        QString kavOne = QString("'");

        int workPlace1ResultInt;
        int workPlace2ResultInt;
        int workPlace3ResultInt;
        int workPlace4ResultInt;

        //
        //вынесли параметр "Usable" в отдельный столбец б.д. в виде значения int
        if(workPlace1ResultString == tr("Годен")) {
            workPlace1ResultInt = 1;
        }
        else {
            workPlace1ResultInt = 0;
        }
        //
        if(workPlace2ResultString == tr("Годен")) {
            workPlace2ResultInt = 1;
        }
        else {
            workPlace2ResultInt = 0;
        }
        //
        if(workPlace3ResultString == tr("Годен")) {
            workPlace3ResultInt = 1;
        }
        else {
            workPlace3ResultInt = 0;
        }
        //
        if(workPlace4ResultString == tr("Годен")) {
            workPlace4ResultInt = 1;
        }
        else {
            workPlace4ResultInt = 0;
        }
        //
        //вынесли параметр "Usable" в отдельный столбец б.д. в виде значения int/


       //
       if(!isDublExist1 && ui->checkBox_workPlace1->isChecked()) {

          //запись в две таблицы, сначала eb_test(запоминаем id записи) потом dev(в поле eb_id записываем id, которое запомнили в eb_test)

           // запись в таблицу eb_test

               // INSERT INTO eb_test ("date", "result", "work_user_id") VALUES (current_timestamp, '{"a" : "5", "b" : 2}', 1) returning "id";

            QString queryStringEbTest = "INSERT INTO eb_test (" +
                    kav + "date" + kav + "," +
                    kav + "result" + kav + "," +
                    kav + "work_user_id" + kav + "," +
                    kav + "count" + kav +
                    ") VALUES (" + "current_timestamp(0)" + "," +
                kavOne + QString(QJsonDocument(currentJsonObject1).toJson(QJsonDocument::Compact)) + kavOne + "," +
                   QString::number(userId) + "," +
                   QString::number(workPlace1ResultInt) +
                   ") returning \"id\";";

            qDebug()<<"queryStringEbTest "<<queryStringEbTest;

            dataBase.transaction();

            QSqlQuery sqlQueryEbTest(dataBase);

            if(!sqlQueryEbTest.exec(queryStringEbTest)) {
               QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryEbTest.lastError().text();
               dataBase.rollback();
               QMessageBox::information(this, "", lastErrorQuery);
               return;
            }

            dataBase.commit();

            sqlQueryEbTest.first();

            int idEbTestInt = sqlQueryEbTest.value(0).toInt();

            // запись в таблицу eb_test/

            //

            //запись в таблицу dev

            QString queryStringDev = "INSERT INTO dev (" +
                    kav + "serial" + kav + "," +
                    kav + "pcb" + kav + "," +
                    kav + "eb_id" + kav +
                    ") VALUES (" + kavOne + serialNumber.toHex() + kavOne + "," +
                kavOne + PCB_SN_ByteArray.toHex() + kavOne + "," +
                   QString::number(idEbTestInt) +
                   ");";

            dataBase.transaction();

            QSqlQuery sqlQueryDev(dataBase);

            if(!sqlQueryDev.exec(queryStringDev)) {
               QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryDev.lastError().text();
               dataBase.rollback();
               QMessageBox::information(this, "", lastErrorQuery);
               return;
            }

            dataBase.commit();

            //запись в таблицу dev/



 //          QString queryString = "INSERT INTO eb_test (" +
 //                                kav + "serial" + kav + "," +
 //                                kav + "eb_result" + kav + "," +
 //                                kav + "eb_date" + kav +
 //                                ") VALUES (" +
 //                              kavOne + serialNumber.toHex() + kavOne + "," +
 //             kavOne + QString(QJsonDocument(currentJsonObject1).toJson(QJsonDocument::Compact)) + kavOne + "," +
 //                              "current_timestamp(0)" + ");";

 //          qDebug()<<"queryString " + queryString;

 //          bool que = execQuery(queryString);



          //запись в две таблицы, сначала eb_test(запоминаем id записи) потом dev(в поле eb_id записываем id, которое запомнили в eb_test) /

       }

       //если этот номер уже присутствует, тогда задаём вопрос оператору о перезаписи
       if(isDublExist1 && ui->checkBox_workPlace1->isChecked()) {

          emit sendNoteDataToDialofForm(PCB_SN_ByteArray.toHex(), QString::fromUtf8(jsonByteArray1), 1,
                                        currentDublicatTime1, currentDublicatUsable1);

          //перезаписать?

          if(dialogUpdateNote->exec() == QDialog::Accepted) {

              qDebug()<<"Dialog Accepted";

              updateDataBaseNoteExtServ(PCB_SN_ByteArray.toHex() /*serialNumber.toHex()*/, 0);

          }
          else {
              qDebug()<<"Dialog Rejected";
          }

          //перезаписать?/


       }
       //если этот номер уже присутствует, тогда задаём вопрос оператору о перезаписи/

       //
       if(!isDublExist2 && ui->checkBox_workPlace2->isChecked()) {

           //запись в две таблицы, сначала eb_test(запоминаем id записи) потом dev(в поле eb_id записываем id, которое запомнили в eb_test)

            // запись в таблицу eb_test

                // INSERT INTO eb_test ("date", "result", "work_user_id") VALUES (current_timestamp, '{"a" : "5", "b" : 2}', 1) returning "id";

             QString queryStringEbTest = "INSERT INTO eb_test (" +
                     kav + "date" + kav + "," +
                     kav + "result" + kav + "," +
                     kav + "work_user_id" + kav + "," +
                     kav + "count" + kav +
                     ") VALUES (" + "current_timestamp(0)" + "," +
                 kavOne + QString(QJsonDocument(currentJsonObject2).toJson(QJsonDocument::Compact)) + kavOne + "," +
                    QString::number(userId) + "," +
                    QString::number(workPlace2ResultInt) +
                    ") returning \"id\";";

             dataBase.transaction();

             QSqlQuery sqlQueryEbTest(dataBase);

             if(!sqlQueryEbTest.exec(queryStringEbTest)) {
                QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryEbTest.lastError().text();
                dataBase.rollback();
                QMessageBox::information(this, "", lastErrorQuery);
                return;
             }

             dataBase.commit();

             sqlQueryEbTest.first();

             int idEbTestInt = sqlQueryEbTest.value(0).toInt();

             // запись в таблицу eb_test/

             //

             //запись в таблицу dev

             QString queryStringDev = "INSERT INTO dev (" +
                     kav + "serial" + kav + "," +
                     kav + "pcb" + kav + "," +
                     kav + "eb_id" + kav +
                     ") VALUES (" + kavOne + serialNumber2.toHex() + kavOne + "," +
                 kavOne + PCB_SN_ByteArray2.toHex() + kavOne + "," +
                    QString::number(idEbTestInt) +
                    ");";

             dataBase.transaction();

             QSqlQuery sqlQueryDev(dataBase);

             if(!sqlQueryDev.exec(queryStringDev)) {
                QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryDev.lastError().text();
                dataBase.rollback();
                QMessageBox::information(this, "", lastErrorQuery);
                return;
             }

             dataBase.commit();

             //запись в таблицу dev/

 //          QString queryString = "INSERT INTO device (" +
 //                                kav + "serial" + kav + "," +
 //                                kav + "eb_result" + kav + "," +
 //                                kav + "eb_date" + kav +
 //                                ") VALUES (" +
 //                              kavOne + serialNumber2.toHex() + kavOne + "," + kavOne +
 //            QString(QJsonDocument(currentJsonObject2).toJson(QJsonDocument::Compact)) + kavOne + "," +
 //                              "current_timestamp(0)" + ");";

 //          bool que = execQuery(queryString);
       }

       if(isDublExist2 && ui->checkBox_workPlace2->isChecked()) {

           emit sendNoteDataToDialofForm(PCB_SN_ByteArray2.toHex() /*serialNumber2.toHex()*/, QString::fromUtf8(jsonByteArray2), 2,
                                         currentDublicatTime2, currentDublicatUsable2);

           //перезаписать?

           if(dialogUpdateNote->exec() == QDialog::Accepted) {

               qDebug()<<"Dialog Accepted";

               updateDataBaseNoteExtServ(PCB_SN_ByteArray2.toHex() /*serialNumber2.toHex()*/, 1);

           }
           else {
               qDebug()<<"Dialog Rejected";
           }

           //перезаписать?/
       }

       //
       if(!isDublExist3 && ui->checkBox_workPlace3->isChecked()) {

           //запись в две таблицы, сначала eb_test(запоминаем id записи) потом dev(в поле eb_id записываем id, которое запомнили в eb_test)

            // запись в таблицу eb_test

                // INSERT INTO eb_test ("date", "result", "work_user_id") VALUES (current_timestamp, '{"a" : "5", "b" : 2}', 1) returning "id";

             QString queryStringEbTest = "INSERT INTO eb_test (" +
                     kav + "date" + kav + "," +
                     kav + "result" + kav + "," +
                     kav + "work_user_id" + kav + "," +
                     kav + "count" + kav +
                     ") VALUES (" + "current_timestamp(0)" + "," +
                 kavOne + QString(QJsonDocument(currentJsonObject3).toJson(QJsonDocument::Compact)) + kavOne + "," +
                    QString::number(userId) + "," +
                    QString::number(workPlace3ResultInt) +
                    ") returning \"id\";";

             dataBase.transaction();

             QSqlQuery sqlQueryEbTest(dataBase);

             if(!sqlQueryEbTest.exec(queryStringEbTest)) {
                QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryEbTest.lastError().text();
                dataBase.rollback();
                QMessageBox::information(this, "", lastErrorQuery);
                return;
             }

             dataBase.commit();

             sqlQueryEbTest.first();

             int idEbTestInt = sqlQueryEbTest.value(0).toInt();

             // запись в таблицу eb_test/

             //

             //запись в таблицу dev

             QString queryStringDev = "INSERT INTO dev (" +
                     kav + "serial" + kav + "," +
                     kav + "pcb" + kav + "," +
                     kav + "eb_id" + kav +
                     ") VALUES (" + kavOne + serialNumber3.toHex() + kavOne + "," +
                 kavOne + PCB_SN_ByteArray3.toHex() + kavOne + "," +
                    QString::number(idEbTestInt) +
                    ");";

             dataBase.transaction();

             QSqlQuery sqlQueryDev(dataBase);

             if(!sqlQueryDev.exec(queryStringDev)) {
                QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryDev.lastError().text();
                dataBase.rollback();
                QMessageBox::information(this, "", lastErrorQuery);
                return;
             }

             dataBase.commit();

             //запись в таблицу dev/

 //          QString queryString = "INSERT INTO device (" +
 //                                kav + "serial" + kav + "," +
 //                                kav + "eb_result" + kav + "," +
 //                                kav + "eb_date" + kav +
 //                                ") VALUES (" +
 //                              kavOne + serialNumber3.toHex() + kavOne + "," + kavOne +
 //            QString(QJsonDocument(currentJsonObject3).toJson(QJsonDocument::Compact)) + kavOne + "," +
 //                              "current_timestamp(0)" + ");";

 //          bool que = execQuery(queryString);
       }

       if(isDublExist3 && ui->checkBox_workPlace3->isChecked()) {

           emit sendNoteDataToDialofForm(PCB_SN_ByteArray3.toHex() /*serialNumber3.toHex()*/, QString::fromUtf8(jsonByteArray3), 3,
                                         currentDublicatTime3, currentDublicatUsable3);

           //перезаписать?

           if(dialogUpdateNote->exec() == QDialog::Accepted) {

               qDebug()<<"Dialog Accepted";

               updateDataBaseNoteExtServ(PCB_SN_ByteArray3.toHex() /*serialNumber3.toHex()*/, 2);

           }
           else {
               qDebug()<<"Dialog Rejected";
           }

           //перезаписать?/
       }

       //
       if(!isDublExist4 && ui->checkBox_workPlace4->isChecked()) {

           //запись в две таблицы, сначала eb_test(запоминаем id записи) потом dev(в поле eb_id записываем id, которое запомнили в eb_test)

            // запись в таблицу eb_test

                // INSERT INTO eb_test ("date", "result", "work_user_id") VALUES (current_timestamp, '{"a" : "5", "b" : 2}', 1) returning "id";

             QString queryStringEbTest = "INSERT INTO eb_test (" +
                     kav + "date" + kav + "," +
                     kav + "result" + kav + "," +
                     kav + "work_user_id" + kav + "," +
                     kav + "count" + kav +
                     ") VALUES (" + "current_timestamp(0)" + "," +
                 kavOne + QString(QJsonDocument(currentJsonObject4).toJson(QJsonDocument::Compact)) + kavOne + "," +
                    QString::number(userId) + "," +
                    QString::number(workPlace4ResultInt) +
                    ") returning \"id\";";

             dataBase.transaction();

             QSqlQuery sqlQueryEbTest(dataBase);

             if(!sqlQueryEbTest.exec(queryStringEbTest)) {
                QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryEbTest.lastError().text();
                dataBase.rollback();
                QMessageBox::information(this, "", lastErrorQuery);
                return;
             }

             dataBase.commit();

             sqlQueryEbTest.first();

             int idEbTestInt = sqlQueryEbTest.value(0).toInt();

             // запись в таблицу eb_test/

             //

             //запись в таблицу dev

             QString queryStringDev = "INSERT INTO dev (" +
                     kav + "serial" + kav + "," +
                     kav + "pcb" + kav + "," +
                     kav + "eb_id" + kav +
                     ") VALUES (" + kavOne + serialNumber4.toHex() + kavOne + "," +
                 kavOne + PCB_SN_ByteArray4.toHex() + kavOne + "," +
                    QString::number(idEbTestInt) +
                    ");";

             dataBase.transaction();

             QSqlQuery sqlQueryDev(dataBase);

             if(!sqlQueryDev.exec(queryStringDev)) {
                QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryDev.lastError().text();
                dataBase.rollback();
                QMessageBox::information(this, "", lastErrorQuery);
                return;
             }

             dataBase.commit();

             //запись в таблицу dev/

 //          QString queryString = "INSERT INTO device (" +
 //                                kav + "serial" + kav + "," +
 //                                kav + "eb_result" + kav + "," +
 //                                kav + "eb_date" + kav +
 //                                ") VALUES (" +
 //                              kavOne + serialNumber4.toHex() + kavOne + "," + kavOne +
 //             QString(QJsonDocument(currentJsonObject4).toJson(QJsonDocument::Compact)) + kavOne + "," +
 //                              "current_timestamp(0)" + ");";

 //          bool que = execQuery(queryString);
       }

       if(isDublExist4 && ui->checkBox_workPlace4->isChecked()) {

           emit sendNoteDataToDialofForm(PCB_SN_ByteArray4.toHex() /*serialNumber4.toHex()*/, QString::fromUtf8(jsonByteArray4), 4,
                                         currentDublicatTime4, currentDublicatUsable4);

           //перезаписать?

           if(dialogUpdateNote->exec() == QDialog::Accepted) {

               qDebug()<<"Dialog Accepted";

               updateDataBaseNoteExtServ(PCB_SN_ByteArray4.toHex() /*serialNumber4.toHex()*/, 3);

           }
           else {
               qDebug()<<"Dialog Rejected";
           }

           //перезаписать?/
       }


}

void MainWindow::on_lineEdit_humanName_textChanged(const QString &arg1)
{
    humanNameResult = arg1;
}

void MainWindow::on_toolButton_resetAllCommands_clicked()
{
    ui->checkBox_writeParamsUse->setChecked(false);
    on_checkBox_writeParamsUse_clicked(false);

    ui->checkBox_startCalibrationUse->setChecked(false);
    on_checkBox_startCalibrationUse_clicked(false);

    ui->checkBox_pulsesOutputHeatUse->setChecked(false);
    on_checkBox_pulsesOutputHeatUse_clicked(false);

    ui->checkBox_pulsesInputVolumeUse->setChecked(false);
    on_checkBox_pulsesInputVolumeUse_clicked(false);

    ui->checkBox_pulsesOutputOffUse->setChecked(false);
    on_checkBox_pulsesOutputOffUse_clicked(false);

    ui->checkBox_MBusOnUse->setChecked(false);
    on_checkBox_MBusOnUse_clicked(false);

    ui->checkBox_CheckMbusUse->setChecked(false);
    on_checkBox_CheckMbusUse_clicked(false);

    ui->checkBox_digitalWireInterfaceCheckingUse->setChecked(false);
    on_checkBox_digitalWireInterfaceCheckingUse_clicked(false);

    ui->checkBox_MBusOffUse->setChecked(false);
    on_checkBox_MBusOffUse_clicked(false);

    ui->checkBox_calibrationModeOffUse->setChecked(false);
    on_checkBox_calibrationModeOffUse_clicked(false);

}


void MainWindow::on_toolButton_calibrationRepeat_clicked()
{

    repeatParameter = 1;

    on_toolButton_executeCommands_clicked();

//    ui->label_StatusBar->clear();

//    isCommandsEnded = false;

//    if(ui->checkBox_workPlace1->isChecked()) vectorIsWorkPlaceUse[0] = true;
//    if(ui->checkBox_workPlace2->isChecked()) vectorIsWorkPlaceUse[1] = true;
//    if(ui->checkBox_workPlace3->isChecked()) vectorIsWorkPlaceUse[2] = true;
//    if(ui->checkBox_workPlace4->isChecked()) vectorIsWorkPlaceUse[3] = true;

//    isCalibrationFinished1 = false;
//    isCalibrationFinished2 = false;
//    isCalibrationFinished3 = false;
//    isCalibrationFinished4 = false;

//    vectorIndicatorStateMatrix[1].fill(false);

//    ObjectThread1->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
//    ObjectThread2->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
//    ObjectThread3->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
//    ObjectThread4->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);

//    repaint();

//    //калибровка

//    if(vectorIsCommandUse.at(1)) {

//        portOptical->clear();
//        portOptical2->clear();
//        portOptical3->clear();
//        portOptical4->clear();
//        portOptical->close();
//        portOptical2->close();
//        portOptical3->close();
//        portOptical4->close();

//        ObjectThread1->moveToThread(&Thread1);
//        ObjectThread2->moveToThread(&Thread2);
//        ObjectThread3->moveToThread(&Thread3);
//        ObjectThread4->moveToThread(&Thread4);

//        Thread1.start();
//        Thread2.start();
//        Thread3.start();
//        Thread4.start();

//        ObjectThread1->setCalibrationMap(calibrationMap);
//        ObjectThread2->setCalibrationMap(calibrationMap);
//        ObjectThread3->setCalibrationMap(calibrationMap);
//        ObjectThread4->setCalibrationMap(calibrationMap);

//        ObjectThread1->setCalibrationFloatMap(calibrationFloatMap);
//        ObjectThread2->setCalibrationFloatMap(calibrationFloatMap);
//        ObjectThread3->setCalibrationFloatMap(calibrationFloatMap);
//        ObjectThread4->setCalibrationFloatMap(calibrationFloatMap);

//        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
//        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
//        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
//        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

//        QPalette palettePrime = ui->toolButton_startCalibration->palette();
//        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

//        QPalette palette = palettePrime;
//        palette.setColor( QPalette::Button, QColor( Qt::red )  );

//        QColor backgroundColor = palette.color(QPalette::Button);

//        qDebug()<<"palette "<<palette
//                <<"backgroundColor "<<backgroundColor.name()
//                <<"backgroundColorPrime "<<backgroundColorPrime.name();

//        ui->toolButton_startCalibration->setAutoFillBackground(true);
//        ui->toolButton_startCalibration->setPalette( palette );

// //        for(int l=0; l<4; l++) {

// //          if(vectorIsWorkPlaceUse.at(l)) {
// //              emit signalCalibration(l);

// //          }

// //        }

//        emit signalCalibrationToThread(portOptical, portOptical2, portOptical3, portOptical4);

//        emit signalLog("<font color = \"#0000ff\">" + QString("Начало калибровки") + '\n' + "</font>");


//        //-------------------------Ждём завершения калибровки------------------

//          bool isCalibrationFinishedTmp1 = true;
//          bool isCalibrationFinishedTmp2 = true;
//          bool isCalibrationFinishedTmp3 = true;
//          bool isCalibrationFinishedTmp4 = true;

// //          if(!vectorIsWorkPlaceUse.at(0)) isCalibrationFinishedTmp1 = true;
// //          if(!vectorIsWorkPlaceUse.at(1)) isCalibrationFinishedTmp2 = true;
// //          if(!vectorIsWorkPlaceUse.at(2)) isCalibrationFinishedTmp3 = true;
// //          if(!vectorIsWorkPlaceUse.at(3)) isCalibrationFinishedTmp4 = true;

//          for(int e=0; e<200; e++) { //20 sec
//              global::pause(100);

// //              if(vectorIsWorkPlaceUse.at(0)) isCalibrationFinishedTmp1 = isCalibrationFinished1;
// //              if(vectorIsWorkPlaceUse.at(1)) isCalibrationFinishedTmp2 = isCalibrationFinished2;
// //              if(vectorIsWorkPlaceUse.at(2)) isCalibrationFinishedTmp3 = isCalibrationFinished3;
// //              if(vectorIsWorkPlaceUse.at(3)) isCalibrationFinishedTmp4 = isCalibrationFinished4;

//              if(ui->checkBox_workPlace1->isChecked()) {
//                  isCalibrationFinishedTmp1 = isCalibrationFinished1;

//                  if(!vectorIsWorkPlaceUse.at(0)) isCalibrationFinishedTmp1 = true;
//              }

//              if(ui->checkBox_workPlace2->isChecked()) {
//                  isCalibrationFinishedTmp2 = isCalibrationFinished2;

//                  if(!vectorIsWorkPlaceUse.at(1)) isCalibrationFinishedTmp2 = true;
//              }

//              if(ui->checkBox_workPlace3->isChecked()) {
//                  isCalibrationFinishedTmp3 = isCalibrationFinished3;

//                  if(!vectorIsWorkPlaceUse.at(2)) isCalibrationFinishedTmp3 = true;
//              }

//              if(ui->checkBox_workPlace4->isChecked()) {
//                  isCalibrationFinishedTmp4 = isCalibrationFinished4;

//                  if(!vectorIsWorkPlaceUse.at(3)) isCalibrationFinishedTmp4 = true;
//              }


//              if(isCalibrationFinishedTmp1 && isCalibrationFinishedTmp2 && isCalibrationFinishedTmp3 && isCalibrationFinishedTmp4)
//                  break;
//          }


//        //-------------------------Ждём завершения калибровки------------------/

//          ui->toolButton_startCalibration->setPalette(palettePrime);

//    }

//    isCommandsEnded = true;
//    repaint();

//    //калибровка/

//    global::pause(500);

//    //если хотя бы один результат Не годен, спрашиваем о необходимости записи в бд
//    if(workPlace1ResultString == tr("Не годен") || workPlace2ResultString == tr("Не годен") ||
//            workPlace3ResultString == tr("Не годен") || workPlace4ResultString == tr("Не годен")) {

//        if(dialogWritingDB->exec() == QDialog::Accepted) {

//            isNoteWriting = true;

//            on_toolButton_externalServerConnect_clicked();

//        }
//        else {
//            isNoteWriting = false;

//            saveCounterCheckingResult(1, QString());
//        }

//    }
//    else {

//        isNoteWriting = true;

//        on_toolButton_externalServerConnect_clicked();

//    }

}


void MainWindow::slotPort1AnyError(QSerialPort::SerialPortError error)
{
    qDebug()<<"MainWindow::slotPortAnyError "<<error;

//    if(error != QSerialPort::NotOpenError)
//      QMessageBox::information(this, "", tr("Рабочее место1 : ") + portOptical->errorString());
}

void MainWindow::slotPort2AnyError(QSerialPort::SerialPortError error)
{
    qDebug()<<"MainWindow::slotPortAnyError "<<error;

//    if(error != QSerialPort::NotOpenError)
//      QMessageBox::information(this, "", tr("Рабочее место2 : ") + portOptical2->errorString());
}

void MainWindow::slotPort3AnyError(QSerialPort::SerialPortError error)
{
    qDebug()<<"MainWindow::slotPortAnyError "<<error;

//    if(error != QSerialPort::NotOpenError)
//      QMessageBox::information(this, "", tr("Рабочее место3 : ") + portOptical3->errorString());
}

void MainWindow::slotPort4AnyError(QSerialPort::SerialPortError error)
{
    qDebug()<<"MainWindow::slotPortAnyError "<<error;

//    if(error != QSerialPort::NotOpenError)
//      QMessageBox::information(this, "", tr("Рабочее место4 : ") + portOptical4->errorString());
}

void MainWindow::slotPortDigatalInterAnyError(QSerialPort::SerialPortError error)
{
    qDebug()<<"MainWindow::slotPortAnyError "<<error;

//    if(error != QSerialPort::NotOpenError)
//      QMessageBox::information(this, "", tr("Проводные интерфейсы : ") + portDigitalInterfaceChecking->errorString());
}


bool MainWindow::userPasswordChecking(QString log, QString pas)
{
    //прочитать таблицу user
    QString queryString = "Select * From \"user\";";

    QSqlQuery sqlQuery(dataBase);

    if(!sqlQuery.exec(queryString)) {
       QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQuery.lastError().text();
   //    emit slotError(lastErrorQuery + '\n');
       QMessageBox::information(this, "", lastErrorQuery);
       return false;
    }

    QString pasHash = QCryptographicHash::hash(pas.toUtf8(), QCryptographicHash::Md5).toHex();


    while (sqlQuery.next()) {
      QString logFromTable = sqlQuery.value(1).toString();
      QString pasFromTable= sqlQuery.value(2).toString();



      if(logFromTable == log/*curSerNum*/ && pasFromTable == pasHash) {

          isLoginPasswordOk = true;

      }

    }


 //   if(log == "user1" && pas == "gefest1")

    if(isLoginPasswordOk) {

        return true;

    }
    else {
        return false;
    }


}


void MainWindow::on_action_4_triggered()
{

}

void MainWindow::on_ResultTable_triggered()
{
    qDebug()<<"MainWindow::on_ResultTable_triggered()";

    //прочитать таблицу work_user

    QMap<int, QString> mapWorkUser;
    QStringList userList;
    QList<int> intList;

    QString queryStringWorkUser = QString("Select \"id\", \"name\" from \"work_user\";");

    QSqlQuery sqlQueryWorkUser(dataBase);

    if(!sqlQueryWorkUser.exec(queryStringWorkUser)) {
       QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryWorkUser.lastError().text();
       QMessageBox::information(this, "", lastErrorQuery);
       return;
    }

    while (sqlQueryWorkUser.next()) {
        mapWorkUser[sqlQueryWorkUser.value(0).toInt()] = sqlQueryWorkUser.value(1).toString();
        intList.append(sqlQueryWorkUser.value(0).toInt());

    }


    //прочитать таблицу work_user/

    //

    //прочитать таблицу dev, поля pcb, eb_id

    QString queryStringDev = QString("Select \"serial\", \"pcb\", \"eb_id\" from \"dev\";");  //"Select * From \"device\";";

    QSqlQuery sqlQueryDev(dataBase);

    if(!sqlQueryDev.exec(queryStringDev)) {
       QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryDev.lastError().text();
       QMessageBox::information(this, "", lastErrorQuery);
       return;
    }

    QStringList tableList;

    while (sqlQueryDev.next()) {

        QString serialStr = QString::number(sqlQueryDev.value(0).toInt());

        QString pcbStr = sqlQueryDev.value(1).toString();

        int ebIdInt = sqlQueryDev.value(2).toInt();

        //прочитываем одну запись таблицы eb_test, соответствующую ebIdInt

        QString queryStringEbTest = QString("Select \"date\", \"result\"::varchar as \"result\", \"work_user_id\", \"count\" from \"eb_test\" WHERE \"id\" = " + QString::number(ebIdInt) + ";");  //"Select * From \"device\";";

        QSqlQuery sqlQueryEbTest(dataBase);

        if(!sqlQueryEbTest.exec(queryStringEbTest)) {
           QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryEbTest.lastError().text();
           QMessageBox::information(this, "", lastErrorQuery);
           return;
        }

        sqlQueryEbTest.first();

        QString dateStr = sqlQueryEbTest.value(0).toString();
        QString resultStr = sqlQueryEbTest.value(1).toString();
        int userIdInt = sqlQueryEbTest.value(2).toInt();
        int usableStr = sqlQueryEbTest.value(3).toInt();

        tableList.append(serialStr + ";" + pcbStr + ";" + dateStr + ";" + resultStr + ";" + mapWorkUser[userIdInt] + ";" + QString::number(usableStr));

//        QJsonParseError parseError;

//        QString jsonString = sqlQuery.value(1).toString();

//        QJsonDocument jsonDoc = QJsonDocument::fromVariant(sqlQuery.value(1)/*, &parseError*/);

//        if(parseError.error != QJsonParseError::NoError) {
//            QMessageBox::information(this, "",parseError.errorString());
//        }

//        QJsonObject jsonObj = jsonDoc.object();//sqlQuery.value(3).toJsonObject();

//        QStringList keyList = jsonObj.keys();


//        QJsonArray jsonArray = sqlQuery.value(1).toJsonArray();

//        QByteArray jsonByteArr = sqlQuery.value(3).toByteArray();

//        QString jsonString = QString::fromUtf8(jsonByteArr);


//        int timestamp = sqlQuery.value(2).toInt();

//        QDateTime dateTime = QDateTime::fromSecsSinceEpoch(sqlQuery.value(2).toInt(), Qt::UTC);

//        tableList.append(sqlQuery.value(1).toString() + "; " +
//                         QString::fromUtf8(jsonDoc.toBinaryData()) + "; " +
//                         dateTime.toString("dd-MM-yyy hh:mm:ss"));



    }


    //прочитать таблицу dev, поля pcb, eb_id/


    qDebug()<<"tableList "<<tableList;

    formViewTable->show();

    emit sendTableListToTableForm(tableList, humanNameResult, mapWorkUser, userList, intList);



    //прочитать таблицу device
//    QString queryString = QString("Select \"serial\", \"eb_result\"::varchar as \"eb_result\", \"eb_date\" from \"device\";");  //"Select * From \"device\";";

//    QSqlQuery sqlQuery(dataBase);

//    if(!sqlQuery.exec(queryString)) {
//       QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQuery.lastError().text();
//   //    emit slotError(lastErrorQuery + '\n');
//       QMessageBox::information(this, "", lastErrorQuery);
//       return;
//    }

//    QStringList tableList;

//    QMap<QString, QVariant> mapQuery;


//    while (sqlQuery.next()) {

//        QString serialStr = sqlQuery.value(0).toString();

//        QJsonParseError parseError;

//        QString jsonString = sqlQuery.value(1).toString();

//        QJsonDocument jsonDoc = QJsonDocument::fromVariant(sqlQuery.value(1)/*, &parseError*/);

// //        if(parseError.error != QJsonParseError::NoError) {
// //            QMessageBox::information(this, "",parseError.errorString());
// //        }

//        QJsonObject jsonObj = jsonDoc.object();//sqlQuery.value(3).toJsonObject();

//        QStringList keyList = jsonObj.keys();


//        QJsonArray jsonArray = sqlQuery.value(1).toJsonArray();

// //        QByteArray jsonByteArr = sqlQuery.value(3).toByteArray();

// //        QString jsonString = QString::fromUtf8(jsonByteArr);


//        int timestamp = sqlQuery.value(2).toInt();

//        QDateTime dateTime = QDateTime::fromSecsSinceEpoch(sqlQuery.value(2).toInt(), Qt::UTC);

// //        tableList.append(sqlQuery.value(1).toString() + "; " +
// //                         QString::fromUtf8(jsonDoc.toBinaryData()) + "; " +
// //                         dateTime.toString("dd-MM-yyy hh:mm:ss"));



//    }
}

QStringList MainWindow::readUserTable()
{
    //прочитать таблицу user, составить список пользователей
    QString queryString = "Select \"name\", \"pas\", \"type\", \"status\" From \"user\";";

    QStringList userList;
    QStringList listToFormUserControl;

    QSqlQuery sqlQuery(dataBase);

    if(!sqlQuery.exec(queryString)) {
       QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQuery.lastError().text();
       QMessageBox::information(this, "", lastErrorQuery);
       return QStringList();
    }

    while (sqlQuery.next()) {

      listToFormUserControl.append(sqlQuery.value(0).toString() + ";" +
                                   sqlQuery.value(1).toString() + ";" +
                                   QString::number(sqlQuery.value(2).toInt()) + ";" +
                                   QString::number(sqlQuery.value(3).toInt()) );


      if(sqlQuery.value(3).toInt() == 1) { //если поле статус - активен

          userList.append(sqlQuery.value(0).toString());

      }

    }

    emit sendUserTable(listToFormUserControl); //сигнал для формы управления пользователями

    userTable = listToFormUserControl;


   return userList;
}

void MainWindow::on_connectionParams_triggered()
{
    formConnectionParams->show();
}


void MainWindow::on_action_users_triggered()
{
    emit sendCurrentUser(ui->lineEdit_humanName->text());

    formUserControl->show();
}

void MainWindow::slotAddUser(QVector<QString> vector)
{
    qDebug()<<"MainWindow::slotAddUser";

    QString kav = QString('"');
    QString kavOne = QString("'");

    // запись в таблицу user

        //"INSERT INTO \"user\" (\"name\", \"pas\", \"status\", \"type\") VALUES"
 //   "  ('admin', md5('admin'), 1, 1), ('operator', md5('operator'), 1, 2);"

     QString queryStringUser = "INSERT INTO \"user\" (" +
             kav + "name" + kav + "," +
             kav + "pas" + kav + "," +
             kav + "status" + kav + "," +
             kav + "type" + kav +
             ") VALUES (" +
             kavOne + vector.at(0) + kavOne + "," +
             "md5(" + kavOne + vector.at(1) + kavOne + ")" + "," +
            vector.at(3) + "," +
            vector.at(2) +
            ");";

     qDebug()<<"queryStringUser "<<queryStringUser;

     dataBase.transaction();

     QSqlQuery sqlQueryUser(dataBase);

     if(!sqlQueryUser.exec(queryStringUser)) {
        QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryUser.lastError().text();
        dataBase.rollback();
        QMessageBox::information(this, "", lastErrorQuery);
        return;
     }

     dataBase.commit();

     global::pause(1000);

     readUserTable();
}

void MainWindow::slotChangeUser(QVector<QString> vector)
{
    qDebug()<<"MainWindow::slotChangeUser";

    //если новый пароль введён

    qDebug()<<"MainWindow::slotAddUser";

    QString kav = QString('"');
    QString kavOne = QString("'");

    // запись в таблицу user

        //"INSERT INTO \"user\" (\"name\", \"pas\", \"status\", \"type\") VALUES"
 //   "  ('admin', md5('admin'), 1, 1), ('operator', md5('operator'), 1, 2);"

//    UPDATE eb_test SET "date" = current_timestamp(0), "result" = '{"a" : "1", "b" : 2, "c" : 3}', "work_user_id" = 1
//                   WHERE "id" = 9
//                   returning "id";

    QString queryStringUser = "UPDATE \"user\" SET " +
            kav + "pas" + kav + " = " + "md5(" + kavOne + vector.at(1) + kavOne + ")" + ", " +
            kav + "status" + kav + " = " + vector.at(3) + ", " +
            kav + "type" + kav + " = " +  vector.at(2) + " " +
            " WHERE " + kav + "name" + kav + " = " + kavOne + vector.at(0) + kavOne +
            ";";

     qDebug()<<"queryStringUser "<<queryStringUser;

     dataBase.transaction();

     QSqlQuery sqlQueryUser(dataBase);

     if(!sqlQueryUser.exec(queryStringUser)) {
        QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryUser.lastError().text();
        dataBase.rollback();
        QMessageBox::information(this, "", lastErrorQuery);
        return;
     }

     dataBase.commit();

     //если новый пароль введён/

     global::pause(1000);

     readUserTable();
}

void MainWindow::slotDeleteUser(QVector<QString> vector)
{
    qDebug()<<"MainWindow::slotDeleteUser";

    QString kav = QString('"');
    QString kavOne = QString("'");

    // запись в таблицу user

    //DELETE FROM device WHERE CAST(serial AS text) SIMILAR TO '903%';

    QString queryStringUser = "DELETE FROM \"user\" WHERE " +
            kav + "name" + kav + " = " + kavOne + vector.at(0) + kavOne +
            ";";

     qDebug()<<"queryStringUser "<<queryStringUser;

     dataBase.transaction();

     QSqlQuery sqlQueryUser(dataBase);

     if(!sqlQueryUser.exec(queryStringUser)) {
        QString lastErrorQuery = tr("Ошибка запроса SQL: ") + sqlQueryUser.lastError().text();
        dataBase.rollback();
        QMessageBox::information(this, "", lastErrorQuery);
        return;
     }

     dataBase.commit();

     global::pause(1000);

     readUserTable();
}



void MainWindow::on_toolButton_calibrationModeOffRepeat_clicked()
{
    ui->label_StatusBar->clear();

    isCommandsEnded = false;

    if(ui->checkBox_workPlace1->isChecked()) vectorIsWorkPlaceUse[0] = true;
    if(ui->checkBox_workPlace2->isChecked()) vectorIsWorkPlaceUse[1] = true;
    if(ui->checkBox_workPlace3->isChecked()) vectorIsWorkPlaceUse[2] = true;
    if(ui->checkBox_workPlace4->isChecked()) vectorIsWorkPlaceUse[3] = true;

    isCalibrationModeOff1 = false;
    isCalibrationModeOff2 = false;
    isCalibrationModeOff3 = false;
    isCalibrationModeOff4 = false;

    vectorIndicatorStateMatrix[9].fill(false);

    ObjectThread1->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
    ObjectThread2->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
    ObjectThread3->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);
    ObjectThread4->setVectorIndicatorStateMatrix(vectorIndicatorStateMatrix);

    repaint();

    //выключение режима калибровки

    if(vectorIsCommandUse.at(9)) {

        portOptical->close();
        portOptical2->close();
        portOptical3->close();
        portOptical4->close();
        portDigitalInterfaceChecking->close();
        portOptical->clear();
        portOptical2->clear();
        portOptical3->clear();
        portOptical4->clear();
        portDigitalInterfaceChecking->clear();

        ObjectThread1->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread2->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread3->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);
        ObjectThread4->setIsWorkPlaceUseVector(vectorIsWorkPlaceUse);

        QPalette palettePrime = ui->toolButton_calibrationModeOff->palette();
        QColor backgroundColorPrime = palettePrime.color(QPalette::Button);

        QPalette palette = palettePrime;
        palette.setColor( QPalette::Button, QColor( Qt::red )  );

        QColor backgroundColor = palette.color(QPalette::Button);

        qDebug()<<"palette "<<palette
                <<"backgroundColor "<<backgroundColor.name()
                <<"backgroundColorPrime "<<backgroundColorPrime.name();

        ui->toolButton_calibrationModeOff->setAutoFillBackground(true);
        ui->toolButton_calibrationModeOff->setPalette( palette );

//      for(int l=0; l<4; l++) {

//        if(vectorIsWorkPlaceUse.at(l)) {
//            emit signalCalibrationModeOff(l);

//        }

//      }

        emit signalLog("<font color = \"#0000ff\">" + QString("Выключение режима калибровки")  + '\n' + "</font>");

        emit signalCalibModeOffToThread(portOptical, portOptical2, portOptical3, portOptical4);

        //-------------------------Ждём завершения Выключение режима калибровки------------------

        bool isCalibrationModeOffTmp1 = true;
        bool isCalibrationModeOffTmp2 = true;
        bool isCalibrationModeOffTmp3 = true;
        bool isCalibrationModeOffTmp4 = true;

//          if(!vectorIsWorkPlaceUse.at(0)) isPulsesInputVolumeTmp1 = true;
//          if(!vectorIsWorkPlaceUse.at(1)) isPulsesInputVolumeTmp2 = true;
//          if(!vectorIsWorkPlaceUse.at(2)) isPulsesInputVolumeTmp3 = true;
//          if(!vectorIsWorkPlaceUse.at(3)) isPulsesInputVolumeTmp4 = true;

          for(int e=0; e<75; e++) { //5 sec
              global::pause(100);

              if(ui->checkBox_workPlace1->isChecked()) {
                 isCalibrationModeOffTmp1 = isCalibrationModeOff1;

                 if(!vectorIsWorkPlaceUse.at(0)) isCalibrationModeOffTmp1 = true;
              }

              if(ui->checkBox_workPlace2->isChecked()) {
                 isCalibrationModeOffTmp2 = isCalibrationModeOff2;

                 if(!vectorIsWorkPlaceUse.at(1)) isCalibrationModeOffTmp2 = true;
              }

              if(ui->checkBox_workPlace3->isChecked()) {
                 isCalibrationModeOffTmp3 = isCalibrationModeOff3;

                 if(!vectorIsWorkPlaceUse.at(2)) isCalibrationModeOffTmp3 = true;
              }

              if(ui->checkBox_workPlace4->isChecked()) {
                 isCalibrationModeOffTmp4 = isCalibrationModeOff4;

                 if(!vectorIsWorkPlaceUse.at(3)) isCalibrationModeOffTmp4 = true;
              }
//              if(vectorIsWorkPlaceUse.at(0)) isCalibrationModeOffTmp1 = isCalibrationModeOff1;
//              if(vectorIsWorkPlaceUse.at(1)) isCalibrationModeOffTmp2 = isCalibrationModeOff2;
//              if(vectorIsWorkPlaceUse.at(2)) isCalibrationModeOffTmp3 = isCalibrationModeOff3;
//              if(vectorIsWorkPlaceUse.at(3)) isCalibrationModeOffTmp4 = isCalibrationModeOff4;

              if(isCalibrationModeOffTmp1 && isCalibrationModeOffTmp2 &&
                      isCalibrationModeOffTmp3 && isCalibrationModeOffTmp4)
                  break;

          }


        //-------------------------Ждём завершения Выключение режима калибровки------------------/

      ui->toolButton_calibrationModeOff->setPalette(palettePrime);

    }

    isCommandsEnded = true;
    repaint();

    //проверка проводных интерфейсов/

  if(!isRunWithoutConnect) {

    global::pause(500);

    //если хотя бы один результат Не годен, спрашиваем о необходимости записи в бд
    if(workPlace1ResultString == tr("Не годен") || workPlace2ResultString == tr("Не годен") ||
            workPlace3ResultString == tr("Не годен") || workPlace4ResultString == tr("Не годен")) {

        if(dialogWritingDB->exec() == QDialog::Accepted) {

            isNoteWriting = true;

            on_toolButton_externalServerConnect_clicked();

        }
        else {
            isNoteWriting = false;

            saveCounterCheckingResult(1, QString());
        }

    }
    else {

        isNoteWriting = true;

        on_toolButton_externalServerConnect_clicked();

    }

  }


}

































